[{"title":"SCIST x SCAICT Camp 2026 聯合寒訓：AI 系列課程 - 授課心得","url":"/post/SCIST-Camp-2026/","content":"\n> 本篇文章連結：https://4yu.dev/post/SCIST-Camp-2026/\n> 公開發布日期：預計 2026/02/22\n\n# 撰寫中... 即將發佈 敬請期待\n\n\n---\n\n{% btn '/post/Sitemap/',回到導覽頁面,far fa-hand-point-right,blue block center larger %}\n\n---","tags":["資訊社","SCIST","寒訓","營隊","AI","DC Bot","SCAICT","成大電機"],"categories":["心得","營隊"]},{"title":"特殊選才資訊工程學系 心得彙整 by 4yu（114 級）","url":"/post/SPC-CSIE/","content":"\n# 前言\n\n我報名的校系全部都是資訊工程學系，以下是我特選前主要的經歷（目前經歷請看 [About](https://4yu.dev/about/)）：\n\n- SCIST 南臺灣學生資訊社群 S5 總召 & 演算法助教\n- NFIRC 創辦人 & 社長 & 講師\n- APCS 4+4、CPE Professional 排名 176/2406 前 7.3 %\n- 高中學科能力競賽 資訊科 連續兩年複賽佳作\n- AIS3 Junior 2024 最佳專題獎\n- 南四校聯合社課 - AI 人工智慧主題 講師\n- 南九校資訊社 x 成大資工 x SCIST 2024 聯合寒訓 副召\n\n在報名之前有先透過 [114 特選群](https://discord.gg/RbHxzRAmWb) 裡的調查表單搜集到約 130 筆資工特選生的經歷，因為我屬於競程、資安、AI 各領域都有碰的那種，並且還有很大一部份時間是花在創立社團、擔任社群總召、當課程講師...這些經歷上，所以我的檢定競賽成績與其他專注在刷題的人相比較沒那麼有優勢，但比別人多了一些特殊表現，對比各校系名額後評估自己大概的落點會在中字輩左右，並且多報了台師大與海大當作保底學校。\n\n---\n\n# 結果總表\n\n> 以面試日期排序\n\n| 學校 | 組別 | 報名人數 | 進複試 | 面試人數 | 錄取名額 | 錄取率 | 最終結果 | 備取人數 | 狀態 |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 中央大學 | 聯招（一般組） | 56 | ✅ | 15 | 2 | 3.57% | 🔵 備取 1 | 7 | 遞補錄取，已報到 |\n| 中央大學 | 聯招（資安組） | 56 | ✅ | 15 | 1 | 1.79% | 🟢 正取 | 3 | 已放棄 |\n| 臺灣師範大學 | 一般組 | 83 | ✅ | 17 | 5 | 6.02% | 🟢 正取 | 9 | 已放棄 |\n| 臺灣師範大學 | 資安組 | 48 | ✅ | 16 | 3 | 6.25% | 🔴 | 7 |  |\n| 成功大學 | 甲組（競程） | 28 | ✅ | 28 | 4 | 14.29% | 🔴 | 10 |  |\n| 中山大學 | 一般組 | 70 | ✅ | 22 | 3 | 4.29% | 🔵 備取 4 | 7 | 遞補錄取，已放棄 |\n| 中興大學 | 一般組 | 57 | ✅ | 8 | 1 | 1.75% | 🔵 備取 4 | 5 |  |\n| 中興大學 | 資安組 | 44 | ✅ | 19 | 3 | 6.82% | 🟢 正取 | 10 | 已放棄 |\n| 海洋大學 | 一般組 |  | ✅ |  |  |  | 🔴 沒去面試 |  |  |\n| 清華大學 | A 組（一般組） | 87 | ✅ | 26 | 6 | 6.90% | 🔴 |  |  |\n| 陽明交通大學 | 一般組 | 109 | ❌ | 32 | 10 | 9.17% | 🔴 |  |  |\n\n最後中字輩全上（中正大學近幾年特選沒開資工系），滿符合我當初預期的結果，也確定會就讀 **國立中央大學 資訊工程學系**\n\n---\n\n# 各校面試過程\n\n依面試日期排序，若只想看面試問答過程請自行忽略其他內容\n\n\n1. {% btn /post/SPC-NCU/,中央大學,fa-solid fa-hand-point-right,blue %} \n2. {% btn /post/SPC-NTNU/,臺灣師範大學,fa-solid fa-hand-point-right,blue %}\n3. {% btn /post/SPC-NCKU/,成功大學,fa-solid fa-hand-point-right,blue %}\n4. {% btn /post/SPC-NSYSU/,中山大學,fa-solid fa-hand-point-right,blue %}\n5. {% btn /post/SPC-NCHU/,中興大學,fa-solid fa-hand-point-right,blue %}\n6. {% btn /post/SPC-NTHU/,清華大學,fa-solid fa-hand-point-right,blue %}\n\n---\n\n# 特選心得\n\n> 待更新\n\n---\n\n# Q & A\n\n以下問題全部都是我從 Instagram 限時動態提問框蒐集到的問題\n\n1. Q：好奇你競程強，面資安組他會問競程為主還是資安為主 XD\n{% hideBlock 點擊查看回答 %}\n- A：我有面的資安組只有中興跟臺師大，可以去看那兩篇文裡面有詳細的提問與回答，這兩間我都面試兩輪，個人感覺第二輪都會變閒聊沒特別被問資安，都是以自我介紹提到的內容為主\n{% endhideBlock %}\n\n2. Q：想知道怎麼做書審資料😭\n{% hideBlock 點擊查看回答 %}\n\n- A：我自己是從升上高中就開始用 Notion 表格紀錄我的經歷，不管參加什麼比賽或活動都寫上去分類好並上傳獎狀，到特選前就不會忘記自己做過什麼事，也可以很快篩選出哪些經歷對特選是有利的就能寫進備審。備審我是先用 HackMD 寫好全部的文字後再開始排版，整體架構如下：\n{% hideToggle 備審架構 %}\n  - 自傳\n      - 如何接觸資訊領域的\n      - 把所有特殊經歷濃縮\n  - 申請動機\n      - 我為何投入特殊選才：寫自己哪裡特殊\n      - 我為何選擇資工系：寫自己有多適合\n      - 我為何選擇 XX 大學：研究該大學特色與吸引點\n      - XX 大學資工系為何選擇我：寫自己的優勢\n  - 讀書計畫\n      - 近程：大學開學前要達到什麼目標\n      - 中程：大一到大四期間的規劃與目標\n      - 遠程：畢業後的想法\n  - 其他有利資料\n      - 檢定成績\n      - 競賽表現\n      - 社團經營\n      - 社群貢獻\n      - 活動參與\n      - 特殊經歷\n  - 推薦信\n{% endhideToggle %}\n{% endhideBlock %}\n\n1. Q：覺得最有用的經歷或作品是什麼\n\n{% hideBlock 點擊查看回答 %}\n- A：個人感覺在一群那麼強的特選生裡面，對我來說最有用的經歷是創社團 + 當社群總召，因為很少人有這種經驗；作品的話是關於 RL 的 Side Project，有被師大的紀教授深入聊到實作細節\n{% endhideBlock %}\n\n\n4. Q：是不是有人還沒把如何治好拖延症的書看完才會還沒寫完心得\n\n{% hideBlock 點擊查看回答 %}\n- A：是的，從 2024/12 說要寫拖到現在快一年了才全部寫完...那本如何治好拖延症的書從來都沒翻開過。。。\n{% endhideBlock %}\n\n5. Q：會要求組織社團經驗嗎\n{% hideBlock 點擊查看回答 %}\n- A：不一定要有但說不定會加分，因為可以透過這個經歷展現出你的領導能力和規劃能力\n{% endhideBlock %}\n\n6. Q：我當時也有報特選然後貢龜（別的科系），有點好奇上榜者的經歷是不是有甚麼共同點，脫穎而出的關鍵？\n{% hideBlock 點擊查看回答 %}\n- A：特選生的共同點是自學能力都很強，目標明確且會自己找資源學習並持續進步，脫穎而出的關鍵是檢定或競賽成績特別好或是擁有別人沒有的特殊經歷\n{% endhideBlock %}\n\n以上都是挑一部分出來回答而已，其他的都是一堆膜拜或嘲諷，還有一些別的問題就不回答了🤣：可以分一間學校給我嗎、可以跟我組黃氏兄弟嗎。。。如果還有其他問題都歡迎用右側聊天室傳訊息給我，或是參考下方聯絡資訊\n\n---\n\n# 聯絡資訊\n\n有任何疑問或想瞭解更多關於資訊領域、特殊選才相關的事情，甚至是想邀請我去經驗分享的話都歡迎透過以下管道聯絡我：\n- Discord：`shiyu0318`\n- Instagram：`4yu.dev.318`\n- Email：`shiyu@scist.org`\n\n> 2025/10/26 Update: 南十校聯合迎新經驗分享講座簡報公開：https://slides.com/shiyu/share \n\n---\n\n{% btn '/post/Sitemap/',回到導覽頁面,far fa-hand-point-right,blue block center larger %}\n\n---","tags":["資訊工程學系","特殊選才","中央大學","臺灣師範大學","成功大學","中山大學","中興大學","海洋大學","清華大學","陽明交通大學"],"categories":["特殊選才"]},{"title":"資工特選 - 中央大學","url":"/post/SPC-NCU/","content":"\n# 人數\n- 錄取名額：3\n    - 一般組：2\n    - 資安組：1\n    - 採聯招方式\n- 符合報名資格人數：56\n- 過書審進面試人數：15\n# 時程\n- 報名：10/04 ~ 10/09\n- 面試名單：10/22\n- 面試：10/29\n- 放榜：11/19\n\n---\n\n# 面試前\n\n我早起從臺南趕高鐵去桃園，然後坐計程車到中央準時報到，門口滿壯觀的是一個上坡跟中央校徽\n![IMG_6325](https://hackmd.io/_uploads/rJof6MYSlg.jpg)\n\n面試地點在工程五館\n![IMG_6327](https://hackmd.io/_uploads/HJrd0zYSgg.jpg)\n\n\n我們先在二樓特選生休息室等待，冰川超社牛問其他人要不要加入 Discord 群\n\n\n![IMG_6329](https://hackmd.io/_uploads/S1mLJ7FSgg.jpg)\n\n\n由於那教室裡面網路超爛，所以我就出去走廊陽台透氣滑手機，wifecake 走過來跟我聊天（那時還不知道他是誰）\n面試順序是照書審分數由高到低排序的，我是第五位，前一個是 Eason，後一個是冰川，輪到我時有一個酷酷的學長帶上去三樓門口等待，他人超好一直跟我聊天，然後發現他也是臺南人，更巧的是他姐高中跟我同一間，另一個姐跟 Eason 同一間\n\n---\n\n# 面試過程\n\n👨🏻‍🏫：教授（有五個，只有中間那個有講話）\n🤡：我\n\n（學長開門，Eason 走出來，我走進去跟教授打個招呼，然後開簡報）\n🤡：（介紹申請動機與家庭背景）\n🤡：（介紹檢定成績）\n👨🏻‍🏫：（打斷我介紹 直接開問）你是怎麼自學的\n🤡：（回答內容摘要：SCIST 線上資源、網路教材）\n👨🏻‍🏫：你為什麼會想考大學生在考的 CPE\n🤡：（回答內容摘要：檢驗自身程式能力、訓練英文閱讀能力，看看自己在大學生中的排名）（👨🏻‍🏫 轉過去對右邊的教授點頭微笑一下）\n（介紹程式競賽與資安領域的表現）\n👨🏻‍🏫：如何維持大學的學業\n🤡：（回答內容摘要：先修、時間管理）\n🤡：（介紹其他特殊經歷）\n👨🏻‍🏫：進大學後的研究方向\n🤡：（回答內容摘要：深度學習）\n🤡：（未來展望與結尾）\n🤡：請問教授還有問答環節嗎\n👩🏻‍🏫（最右邊的女教授）：因為時間滿久的剛剛問題有問完了\n\n\n中央原本公告：![image](https://hackmd.io/_uploads/SyHzL_ybkx.png)\n實際上：教授在自我介紹時打斷直接開問，中間因為還沒介紹完簡報我怕時間不夠用所以回答的沒有很完整就繼續介紹了，最後用了大概 10 分鐘左右\n\n---\n\n# 面試後\n\n面試完後跟 冰川、Eason、隨風（Eason 的學長 之前的中央資工特選生）一起走去學校外面吃一間不錯的漢堡\n\n![IMG_6331](https://hackmd.io/_uploads/B1c-eXYrxl.jpg)\n\n\n路途一直飄雨感覺中央這地理位置真的很潮濕，後來還去咖啡廳，有聊到他們都沒有被打斷介紹直接問問題，他們覺得是教授是對內容有興趣才會打斷，但我覺得讓我在介紹完簡報後再提問我會回答的更好一點\n\n---\n\n\n# 結果\n\n雖然中央資工分成兩組，但是因為採聯招方式，所以報名時可以兩組都選而且只要繳費一次，面試也是只要一次，放榜之後會依照志願序分配組別\n\n放榜結果：\n\n- 一般組：備取 1（正取 2 人、備取 7 人）遞補錄取\n- 資安組：正取（正取 1 人、備取 3 人）\n\n\n# 心得\n\n中央放榜之後，我心中放下一塊大石，因為第一間就正取了，後面幾間面試時我其實都沒什麼壓力了，個人認為中央資工教授比較喜歡有接觸 AI 的人（一般組正取兩個都是做 AI 專題的旺宏金牌）還有多方面發展的人，太專精在競程反而會給比較低分，因為教授可能已經覺得這人會錄取特別喜歡競程的清大（實例：今年跟去年都有是清大正取且進過 TOI 選訓營一階的人在中央是備取很後面或未錄取），不過我是沒特別專精在某個領域但有很多特殊經歷的，所以在這裡對我來說會比較有優勢，但在其他學校就不一定了\n\n---\n\n{% btn '/post/SPC-CSIE/#%E5%90%84%E6%A0%A1%E9%9D%A2%E8%A9%A6%E9%81%8E%E7%A8%8B',回到特選心得彙整,far fa-hand-point-left,blue block larger %}\n\n{% btn '/post/Sitemap/',回到導覽頁面,far fa-hand-point-right,blue block center larger %}\n\n---","tags":["資訊工程學系","特殊選才","中央大學"],"categories":["特殊選才"]},{"title":"資工特選 - 臺灣師範大學","url":"/post/SPC-NTNU/","content":"\n\n# 人數\n\n\n| 人數             | 一般組 | 資安組 |\n| ---------------- | ------ | ------ |\n| 報名人數         | 83     | 48     |\n| 過書審進面試人數 | 17     | 16     |\n| 錄取名額         | 5      | 3      |\n\n# 時程\n- 報名：10/01 ~ 10/09\n- 面試名單：11/12\n- 面試：11/15\n- 放榜：12/05\n\n---\n\n# 面試前\n\n臺師大把我這個臺南人排在第二個面試，我必須要超早起搭第一班高鐵才能趕得上，第一次在外面等高鐵站開門，還好有 Eason 陪我一起。之前一日資訊營我有來臺師大公館校區當助教所以路途有熟悉的感覺。\n\n![IMG_6469](https://hackmd.io/_uploads/HkDwr9qBel.jpg)\n\n\n---\n\n# 面試過程\n\n臺師大的面試是最特別的，分為三間教室各一個教授，第一間是 3 分鐘自我介紹並要接受提問，第二間是專業問答，有幾個不同主題選兩個並回答問題，第三間是最輕鬆的聊天，有很多卡片可以選擇跟教授聊哪些主題，因為我一般組跟資安組都有進複試所以要面試兩輪\n\n\n## 第一輪面試\n\n### 第一間：自我介紹\n可使用簡報，我有準備也有在報到時用那邊的電腦上傳到他們給的資料夾，但不知道為什麼進到第一間面試時沒有同步過去導致我是沒有簡報直接講完的\n\n\n🤡：我\n👨🏻‍🏫：陳教授\n![image](https://hackmd.io/_uploads/SJ33EMUMyg.png)\n\n🤡：（自我介紹）\n👨🏻‍🏫：Supervised learning 跟 Unsupervised learning 的差別\n🤡：差別在於訓練時有沒有 Label，監督式學習資料與標籤之間的關係可以用來預測新資料，\n    非監督式學習是要找出資料之間隱藏的內部結構\n👨🏻‍🏫：你的強化學習專案是用什麼算法\n🤡：有用過 DQN 和 PPO\n👨🏻‍🏫：Loss Function 有什麼不同\n🤡：DQN 是透過最小化誤差來學習 Q 值，PPO 比較像是學習一個策略\n👨🏻‍🏫：有考英文檢定嗎\n🤡：目前正在準備多益\n\n\n聊到外面學長敲門才出去，問到的都有回答出來，感覺第一間自我介紹的提問比第二間專業問題的提問還要更專業，還有很多人說在第一間被全英文問答，教授口音又很重，他們感覺滿慌的，我最後一題回答完後剛好學長敲門我才沒被用英文問，後來去查臺師大教授名單找了才知道原來專長是機器學習還在國外留學過難怪會這樣\n\n### 第二間：專業問答\n\n\n\n🤡：我\n👨🏻‍🏫：紀教授\n![image](https://hackmd.io/_uploads/Bk09PfLf1g.png)\n\n🤡：（進去先簡單自我介紹了一分鐘）\n👨🏻‍🏫：螢幕上的主題選兩個，可以不用選資安，因為你這次面完要接著考筆試\n\n| | | |\n|---|---|---|\n| 演算法 | 資料結構 | 程式設計 |\n| ? | ? | ? |\n| 資訊安全 | 人工智慧 | ? |\n| X | 其他 | X |\n> 我忘記 ? 的是什麼了\n\n🤡：人工智慧 和 資料結構\n👨🏻‍🏫：解釋 圖靈測試\n🤡：由艾倫圖靈提出的思想實驗，目的是在測驗電腦能不能讓人類分辨不出來是在跟人還是電腦對話\n👨🏻‍🏫：解釋 K-NN\n🤡：K 近鄰算法，機器學習裡面預測一個新資料是哪個類別時，看看離它最近的 K 個資料是什麼類別來決定答案\n> 然後就開始聊我的強化學習專案技術細節：Reward Funtion 是如何設計之類的\n\n👨🏻‍🏫：好先換資料結構 解釋 stack 特性與應用\n🤡：特性是先進後出，像堆疊盤子一樣，先想到應用的是括號匹配的題目，還有維護單調隊列之類的\n👨🏻‍🏫：BST 最佳 / 最差情況 & 如何解決\n🤡：最佳情況的話 BST 是平衡的 O(log N)，最差會變成一條鏈 O(N)，解決方法就是用像 set 這種底層是紅黑樹之類的資料結構\n\n\n\n### 第三間：卡片閒聊\n\n\n🤡：我\n👨🏻‍🏫：蔣教授\n![image](https://hackmd.io/_uploads/BkFiVGIfkl.png)\n👨🏻‍🏫：應該知道第三關要做什麼吧\n🤡：有先上網看過別人心得，結果真的是卡片\n👨🏻‍🏫：四張主要卡片選幾張介紹自己：\n> 可複選所以我選擇全部都講一次\n1. 高中生活：描述高中生活\n🤡：高一開始考 APCS 並創了校內資訊社團，高二經營社團、到處打比賽、參與社群、擔任各種課程講師、高三擔任社群總召、準備特選，因為一直都有目標而且想持續進步所以過得滿精彩的\n1. 特殊之處：與其他特選生的不同之處\n🤡：除了刷題精進自己能力以外，還有創社、講課、投入社群等不同的多元表現\n1. 特殊選才：為何投入特殊選才、何時開始的、做了什麼準備\n🤡：因為有這些特殊經歷讓我想嘗試、高二暑假、調整心態和規劃未來\n1. 未來展望：希望進大學後成為一個怎樣的人\n🤡：成為自己想要的樣子，為了目標努力，充實自己大學生活的人\n\n\n👨🏻‍🏫：選 3 張卡片描述未來想做的事\n\n1. 社團領導\n2. 師資培育\n3. 學術研究\n4. 海外留學\n5. 程式競賽\n6. 企業培訓\n\n\n> 我其實也想每張都選，但最後選了 3 張能讓我結合自身經歷的\n1. 社團領導：對應我創社當社長和擔任社群總召的經歷\n2. 師資培育：對應擔任課程講師、助教的經歷\n3. 程式競賽：可以組隊打 ICPC 之類的競賽\n\n> 講完之後教授翻開卡片背面，每張背面都有台師大歷屆學生的相關成果，有點宣傳的效果\n\n\n整個過程滿輕鬆的，教授全程笑笑的，感覺真的是想透過卡片與聊天過程認識一個人的經歷與特質，我回答的時候有下意識地挑一些對我比較有優勢的地方特別提出來講，所以第一輪面試很順利也還滿有把握的\n\n---\n\n## 資安組筆試\n\n資安組除了面試之外還有筆試，我甚至當天到現場才知道這件事，根本完全沒準備 🤡，而且時間超級緊迫，我第一輪面試完要馬上衝去別棟筆試完再回來面試第二輪\n\n### 一、程式設計\n1. ans = ?\n```c\n#include<stdio.h>\nint main(){\n    int ans=0;\n    for(int i=0,j=0;i<5;j+=(i++))\n        ans+=j;\n    printf(\"%d\",ans);\n}\n```\n2. ans = ?\n```c\n#include<stdio.h>\nint f(int x,int y){\n    return x | (1 <<y);\n}\nint main(){\n    int ans = f(2,7);\n    printf(\"%d\" , ans);\n}\n```\n3. 當輸入 50 時\n    - 為何會印出 50 0 0？\n    - 為何會印出stack smashing detected？\n```c\n#include<stdio.h>\nint main(){\n    int8_t a=10 ,b=23, c=44;\n    scanf(\"%d\",&a);\n    printf(\"%d%d%d\",&a,&b,&c);\n}\n```\n\n### 二、系統安全\n\n1. linux 檔案權限中的 s 是什麼意思？\n2. proc/version 為何佔用 0 byte\n3. 如果要將 test.pdf 隱藏起來，那該要怎麼去打 linux command\n\n### 三、網路\n\n1. ping 的原理\n2. 家中的ip分享器原理\n3. 為何網頁有時會顯示不安全，至少寫出3個原因\n\n### 四、密碼學\n\n1. 手算凱撒密碼（密文忘了）\n2. 在 1～124 中取一個數乘以 17，再除以 125 要餘 1，1～143 中與 143 互質的數有幾個\n3. 證明 16 bits 的 key 不安全\n\n\n> 感謝 yih 背出來的題目 Orz\n\n\n寫完之後回到原本那棟的地下一樓休息室等第二輪面試，遇到很多認識的人，大家一起聊天，OsGa 好兄弟剛好在台北還特別過來師大陪我們一起，也遇到了 Ricky，他想從臺科大重特到臺師大，詳細過程可以看 [這篇文章](https://ricky.place/posts/journey-ntust-to-ntnu-20250705/) 真心滿佩服他的勇氣的，然後因為第一間自我介紹我有準備簡報但用不了就去找行政人員問了一下，發現另一個女生也跟我遇到同樣問題一起來問，我覺得他滿眼熟的感覺是我當某一場課程講師教過的學員。後來我重新上傳了一次在第二輪終於有簡報可以用了\n\n---\n\n## 第二輪面試\n\n### 第一間\n\n> 用簡報快速帶過第一輪介紹過的經歷，因為是資安組面試所以最後有詳細補充我在 AIS3 Junior 2024 拿到最佳專題獎的實作內容\n\n👨🏻‍🏫：LLaMA 是什麼\n\n> 他的反應讓我感覺不是要我解釋 LLM，而是他真的不知道有 LLaMA，直到我說類似 GPT 他才懂）\n\n👨🏻‍🏫：AI 想的漏洞攻擊方法有比人類更好、更快嗎，如果沒有的話，你們專案有 AI 跟沒 AI 有什麼差別\n> 顯然完全放錯重點，我們專案是模擬駭客利用購物網站上的 AI 客服助手透過 Prompt Injection 的方式攻擊網站漏洞，而不是讓 AI 想出攻擊方法，反正他一直重複問類似的問題，我不管回答什麼他都跳針到最後時間結束，感覺他自己不太接觸資安領域，所以隨便想了個問題來一直問，出去之後覺得心情滿差的\n\n\n### 第二間：專業問答\n\n教授看到我又來一次，就不考專業問題了，直接開始聊天\n\n👨🏻‍🏫：你覺得剛剛考資安筆試的題目如何\n> 因為這份題目是他出的\n\n👨🏻‍🏫：有什麼問題想問嗎\n🤡：我想問關於 APCS 改制的問題，因為看到網路上有消息透露 APCS 要改成類似英檢那樣分級的新制度，這是假消息還是已經確定了\n👨🏻‍🏫：你們消息傳好快，是有這件事不過我是不太清楚詳細內容，而且負責的教授現在人在國外。時間還很多還有想問的嗎\n🤡：那我想了解一下師資培育的一些細節\n👨🏻‍🏫：校內有指定要修師培的課，然後要考核通過才行，我自己也是負責師資培育的，看過外面很多不太合格的資訊老師，所以對臺師大的學生滿有信心的\n🤡：那臺師大有什麼資源可以先修或需要提前準備什麼事情\n👨🏻‍🏫：我有開 TouTube 頻道：[Neokent 的線上課程](https://www.youtube.com/channel/UC1EpSGnc7eX2Cr9XgBUQqIw) 可以去按讚訂閱分享開啟小鈴鐺。不然你之前是透過什麼資源學程式的\n🤡：之前學程式是參加 [SCIST 演算法培訓課程](https://www.youtube.com/c/OfficialSCIST) ，我現在擔任 S5 的總召\n👨🏻‍🏫：每年都會有 SCIST 的人上來這裡面試，印象滿深刻的\n\n\n### 第三間：專業問答\n\n> 教授看到我又來了就說不用翻卡牌了 直接開始閒聊\n\n👨🏻‍🏫：上面的教授都問了什麼\n👨🏻‍🏫：想問你們考生對目前 APCS 的看法\n👨🏻‍🏫：為什麼會想投資安組 還是想說順便投的\n🤡：雖然資安經歷比較沒有競程經歷多，但對資安和 AI 領域都有興趣\n\n> 教授看了桌上的表，上面有大家的主要經歷\n\n👨🏻‍🏫：你會兩組都進是因為有其他特殊經歷是別人沒有的所以加了不少分\n👨🏻‍🏫：你有 AIS3 最佳專題獎，今天很多人也都有，想知道為什麼\n🤡：除了不同年度之外，還分為 AIS3 和 AIS3 Junior，AIS3 有不同類別的主題，每個主題都有最佳專題獎，AIS3 Junior 則是只有前兩名有，所以今天才會有那麼多人有最佳專題獎。\n\n---\n\n## 面試後\n\n面試後跟一群人（OsGa、Ricky、yih、soar）一起去吃師大學餐，自助餐價格跟菜色都還算可以，但是餐廳滿熱的，吃完就跟 Eason 逛北車地下街，最後搭客運還差點趕不上，因為我們不知道上車的地方在五樓，總之就是行程很趕很累的一天\n\n---\n\n## 結果\n\n### 一般組：正取（正取 5 人、備取 9 人）\n### 資安組：未錄取（正取 3 人、備取 7 人）\n\n---\n\n{% btn '/post/SPC-CSIE/#%E5%90%84%E6%A0%A1%E9%9D%A2%E8%A9%A6%E9%81%8E%E7%A8%8B',回到特選心得彙整,far fa-hand-point-left,blue block larger %}\n\n\n{% btn '/post/Sitemap/',回到導覽頁面,far fa-hand-point-right,blue block center larger %}\n\n---","tags":["資訊工程學系","特殊選才","臺灣師範大學"],"categories":["特殊選才"]},{"title":"資工特選 - 中興大學","url":"/post/SPC-NCHU/","content":"\n\n\n# 人數\n\n| 人數             | 一般組 | 資安組 |\n| ---------------- | ------ | ------ |\n| 報名人數         | 57     | 44     |\n| 過書審進面試人數 | 8     | 19     |\n| 錄取名額         | 1      | 3      |\n\n# 時程\n- 報名：10/28 ~ 11/10\n- 面試名單：12/02\n- 面試：12/06\n- 放榜：12/20\n\n\n---\n\n# 面試過程\n\n中興我也是兩組都報名都進所以要面試兩次，有兩間教室一間面試一間給特選生休息和社交，然後時間到要出去走廊坐椅子排隊準備，面試要坐在講台自我介紹且沒有簡報，下面有五位教授坐一排輪流提問\n\n## 第一次面試\n\n👨🏻‍🏫：教授\n🤡：我\n\n🤡：（自我介紹）\n👨🏻‍🏫 1：除了程式以外你知道資工系還有哪些課程嗎\n🤡：除了程式以外有比較重要的數學例如微積分、離散、線性代數、機率與統計之類的\n👨🏻‍🏫 2：介紹一下 Heap\n🤡：一個可以用來維護極值的資料結構\n👨🏻‍🏫 2：那跟直接找有什麼差別？\n🤡：用 Heap 時間複雜度是 $O(\\log n)$，直接找要 $O(n)$\n👨🏻‍🏫 2：為什麼？\n🤡：因為 Heap 是一個完全二元樹\n👨🏻‍🏫 2：那插入元素怎麼實作\n🤡：先放在最左葉節點，然後一直不斷跟父節點交換直到保證所有子節點都比較小\n👨🏻‍🏫 3：當講師的課程內容是什麼\n🤡：自己編的課程教材有 Python 語法、C++ 語法、基本資料結構和演算法、AI 機器學習入門\n👨🏻‍🏫 4：介紹一下學科能力競賽\n🤡：教育部辦給高中生的演算法競賽，分區域複賽和全國決賽，有兩年拿到複賽佳作\n\n## 第二次面試\n\n👨🏻‍🏫 5：又見面了！\n🤡：（補充資安 & AI 經歷）\n👨🏻‍🏫 5：未來想從事什麼工作\n🤡：AI 軟體工程師\n👨🏻‍🏫 3：有具體一點的方向嗎\n🤡：RL 應用例如 FSD 全自動駕駛系統之類的\n👨🏻‍🏫 3：不錯 那還有很多東西要學\n👨🏻‍🏫 1：你在台南讀書，你那間學校和家齊、南二中有什麼區別\n🤡：我們學校是綜高，其他都是高中，而我是普高自然組...（後面不知道講到什麼就順便帶到創社團和辦營隊的事情了）\n👨🏻‍🏫 4：那你上大學之後想做什麼事\n🤡：：加入實驗室做 AI 研究，然後持續推廣資訊教育之類的\n\n\n補充：Eason 後來有跟我說他除了也被問 Heap 之外還被問到 OOP 是什麼\n\n---\n\n# 面試後\n\n當天剛好也是海洋大學面試，有些人面完中興馬上衝去基隆，雖然我也有進海大複試但我選擇不去，跟剩下的一些人待在休息室社交，結果有一位教授就過來跟我們聊天，在場的特選生有 @chao、@Sam、@y1wen、@che\n\n![IMG_6639 (1)](https://hackmd.io/_uploads/SJyXXPrJZe.jpg)\n\n![image](https://hackmd.io/_uploads/BJvt6egNyl.png)\n\n教授就問我們從哪裡來的 感覺他很認真聽我們的自我介紹，對每個人都有印象，然後說今年有面試是他發起的因為去年沒有，chao 有問教授說資安組的條件其實一般組也達得到，如果一般組沒資安背景的人來特資安組有機會上嗎？教授說其實進來後都是資工系沒有分組 只是這幾年有多了資安外加名額，讓面試的時候分流，不過都還是要會寫程式才會錄取\n\n後來下午還有很多時間我就在校園到處逛逛，發現學校裡就有 Subway、85°C、路易莎，中央輸光\n\n![IMG_6649 (1)](https://hackmd.io/_uploads/Byf2VwByWg.jpg)\n\n然後在吃小木屋鬆餅的時候接到海大打過來的面試提醒電話。\n\n![IMG_6653 (1)](https://hackmd.io/_uploads/BJkeUwHJWg.jpg)\n\n\n---\n\n\n# 結果\n\n- 一般組：備取 4（正取 1 人、備取 7 人）遞補到備取 2\n- 資安組：正取（正取 3 人、備取 10 人）遞補到備取 6\n\n---\n\n{% btn '/post/SPC-CSIE/#%E5%90%84%E6%A0%A1%E9%9D%A2%E8%A9%A6%E9%81%8E%E7%A8%8B',回到特選心得彙整,far fa-hand-point-left,blue block larger %}\n\n{% btn '/post/Sitemap/',回到導覽頁面,far fa-hand-point-right,blue block center larger %}\n\n---\n\n","tags":["資訊工程學系","特殊選才","中興大學"],"categories":["特殊選才"]},{"title":"資工特選 - 中山大學","url":"/post/SPC-NSYSU/","content":"\n\n# 人數\n- 錄取名額：3\n- 符合報名資格人數：70\n- 過書審進面試人數：22\n# 時程\n- 報名：10/16 ~ 10/22\n- 面試名單：11/19\n- 面試：11/22\n- 放榜：12/11\n\n---\n\n# 面試前\n\n中山面試前 3 天中央就放榜了，因為我是正取已經有學校讀了所以那天完全沒有任何壓力，就當作是去高雄一日遊，我甚至穿短褲去面試（因為高雄很熱）\n感謝跟我同校的許又勻（特選生命科學系）的媽媽開車載我們去面試\n面試在下午所以中午先跟 Eason、冰川、Youtong 先去吃中山學餐，那個樓層設計很酷，選擇滿多的但我點的唐揚雞便當不好吃，旁邊有山有海風景很好\n\n---\n\n# 面試過程\n\n中山是分組團體面試，每組有三個人，在一間超小教室有一個 ㄇ 字型桌子，三個人分別坐在一個邊，要帶自己的電腦展示簡報，有四位教授分成兩組輪流進來聽我們個別自我介紹並現場問答，所以可以聽得到其他兩人的經歷和回覆\n\n\n## 第一組教授\n\n👨🏻‍🏫：教授\n🤡：我\n👩🏻‍💻：女特選生\n👨🏻‍💻：男特選生\n\n\n\n\n\n👩🏻‍💻：（自我介紹：科技女孩計畫、英文很強、數學建模）\n👨🏻‍🏫：科技女孩計畫是什麼？\n👩🏻‍💻：去美國參加夏令營、在國務院演講\n👨🏻‍🏫：解釋剛剛提到的費馬最後定理如何用數學建模\n👩🏻‍💻：忘記了\n👨🏻‍🏫：$x^n + y^n = z^n$ 在 $n > 2$ 時沒有正整數解\n\n\n\n🤡：（自我介紹）\n👨🏻‍🏫：跟科技公司合作的那個是什麼？\n🤡：在當 SCIST 總召前有舉辦過演算法+資安實體營隊，有邀請贊助 SCIST 的科技公司合作演講活動\n👨🏻‍🏫：你的程式網站有什麼內容？可以 Demo 一下嗎？\n🤡：（現場打開這個網站 https://4yu.dev 滑這些文章給教授看）\n\n\n\n👨🏻‍💻：（自我介紹：APCS 4+3、資研社教學）\n👨🏻‍🏫：為什麼自走車要用 DFS？有嘗試過其它算法嗎？\n👨🏻‍💻：讓他探索碰到死路就換一條，沒有嘗試過別的算法\n\n## 第二組教授\n\n![image](https://hackmd.io/_uploads/B1h-dQCMkg.png)\n![image](https://hackmd.io/_uploads/r1JgOX0fkx.png)\n\n👩🏻‍💻：（自我介紹）\n👨🏻‍🏫：有沒有程式相關經驗？\n👩🏻‍💻：在數學建模時有用過 Python\n👨🏻‍🏫：在國務院演講是什麼樣的活動？\n👩🏻‍💻：科技少女計畫\n\n\n\n🤡：（自我介紹）\n👨🏻‍🏫：你 CPE 檢定考到專業級的感想，對 CPE 有什麼建議（這個楊教授就是負責主辦 CPE 的）\n🤡：我覺得考 CPE 可以練習到程式還可以順便練習英文還不錯，建議的話是每次考試的難度浮動可以稍微降低一點\n👨🏻‍🏫：你說你以無指導老師的身份代表學校參賽是什麼？你覺得有指導老師跟沒指導老師的差別\n🤡：高中資訊學科能力競賽，沒有指導老師較考驗自學能力\n\n\n\n👨🏻‍💻：（自我介紹）\n👨🏻‍🏫：為什麽不用 BFS\n👨🏻‍💻：沒嘗試過\n👨🏻‍🏫：遇到障礙物能及時反應嗎\n👨🏻‍💻：有在程式裡面判斷\n👨🏻‍🏫：vector array 差別\n👨🏻‍💻：可以改變長度\n\n---\n\n# 意外插曲\n\n眾所周知，中山大學有很多猴子🐒，我去面試前的路上邊走邊吃冰 🤡，直接被一隻猴子襲擊，不只搶走我的冰還把我的右手背抓出一道傷口😡\n\n![IMG_6528](https://hackmd.io/_uploads/B1I9hSSJWl.jpg)\n\n\n學長幫我簡單消毒後帶傷面試完才搭捷運去大同醫院打破傷風疫苗，董油桐在旁邊一直笑我😮‍💨\n\n\n![IMG_6531](https://hackmd.io/_uploads/rktnpSB1Zl.jpg)\n\n\n# 面試後\n\n打完疫苗我跟 Youtong 和 Eason 就去駁二走走逛逛，還搭了輕軌，我覺得高雄給我的感覺很 Chill，我會想住在高雄但不會想讀中山😂，晚上還去吃了一間要等超久但很頂的拉麵😋\n\n![IMG_6535 (1)](https://hackmd.io/_uploads/Byomy8H1-l.jpg)\n![IMG_6538 (1)](https://hackmd.io/_uploads/ryi_18Hk-x.jpg)\n![IMG_6543](https://hackmd.io/_uploads/BJNjJUB1Wg.jpg)\n![28779D94-49D6-4A7F-B01A-DDD24B180944](https://hackmd.io/_uploads/HkFak8HyWg.jpg)\n\n\n---\n\n\n# 結果\n\n備取 4（正取 3 人、備取 7 人）遞補錄取\n\n---\n\n{% btn '/post/SPC-CSIE/#%E5%90%84%E6%A0%A1%E9%9D%A2%E8%A9%A6%E9%81%8E%E7%A8%8B',回到特選心得彙整,far fa-hand-point-left,blue block larger %}\n\n\n{% btn '/post/Sitemap/',點擊回到導覽頁面,far fa-hand-point-right,blue block center larger %}\n\n---","tags":["資訊工程學系","特殊選才","中山大學"],"categories":["特殊選才"]},{"title":"資工特選 - 清華大學","url":"/post/SPC-NTHU/","content":"\n\n\n# 人數\n\n| 人數             | A 組（競程） | B 組（資安） |\n| ---------------- | ------ | ------ |\n| 報名人數         | 87     | 26     |\n| 過書審進面試人數 | 26     | 23     |\n| 錄取名額         | 6      | 3      |\n\n# 時程\n- 報名：10/08 ~ 10/14\n- 面試名單：11/29\n- 面試：12/08\n- 放榜：12/13\n\n\n---\n\n# 面試前\n上次來清大是 IONC 真懷念，搭高鐵上來北部發現變冷了\n![IMG_6667](https://hackmd.io/_uploads/HkM7PuB1Wl.jpg)\n\n在休息室社交，看劉宇勝大跳「解開我」，旁邊還有冰川，清大面試就看到一些進資訊奧林匹亞選訓營的電神，已經想到自己可能不會錄取了，單純來體驗的而已\n![IMG_9130](https://hackmd.io/_uploads/r11CL_Hy-g.jpg)\n\n\n---\n\n# 面試過程\n分為兩間教室，第一間自我介紹+問答，第二間有競賽題目要逐一翻開現場思考並說明做法\n\n## 第一間\n\n👨🏻‍🏫：教授\n🤡：我\n\n🤡：（自我介紹）\n👨🏻‍🏫：你學習的資源都如何獲取\n🤡：SCIST 線上資源 & 實體培訓\n👨🏻‍🏫：怎麼拉到 30 萬贊助的\n🤡：寫計畫書，寄信給科技公司邀請合作\n👨🏻‍🏫：如何達成合作的，是單方面投資嗎\n🤡：算是互利，有不同贊助方案，協助企業曝光和培育人才\n👨🏻‍🏫：怎麼有那麼多時間投入這些多元表現的，那些社群啊、社團和競賽之類的\n🤡：壓縮自己的娛樂和休息時間，有熱忱和目標就會一直投入時間在這些事情上面\n\n## 第二間\n\n1. 完全連接多重圖，按特定順序移除點，問何時 1 與 v 不連通？|E| <= 2|V|。\n\n2. N 人分 K 組，任兩組之間的仇恨值為 F(A, B) = min(f(a, b), ∀a∈A, b∈B)，使任兩組仇恨值最小值最大。\n\n3. N*N 的棋盤，盤上有一些棋，可重複移除最上、下一列，左、右一行，每次移除不可超過 K 顆棋，你會怎麼移除？\n\n4. 總共有 N 層樓，從一樓開始需要到達指定樓層 K，總共有 M 個電梯從左往右排，電梯能從一個區間 [l, r] 搭並且只能搭到 r 樓，你只能在同一層由左往右走不能回頭。\n\n\n# 面試後\nKoying 跟 temmie 帶我們去吃了一間火鍋，吃完到超算的實驗室逛逛，然後又去吃了好吃的豆花冰沙\n\n![IMG_6684](https://hackmd.io/_uploads/rJvu8uHkWe.jpg)\n\n![IMG_6694](https://hackmd.io/_uploads/SJ1tIuSJbx.jpg)\n\n---\n\n\n# 結果\n\n- 未錄取（正取 6 人、備取 11 人）遞補到備取 9\n\n\n---\n\n{% btn '/post/SPC-CSIE/#%E5%90%84%E6%A0%A1%E9%9D%A2%E8%A9%A6%E9%81%8E%E7%A8%8B',回到特選心得彙整,far fa-hand-point-left,blue block larger %}\n\n{% btn '/post/Sitemap/',回到導覽頁面,far fa-hand-point-right,blue block center larger %}\n\n---\n\n","tags":["資訊工程學系","特殊選才","清華大學"],"categories":["特殊選才"]},{"title":"資工特選 - 成功大學","url":"/post/SPC-NCKU/","content":"\n\n# 人數\n| 人數             | 甲組（競程） | 乙組（開發） |\n| ---------------- | ------ | ------ |\n| 報名人數         | ?     | ?     |\n| 過書審進面試人數 | 28     | 42     |\n| 錄取名額         | 4      | 4      |\n\n# 時程\n- 報名：10/17 ~ 10/23\n- 面試名單：11/08\n- 面試：11/16\n- 放榜：12/11\n\n---\n\n成大沒有面試只有上機考，分為甲組（競程）和乙組（開發），甲組就是考一些 DSU、Greedy、快速冪、LCA+倍增法、歐拉定理之類的東西，詳細題目忘記了沒背出來，我當天超級燒雞，打不贏那些全國賽競程選手，最後當然是沒上，然後我們這屆是成大資工最後一屆特選甲組，蘇文鈺教授說 115 就會把甲組名額給乙組了，乙組的話是考模擬無人車協作之類的專案，好像是要 debug 或寫新功能吧，然後要會用 Docker + GitLab CI/CD，優勢是乙組可以用 AI 協助，所以有人上機考前付費訂閱了 Claude 丟問題上去就能拿到分數了超好笑\n\n![IMG_6487 (1)](https://hackmd.io/_uploads/Hkm9FLSJWe.jpg)\n\n\n![IMG_6494 (1)](https://hackmd.io/_uploads/SkGW58B1Zl.jpg)\n\n\n\n---\n\n{% btn '/post/SPC-CSIE/#%E5%90%84%E6%A0%A1%E9%9D%A2%E8%A9%A6%E9%81%8E%E7%A8%8B',回到特選心得彙整,far fa-hand-point-left,blue block larger %}\n\n{% btn '/post/Sitemap/',回到導覽頁面,far fa-hand-point-right,blue block center larger %}\n\n---","tags":["資訊工程學系","特殊選才","成功大學"],"categories":["特殊選才"]},{"title":"NFIRC 南附資研社 - 從零開始的社團經營之路","url":"/post/NFIRC/","content":"\n# [創社計畫](https://hackmd.io/@YuDong/ashsnutn_csirc)\n\n# 創社歷程、成果、心得與反思\n## 撰寫中 ...\n\n# [第一屆年報](https://online.fliphtml5.com/thcty/kwmf/)\n\n---\n\n{% btn '/post/Sitemap/',回到導覽頁面,far fa-hand-point-right,blue block center larger %}\n\n---","tags":["南附資研社","NFIRC 1st"],"categories":["心得","社團"]},{"title":"資料結構 進階實作（C++）","url":"/post/Data-Structures/","content":"\n# 本篇文章仍在撰寫中 請稍等內容完整後再閱讀...\n\n> 本篇文章連結：https://4yu.dev/post/Data-Structures/\n\n\n# Intro\n\n此篇文章使用 C++ 來實作各種從基礎到進階的資料結構\n可先閱讀這篇關於 C++ 內建基礎資料結構的 {% btn /post/STL/, C++ STL 大全,fa-solid fa-hand-point-right,blue %} 後再回來繼續\nSTL 中的基礎資料結構只需學會如何應用即可，而此篇的資料結構則是要自行實作\n內容一樣很多，若有編寫錯誤之處請使用右側聊天室回報給我，將盡快修改\n\n---\n\n# 實作資料結構\n\n本篇包含以下資料結構的實作\n\n- 前綴和 & 差分數列\n- 樹狀數組 BIT\n- 稀疏表 Sparse Table\n- 線段樹 Segment Tree\n- 鏈結串列 Linked-list\n- 並查集 DSU\n- 二元搜尋樹 BST\n- 樹堆 Treap\n- 伸展樹 Splay Tree\n- 字典樹 Trie\n- rope\n- pbds\n\n---\n\n## 前綴和 & 差分數列\n\n本篇開頭以此做為基礎，與其稱呼它們為資料結構，我更傾向將它們視為一種能有效的降低時間複雜度的重要預處理技巧\n\n前綴和（Prefix Sum）可以簡單理解為 `數列由前往後累加的值`\n\n![image](https://hackmd.io/_uploads/Hyl0qg__C.png)\n\n### 建出前綴和數列\n```cpp=\n#include <bits/stdc++.h>\nusing namespace std;\n\nsigned main() \n{\n    int n; cin >> n;\n    vector<int> v(n), p(n+1);\n    p[0] = 0;\n    for(int i=0;i<n;++i)\n    {\n        cin >> v[i];\n        sum[i+1] = v[i] + p[i];\n    }\n    for(auto i:p) cout << i << ' ';\n}\n```\n> 注意：前綴和數列會比原數列多了一項，記得初始化第 0 項為 0\n#### Input\n```txt=\n5\n1 2 3 4 5\n```\n#### Output\n```txt=\n0 1 3 6 10 15 \n```\n\n### 快速查詢區間和\n\n要查詢數列區間 $[l,r]$ 的和，原始方法是用迴圈慢慢加\n```cpp=\nint sum = 0;\nfor(int i=l;i<=r;++i) sum += p[i];\n```\n有了前綴和後，每次查詢使用一次減法 `第 r+1 項 - 第 l 項` 即可快速取得區間和，直接將時間複雜度從 $O(n)$ 降到 $O(1)$\n\n![image](https://hackmd.io/_uploads/rJzZoxO_C.png)\n\n```cpp=\nint q,l,r; cin >> q;\nwhile(q--)\n{\n    cin >> l >> r;\n    cout << p[r+1] - p[l] << '\\n';\n}\n```\n\n### 內建函數\n\nstd 內建了可以建立前綴和的函數 `partial_sum(原數列起點, 原數列終點, 新數列起點)`，使用方法如下：\n```cpp=\n#include <bits/stdc++.h>\nusing namespace std;\n\nsigned main() \n{\n    int n; cin >> n;\n    vector<int> v(n), p(n+1);\n    for(auto &i:v) cin >> i;\n    partial_sum(v.begin(), v.end(), p.begin()+1);\n    for(auto i:p) cout << i << ' ';\n}\n```\n\n\n> 前綴和能快速取得區間和，而快速取得區間的最大/最小值則會用到本篇內容之一的 `稀疏表 Sparse Table`\n\n> 補充：後綴和（Suffix Sum）\n會前綴和就知道後綴和就是由後往前累加的值，可以自己試著建看看\n\n### 二維前綴和\n\n二維前綴和是前綴和概念在二維空間的擴展，可快速查詢二維平面上任意子矩形的數值總和\n\n![image](https://hackmd.io/_uploads/HyfiOMd_R.png)\n\n首先要先了解排容原理\n\n$A \\cup B = A + B - A \\cap B$\n\n![image](https://hackmd.io/_uploads/B1GD0zOOA.png)\n\n而二維前綴和也運用了這個原理\n\n![image](https://hackmd.io/_uploads/BkG-mX__A.png)\n\n#### 建出二維前綴和\n```cpp=\n#include <bits/stdc++.h>\n#define RPT(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\n\nconst int N = 100;\nint tb[N][N], pre[N][N];\n\nsigned main() \n{\n    int r,c; cin >> r >> c;\n    RPT(i,r) RPT(j,c)\n    {\n        cin >> tb[i][j];\n        pre[i][j] = pre[i-1][j] + pre[i][j-1] \n                  - pre[i-1][j-1] + tb[i][j];\n    }\n    RPT(i,r) RPT(j,c) cout << pre[i][j] << \" \\n\"[j == c];\n}\n```\n\n#### Input\n```txt=\n3 3\n1 2 3\n4 5 6\n7 8 9\n```\n#### Output\n```txt=\n1 3 6\n5 12 21\n12 27 45\n```\n\n#### 查詢子矩形總和\n\n\n建完二維前綴和後每個子矩形皆會在右下角的點形成總和\n查詢任意子矩形都可以用排容原理計算出來\n不用使用雙重迴圈一個一個加起來\n以下示範計算 (x1,y1) 到 (x2,y2) 的子矩形總和\n\n![image](https://hackmd.io/_uploads/rySi57u_C.png)\n\n```cpp=\nint q; cin >> q;\nwhile(q--)\n{\n    int x1,x2,y1,y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1--; y1--;\n    int sum = pre[x2][y2] - pre[x1][y2] \n            - pre[x2][y1] + pre[x1][y1];\n    cout << ans << '\\n';\n}\n```\n\n### 差分數列\n\n與前綴和相反的概念，差分數列為原數列相鄰元素的差值\n\n#### 建出差分數列\n```cpp=\n#include <bits/stdc++.h>\nusing namespace std;\n\nsigned main() \n{\n    int n; cin >> n;\n    vector<int> v(n), d(n);\n    cin >> v[0]; d[0] = v[0];\n    for(int i=1;i<n;++i)\n    {\n        cin >> v[i];\n        d[i] = v[i] - v[i-1];\n    }\n    for(auto i:d) cout << i << ' ';\n}\n```\n\n我們要解決以下問題：\n\n```txt=\n在區間 [l,r] 加上 x，經過多次不同的操作後，求最後的數列\n```\n有了差分數列我們就不用每次操作都用迴圈在原數列上從 l 到 r 逐個加上 x\n只需在差分數列上做以下兩步操作：\n1. 第 l 項 + x（相當於將原數列第 l 項開始以後的數都 + x）\n2. 第 r+1 項 - x（相當於將原數列第 r+1 項開始以後的數停止 + x）\n\n所以不管區間 `[l,r]` 多大，都只用兩次加減法操作就能達成在區間 `[l,r]` 加上 x\n所有操作結束後對差分數列做一次前綴和即可得到最後的數列結果，也成功降低了時間複雜度\n\n```cpp=\nint q,l,r,x; cin >> q;\nwhile(q--)\n{\n    cin >> l >> r >> x;\n    d[l] += x;\n    d[r+1] -= x;\n}\nint sum = 0;\nfor(int i=0;i<n;++i)\n{\n    sum += d[i];\n    cout << sum << ' ';\n}\n```\n\n> 注意：此方法只適用於不需要中途詢問的情況，前綴和 & 差分如果要帶修改則會用到本篇內容之一的 `BIT 樹狀數組`\n\n> 補充：二維差分數列\n可以自行試著建看看，能有效地處理二維矩形區域更新的操作\n\n\n### 小結\n\n這兩種資料結構在處理區間操作時非常有用，特別是在需要頻繁進行區間求和或區間更新的問題中\n\n差分和前綴和互為逆運算\n`對差分數列做前綴和` 或 `對前綴和數列作差分` 都會獲得 `原陣列`\n\n---\n\n\n# 本篇文章仍在撰寫中 請稍等內容完整後再閱讀...\n\n\n---\n\n\n## 樹狀數組 BIT\n\n<!-- 樹狀樹組，英文叫做 Fenwick Tree 或 Binary Indexed Tree，又簡稱 BIT，由 Fenwick 在\n1994 年提出，用來解決「動態前綴和」問題 -->\n\n---\n\n## 稀疏表 Sparse Table\n\n\n---\n\n## 線段樹 Segment Tree\n\n---\n\n## 鏈結串列 Linked-list\n\n---\n\n## 並查集 DSU\n<!-- Disjoint Set Union-find -->\n\n---\n\n## 二元搜尋樹 BST\n\n---\n\n## 樹堆 Treap\n\n---\n\n## 伸展樹 Splay Tree\n\n---\n\n## 動態樹 Link-Cut Tree\n\n---\n\n## 字典樹 Trie\n\n---\n\n## rope\n\n<!-- rope 是一個很強大的字串處理資料結構，聽說是為了與字串 string（英譯：細繩）做對比才叫做 rope（英譯：粗繩）的，其底層是一棵持久化平衡樹，因此在做合併或在中間插入的期望時間複雜度是 $O(\\log n)$ -->\n\n---\n\n## pbds \n\n\n---\n\n{% btn '/post/Sitemap/',回到導覽頁面,far fa-hand-point-right,blue block center larger %}\n\n---","tags":["C++","資料結構 Data Structures","前綴和 & 差分數列","樹狀數組 BIT","稀疏表 Sparse Table","線段樹 Segment Tree","鏈結串列 Linked-list","並查集 DSU","二元搜尋樹 BST","樹堆 Treap","伸展樹 Splay Tree","動態樹 Link-Cut Tree","字典樹 Trie","rope","pbds"],"categories":["筆記","DSA"]},{"title":"南九校資訊社 x 成大資工 x SCIST 2024 聯合寒訓 - 資得其樂 籌辦心得","url":"/post/SCIST-Camp-2024/","content":"\n\n\n# [寒訓詳細資訊](https://hackmd.io/@nine-southern-schools/Complete_information)\n\n![資得其樂 LOGO](https://hackmd.io/_uploads/rkoBua7sa.png)\n\n# 引言\n\n在 2023/11/25 這次的寒訓總召 茶碗蒸 私訊我問說要不要一起辦寒訓，但其實我們南附資研在 2023/11/13 幹部線上開會時就有討論到說寒假要辦營隊，本來沒想說要辦那麼大規模的寒訓，那時的規劃主要是開放給校內的所有學生和老師，大概會舉辦講座提供給校內對資訊領域有興趣的人，且主題訂為資訊領域的多元課程。\n後來思考過後決定接下本次寒訓副召，一開始的召群有南女的總召 茶碗蒸、一中的副召 KCC 還有我，加上 Fishhh、Eason 和 Curious 這三位 SCIST S4 的總召們協助，還有小白的加入也讓我們日後籌備更順利。\n\n![第一次開會](https://hackmd.io/_uploads/SJOQ63Hsp.png)\n\n# 籌備階段\n\n我們是先開了線上會議，確認好活動目的與受眾，排好 Deadline 後才開始籌備，一開始是要先招募工作人員，因為有茶碗蒸這個 SCIST 文書在，所以各種表單很快就做好了，而且他也有之前辦茶會迎新的經驗，所以初期還挺順利的，也在一開始就把各校的邀請訊息發出去了，最後是找到了 9 間學校聯合主辦，而 SCIST 則是掛協辦，提供我們講師助教等課程上的資源，我們也開始著手撰寫計劃書、排時間表、預估經費、詢問場地租借...等。在計劃書撰寫上感謝小白幫了很大的忙，而其他的事情也很幸運有上一屆寒訓的 PJ、Koying...等人的努力，有留下文檔提供我們很多資訊可作參考，讓我們在初期不容易迷失方向，對我們幫助很大。\n\n在短短的一週內，就收到了個主辦校報名的工作人員 35 人左右，其中我從南附資研中就拉了 10 幾個人來當行政，加上 SCIST 的講師及助教，最後行政組達到了 50 人左右。\n\n![行政組總表](https://hackmd.io/_uploads/rJyZKRBoT.png)\n\n我們接著開放學員報名，一開始報名狀況其實不是很好，我們很怕無法收到預估的學員人數，所以加強了各校的宣傳，我也以擔任小編的經驗到各大社團和營隊網站上刊登廣告，後來發現報名期間只有第一週和最後一週報名人數才會增加的現象...\n在這要感謝成功大學資工系的 Colten 幫忙處理成大場地以及接線讓成大資工系與本次寒訓合作，讓推廣曝光提升了很多，也提供了我們成大超級棒的階梯教室和電腦教室場地給寒訓使用，也要特別感謝副召 KCC 不斷地與南一中接洽，才能有超大的群英堂提供我們舉辦晚會活動。\n\n![Eport 宣傳刊登](https://hackmd.io/_uploads/Hy_oqRBjp.png)\n\n過了學員報名期限，很開心的我們收到了超過 100 多位學生的報名，接下來就是繁瑣篩選學員環節，繁瑣是因為要閱讀大量的試算表內容，根據報名者的意願、動機、對資訊領域的了解及熱忱來篩選出 80 位實體學員參與為期 3 天的寒訓，然後要開始寄錄取和未錄取通知信，也開始開放學員繳費，過程中遇到了一些困難與挑戰。\n\n![報名結果](https://hackmd.io/_uploads/B1tgoRri6.png)\n\n# 挑戰與學習\n\n在做行政的過程中，會不小心放錯連結之類的，當下其實滿慌的，很難及時補救，所以很感謝有行政組的其他人幫忙處理，我也在這次的籌備過程中學到了很多應對問題的方法，讓我了解到做事須謹慎小心且要再三確認，也在當行政的過程中，學習到如何回信、如何應對突發狀況等。\n\n# 團隊分工合作\n\n在籌備期間我們團隊訂好 Deadline，由召群這分派給每個職位工作，行政組招收了活動、隊輔、總務、場務、美宣和醫護，將每個職位開討論區讓各組員交流更便利，且將資訊公開透明，也將各種連結彙整在一起，讓行政組同步且避免落差，很感謝各組組長非常積極的參與和組員的配合，讓我體會到團隊分工合作的重要性。\n\n![行政組討論區](https://hackmd.io/_uploads/HkMg5CHop.png)\n\n## 活動組\n\n這次寒訓的所有遊戲內容和晚會皆由活動組規劃，我覺得他們非常辛苦，比我們召群還要肝，他們從上任就開始想活動、出題、討論流程，常常看到他們在開會，我大部分都會在，感受到他們的忙碌，要絞盡腦汁的思考有什麼團康遊戲可以玩，思考如何讓學員們破冰，讓彼此在短時間內互相熟悉了解，這裡要特別感謝 Yudong、OsGa 和 Joyce 三位超強的活動，前兩位甚至是三天裡最辛苦的主持人，而活動組長 Yudong 和隊輔組長 Joyce 的規劃和執行能力也讓我相當佩服，這三天有這麼精彩的活動真的要歸功於他們\n\n{% gallery %}\n![活動組開會](https://hackmd.io/_uploads/HJxGBXroT.png)\n![活動組規劃](https://hackmd.io/_uploads/rJa7UaQoT.png)\n![題庫](https://hackmd.io/_uploads/Bkf8pASia.png)\n![大地遊戲關主分配](https://hackmd.io/_uploads/rkl48J8sT.png)\n{% endgallery %}\n\n## 隊輔組\n\n隊輔組是人數最多的一組，因為我們總共招收了 85 位實體學員，所以收了 18 位隊輔，負責帶領小隊完成這三天的所有活動，還要做小隊牌、點名、帶跳小隊舞(~~這點子不是我想的~~)...等繁雜的工作，是需要有責任感且能了解活動流程的人擔任\n\n{% gallery %}\n![隊輔組開會](https://hackmd.io/_uploads/SJbTwaQi6.png)\n![小隊舞音樂](https://hackmd.io/_uploads/SkcTL1Usa.png)\n![隊輔組點名](https://hackmd.io/_uploads/H1msjkIsT.png)\n{% endgallery %}\n\n\n## 總務組\n\n總務組只有兩個人，負責事前的訂餐與金錢的管控，是非常重要的角色\n{% gallery %}\n![餐點店家](https://hackmd.io/_uploads/HkGd6y8iT.png)\n![金錢規劃與收支紀錄](https://hackmd.io/_uploads/r1adxgUi6.png)\n{% endgallery %}\n\n## 場務組\n\n場務組負責拍照、餐點搬運、場復...等工作，要在大家休息的時候努力工作，非常辛苦，感謝場務這三天的付出。\n\n## 美宣組\n\n這次的美宣組只有 JT Lin 一個人，他非常辛苦要製作所有工作人員和實體學員的名牌、獎狀、參與證明...等，需要大量的時間製作，還要兼任隊輔，是一個效率高且負責的人，~~只不過這三天滿諧咖的~~\n\n{% gallery %}\n![宣傳圖](https://hackmd.io/_uploads/ByjPvkIi6.png)\n![美宣工作](https://hackmd.io/_uploads/rJWnPyUs6.png)\n![名牌](https://hackmd.io/_uploads/Hyuu_yLjp.jpg)\n{% endgallery %}\n\n# 課程內容\n\n這次因為 SCIST 協辦，所以有了講師以及助教，感謝講師們在寒訓前辛苦的準備課程講義，每位都帶給學員很大的幫助，以下是我整理的課程資源彙整，大家可以善加利用\n\n## [課程資源彙整](https://hackmd.io/@nine-southern-schools/course-link)\n\n{% gallery %}\n![20240206_101644](https://hackmd.io/_uploads/HJGrUmAha.jpg)\n![20240206_101837](https://hackmd.io/_uploads/HkRNI7Rha.jpg)\n![DSC_3378](https://hackmd.io/_uploads/BJKIIX02p.jpg)\n![DSC_3383](https://hackmd.io/_uploads/HyY8IX02p.jpg)\n![DSC_3385](https://hackmd.io/_uploads/BJKU8mCnp.jpg)\n![DSC_3396](https://hackmd.io/_uploads/HkML8QC36.jpg)\n![DSC_3444](https://hackmd.io/_uploads/BkdL8mC3p.jpg)\n![DSC_3452](https://hackmd.io/_uploads/S1tII70hT.jpg)\n![DSC_3456](https://hackmd.io/_uploads/rkHULmC2a.jpg)\n![DSC_3458](https://hackmd.io/_uploads/H1L8UQ0na.jpg)\n![DSC_3460](https://hackmd.io/_uploads/B1wULQR2T.jpg)\n![DSC_3485](https://hackmd.io/_uploads/S1X88QRhT.jpg)\n![DSC_3503](https://hackmd.io/_uploads/HyuILQ036.jpg)\n![DSC_3505](https://hackmd.io/_uploads/HkYUL703T.jpg)\n![DSC_3514](https://hackmd.io/_uploads/SkwUU7R36.jpg)\n![IMG_7065](https://hackmd.io/_uploads/rkeUI7Rha.jpg)\n![IMG_7081](https://hackmd.io/_uploads/SJiH8Q0h6.jpg)\n![IMG_9032](https://hackmd.io/_uploads/SJw4UQ03T.jpg)\n![IMG_9036](https://hackmd.io/_uploads/r1UVUm026.jpg)\n![IMG_9086](https://hackmd.io/_uploads/rJLNU7Rh6.jpg)\n{% endgallery %}\n\n\n# 活動內容\n\n先放照片 下面剩下的文字內容等我有空再補 ...\n\n## 開幕與破冰\n\n{% gallery %}\n![20240205_085547](https://hackmd.io/_uploads/HkhetmAnT.jpg)\n![20240205_085620](https://hackmd.io/_uploads/ry4bFQ03a.jpg)\n![20240205_093011](https://hackmd.io/_uploads/Hk21Y7Ahp.jpg)\n![20240205_093051](https://hackmd.io/_uploads/H1HlFXAh6.jpg)\n![20240205_093139](https://hackmd.io/_uploads/BkagYX02p.jpg)\n![20240205_093648](https://hackmd.io/_uploads/ry1-t7Anp.jpg)\n![20240205_093708](https://hackmd.io/_uploads/S1JbFQC2p.jpg)\n![20240205_093714](https://hackmd.io/_uploads/rkigK7A2p.jpg)\n![20240205_093746](https://hackmd.io/_uploads/ByHxFXR3a.jpg)\n![20240205_093822](https://hackmd.io/_uploads/S16ltX0hT.jpg)\n![20240205_093916](https://hackmd.io/_uploads/SyHlFQAha.jpg)\n![20240205_093947](https://hackmd.io/_uploads/BJlixKQCnT.jpg)\n![20240205_094010](https://hackmd.io/_uploads/HJKeFXC2p.jpg)\n![20240205_094025](https://hackmd.io/_uploads/rJMetmChT.jpg)\n![20240205_094042](https://hackmd.io/_uploads/rJ_xKmAnp.jpg)\n![DSC_3550](https://hackmd.io/_uploads/SyDso7A3T.jpg)\n![DSC_3372](https://hackmd.io/_uploads/rkdooXA3a.jpg)\n![DSC_3263](https://hackmd.io/_uploads/SkDiiXR3p.jpg)\n![20240205_094324](https://hackmd.io/_uploads/HkOssmR2a.jpg)\n![20240205_094148](https://hackmd.io/_uploads/rkujoQ0np.jpg)\n![20240205_094125](https://hackmd.io/_uploads/ryuojXR2T.jpg)\n![20240205_090344](https://hackmd.io/_uploads/Bkusjm0hp.jpg)\n![20240205_094358](https://hackmd.io/_uploads/S1lWYXA3a.jpg)\n![20240205_094504](https://hackmd.io/_uploads/Hy7WF70h6.jpg)\n![20240205_094856](https://hackmd.io/_uploads/BJJxYQC26.jpg)\n![20240205_095313](https://hackmd.io/_uploads/ByPltXA3T.jpg)\n![20240205_095827](https://hackmd.io/_uploads/Bk5gtmRhT.jpg)\n![20240205_100114](https://hackmd.io/_uploads/BJylKQ03p.jpg)\n![20240205_100417](https://hackmd.io/_uploads/HyK1FQR2a.jpg)\n![20240205_101227](https://hackmd.io/_uploads/S1mgYQC3p.jpg)\n{% endgallery %}\n\n\n\n## 贊助商分享\n\n{% gallery %}\n![IMG_7336](https://hackmd.io/_uploads/H1jw37Cnp.jpg)\n![DSC_3652](https://hackmd.io/_uploads/r1hvh7C2a.jpg)\n![DSC_3609](https://hackmd.io/_uploads/SJnv3QRnp.jpg)\n![DSC_3602](https://hackmd.io/_uploads/S13P2QC3a.jpg)\n![DSC_3571](https://hackmd.io/_uploads/rJ2P27Rha.jpg)\n![20240206_132112](https://hackmd.io/_uploads/B12v3XRna.jpg)\n{% endgallery %}\n\n\n## 遊戲活動\n\n{% gallery %}\n![20240205_195634](https://hackmd.io/_uploads/SJ98cmy6T.jpg)\n![20240206_194936](https://hackmd.io/_uploads/SyGu9XyTp.jpg)\n![20240206_195113](https://hackmd.io/_uploads/HJGucQy6p.jpg)\n![20240206_195918](https://hackmd.io/_uploads/HyfO5m166.jpg)\n![20240206_200137](https://hackmd.io/_uploads/HkGu5mJpp.jpg)\n![20240206_200804](https://hackmd.io/_uploads/rkf_cQJT6.jpg)\n![20240206_200805](https://hackmd.io/_uploads/r1fdcmy66.jpg)\n![DSC_3475](https://hackmd.io/_uploads/HJhK5XyaT.jpg)\n![DSC_3480](https://hackmd.io/_uploads/S1e2Yq7JTa.jpg)\n![DSC_3653](https://hackmd.io/_uploads/ryxhF5XJ6T.jpg)\n![DSC_3854](https://hackmd.io/_uploads/SJnY5mypT.jpg)\n![IMG_7110](https://hackmd.io/_uploads/r1hY9mJpp.jpg)\n![IMG_7114](https://hackmd.io/_uploads/S16Yq7k6T.jpg)\n![IMG_7117](https://hackmd.io/_uploads/HkhtcmypT.jpg)\n![IMG_7120](https://hackmd.io/_uploads/S1hK9Q1pT.jpg)\n![IMG_7122](https://hackmd.io/_uploads/HynFqQyTp.jpg)\n![IMG_7125](https://hackmd.io/_uploads/rknK5Q1pp.jpg)\n![IMG_7127](https://hackmd.io/_uploads/HJ3Ycm1a6.jpg)\n![IMG_7133](https://hackmd.io/_uploads/r1htcQ1p6.jpg)\n![IMG_7136](https://hackmd.io/_uploads/SJnYc716p.jpg)\n![IMG_7139](https://hackmd.io/_uploads/ry3F9XyTp.jpg)\n![IMG_7141](https://hackmd.io/_uploads/rJg2Yq7k6T.jpg)\n![IMG_7143](https://hackmd.io/_uploads/ryght57ypp.jpg)\n![IMG_7144](https://hackmd.io/_uploads/SJe3K5mJpa.jpg)\n![IMG_7146](https://hackmd.io/_uploads/S12Y9X1TT.jpg)\n![IMG_7171](https://hackmd.io/_uploads/rJ3Y5QyTp.jpg)\n![IMG_7186](https://hackmd.io/_uploads/HkehF5my6p.jpg)\n![IMG_7196](https://hackmd.io/_uploads/By3YqXJap.jpg)\n![IMG_7224](https://hackmd.io/_uploads/HkxnF571pp.jpg)\n![IMG_7225](https://hackmd.io/_uploads/SJg3Kq7kaT.jpg)\n![IMG_7227](https://hackmd.io/_uploads/SknKq7kTT.jpg)\n![IMG_7228](https://hackmd.io/_uploads/r13K57Jpa.jpg)\n![IMG_7246](https://hackmd.io/_uploads/rJe3KqQ1aT.jpg)\n![IMG_7247](https://hackmd.io/_uploads/rJhF5XyTa.jpg)\n![IMG_7395](https://hackmd.io/_uploads/H1hY97ypa.jpg)\n![IMG_7401](https://hackmd.io/_uploads/Skl2FcXJ6a.jpg)\n![IMG_9050](https://hackmd.io/_uploads/ByAO5XyTT.jpg)\n{% endgallery %}\n\n## 晚會\n\n<!-- 特別感謝邀請到的南女光舞社、南女鎖舞社和活力小精靈帶來的精彩表演，讓整個晚會的氣氛提升了一個檔次 -->\n\n\n## 闖關活動\n\n{% gallery %}\n![20240207_091051](https://hackmd.io/_uploads/ryUD3m1aT.jpg)\n![20240207_092117](https://hackmd.io/_uploads/BkrwhQypa.jpg)\n![20240207_104938](https://hackmd.io/_uploads/H1rvnXyaT.jpg)\n![DSC_3856](https://hackmd.io/_uploads/ByLv2m1aa.jpg)\n![DSC_3875](https://hackmd.io/_uploads/S1Lv3Xkaa.jpg)\n![DSC_3880](https://hackmd.io/_uploads/SJLD37Jap.jpg)\n![DSC_3881](https://hackmd.io/_uploads/S1Dvh7kTT.jpg)\n![DSC_3883](https://hackmd.io/_uploads/H1vw2mk6T.jpg)\n![DSC_3884](https://hackmd.io/_uploads/r18wh716T.jpg)\n![DSC_3887](https://hackmd.io/_uploads/Sywvh7JT6.jpg)\n![DSC_3901](https://hackmd.io/_uploads/By8PhQ1a6.jpg)\n![DSC_3910](https://hackmd.io/_uploads/ry8PhQkpp.jpg)\n![DSC_3911](https://hackmd.io/_uploads/rk8v3m1ap.jpg)\n![DSC_3915](https://hackmd.io/_uploads/B1LDnXkpp.jpg)\n![DSC_3916](https://hackmd.io/_uploads/BkLwnmy66.jpg)\n![DSC_3921](https://hackmd.io/_uploads/BJvD2QkT6.jpg)\n![DSC_3924](https://hackmd.io/_uploads/SJwD27ypT.jpg)\n![DSC_3928](https://hackmd.io/_uploads/BkgIvnQypa.jpg)\n![DSC_3948](https://hackmd.io/_uploads/rJIvhmypT.jpg)\n![DSC_3951](https://hackmd.io/_uploads/SJvv2m1TT.jpg)\n![DSC_3961](https://hackmd.io/_uploads/B1eIv2QJ66.jpg)\n![DSC_3979](https://hackmd.io/_uploads/H1xUP37JTa.jpg)\n![DSC_3994](https://hackmd.io/_uploads/SJlIvh7Jap.jpg)\n![DSC_4010](https://hackmd.io/_uploads/HyIw3QyTa.jpg)\n![DSC_4019](https://hackmd.io/_uploads/ryUD2Xkpa.jpg)\n![DSC_4029](https://hackmd.io/_uploads/r1LDhQkaT.jpg)\n![DSC_4040](https://hackmd.io/_uploads/B1xIP2mJTp.jpg)\n![DSC_4048](https://hackmd.io/_uploads/HyxUv3Q1a6.jpg)\n![DSC_4113](https://hackmd.io/_uploads/ByxIvnXk6T.jpg)\n![DSC_4125](https://hackmd.io/_uploads/HJl8v3mJTp.jpg)\n![DSC_4131](https://hackmd.io/_uploads/BkgLDhm16T.jpg)\n![DSC_4160](https://hackmd.io/_uploads/rkeUPnQyTT.jpg)\n![IMG_7522](https://hackmd.io/_uploads/BygDD27kTa.jpg)\n![IMG_7529](https://hackmd.io/_uploads/ryvP3my6a.jpg)\n![IMG_7530](https://hackmd.io/_uploads/SyPw271p6.jpg)\n![IMG_7532](https://hackmd.io/_uploads/Hk8PhQJap.jpg)\n{% endgallery %}\n\n## 經驗分享\n\n{% gallery %}\n![DSC_4264](https://hackmd.io/_uploads/rJS9jQkTp.jpg)\n![DSC_4255](https://hackmd.io/_uploads/SyS5j71aa.jpg)\n![DSC_4240](https://hackmd.io/_uploads/rkH5iQkaa.jpg)\n![DSC_4247](https://hackmd.io/_uploads/rkr5s7kpT.jpg)\n![DSC_4226](https://hackmd.io/_uploads/Bkrco7kT6.jpg)\n![DSC_4215](https://hackmd.io/_uploads/BkB9oXk6a.jpg)\n![DSC_4220](https://hackmd.io/_uploads/SkH5j7JaT.jpg)\n![DSC_4214](https://hackmd.io/_uploads/S1BqsXkpa.jpg)\n![20240207_135837](https://hackmd.io/_uploads/SkBciXypT.jpg)\n![DSC_4209](https://hackmd.io/_uploads/BJS9s7k6a.jpg)\n![20240207_135437](https://hackmd.io/_uploads/SJr5o7yaT.jpg)\n![20240207_135238](https://hackmd.io/_uploads/rkHqj7J66.jpg)\n![20240207_135221](https://hackmd.io/_uploads/S1S9jm1Tp.jpg)\n![20240207_134445](https://hackmd.io/_uploads/Syrcom1T6.jpg)\n![20240207_134024](https://hackmd.io/_uploads/rkHco716T.jpg)\n{% endgallery %}\n\n## 頒獎與閉幕\n\n{% gallery %}\n\n\n\n{% endgallery %}\n\n\n# 大合照\n\n![大合照](https://hackmd.io/_uploads/rkmsFpXoa.jpg)\n\n# 回饋\n\n{% gallery %}\n![image](https://hackmd.io/_uploads/H1Uq5TQj6.png)\n![image](https://hackmd.io/_uploads/SJFyo6Qja.png)\n![image](https://hackmd.io/_uploads/S1Ylspmjp.png)\n{% endgallery %}\n\n# 檢討與反思\n\n照片整理了很久，等我有空再來回補文字\n\n# 未來展望\n\n待更新...\n\n---\n\n{% btn '/post/Sitemap/',回到導覽頁面,far fa-hand-point-right,blue block center larger %}\n\n---","tags":["資訊社","成大資工","SCIST","寒訓","營隊","AI","DC Bot","Web"],"categories":["心得","營隊"]},{"title":"AI 概論與 ML 實作入門","url":"/post/AI/","content":"\n> 本篇文章連結：https://4yu.dev/post/AI\n\n\n目前尚未整理成筆記文章，僅有簡報版本，可搭配課程錄影觀看。\n\n# 課程簡報\n\n## https://slides.com/shiyu/ai\n\n# 課程錄影\n\n## https://www.youtube.com/watch?v=IMVLUpGYMjA\n\n\n![AI 簡報總覽](/img/AI-slide.png)\n\n![AI 目錄 1](/img/AI-Outline-1.png)\n![AI 目錄 2](/img/AI-Outline-2.png)\n\n\n---\n\n{% btn '/post/Sitemap/',回到導覽頁面,far fa-hand-point-right,blue block center larger %}\n\n---","tags":["機器學習 ML","深度學習 DL","卷積神經網路 CNN","Transformer","GPT","強化學習 Reinforcement Learning","神經網路 Neural Network","損失函數 Loss Function","梯度下降演算法 Gradient Descent","擬合函數 Fitting Function","過擬合 Overfiting","感知器 Perceptron","多層感知器 MLP","全局最小值 Global Minima","學習率 Learning Rate","偏微分 Partial Derivative","超參數 Hyperparameter","激活函數 Activity Function","反向傳播演算法 Backward Propagation","鏈式法則 Chain Rule","監督式學習 Supervised Learning","均方誤差 MSE","均方根誤差 RMSE","平均絕對值誤差 MAE","交叉熵 Cross-Entropy","模擬退火演算法 Simulated Annealing","遺傳演算法 Genetic Algorithm","粒子群演算法 PSO","隨機梯度下降 SGD","優化器 Optimizer","Newton’s Method","Momentum","Nesterov (NAG)","AdaGrad","RMSprop","Adam","Nadam","Dropout","線性迴歸","邏輯迴歸","決策樹","決策森林","KNN","SVM","DQN","Policy-based","Actor-Critic","TD-Learning","PPO","A2C","Baseline","Softmax","U-Net","殘差網路 ResNet","RNN","LSTM","GRU","BERT","詞嵌入 Embedding","注意力機制 Attention","Fine-Tuning","LoRA","RLHF","Hallucination","檢索增強生成 RAG","Prompt Engineering","CoT","ViT","Positional Encoding","生成對抗網路 GAN","AutoEncoder","VAE","Diffusion 擴散模型","評分函數 Score Function","Stable Diffusion","Sora","AlphaGO","AlphaFold","FSD","AGI","對抗樣本攻擊 Adversarial Attack","提示詞注入攻擊 Prompt Injection Attack","Jailbreaking","NVQLink","量子退火 Quantum Annealing","AI Agent","MCP","Vibe Coding"],"categories":["筆記","AI"]},{"title":"C++ STL 大全","url":"/post/STL/","content":"\n> 本篇文章連結：https://4yu.dev/post/STL/\n> 公開發布日期：2023/12/31\n\n# Intro\n\n學完 C++ 基礎語法之後，接著就該進入資料結構的世界了！\n本篇筆記要介紹的是 C++ STL，彙整了許多基礎資料結構的概念與用法\n文章內容較多，大部分內容為自行收集資料後經過整理而成\n若有任何錯誤或需要補充的地方都歡迎使用右側聊天室傳送訊息給我\n我將會儘速修改，謝謝\n\n# 先備知識\n\n標準模板庫（Standard Template Library），簡稱 **STL**，為 C++ 內建的函式庫\n為了應對各種資料型態，因此 STL 內部採用 `模板 template` 來實作，分為六大部分：\n\n1. 容器（Containers）\n2. 演算法（Algorithm）\n3. 迭代器（Iterator）\n4. 適配器（Adaptor）\n5. 仿函數（Function object）\n6. 空間配置器（allocator）\n\n> 本篇文章內容著重於前四大部分\n\n## 符號解釋\n\n對於本篇文章中各種符號的解釋\n\n- C：某種容器（container）\n- T：某種資料型態（type）\n- S：長度（size）\n- i：索引（index）\n- K：鍵（key）\n- val：值（value）\n- it：迭代器（iterator）\n\n## 迭代器（iterator）\n\nC++ STL 為每個容器提供一個成員型別：`迭代器 Iterator`，我們可以用 `指標 pointer` 的概念來理解迭代器\n\n迭代器透過運算子重載，為不同資料結構定義「如何走訪下一步」，模擬出指標的走訪功能，但能在移動前進行安全判斷或執行額外功能，解決了指標走訪時容易發生越界或亂指的問題\n\n假設現在有個迭代器 `it`，如果要存取 `it` 所指向的內容，就在前面加上星號 `*it`，與指標相同\n\n迭代器有以下三種類型：\n\n1. 隨機存取迭代器：能夠作整數的加減法，往 `後移 x 項`、往 `前移 x 項` 皆可，也能 `遞增 (++)` 和 `遞減 (−−)`，可以把指標當作這種迭代器\n2. 雙向迭代器：只能做 `遞增 (++)` 和 `遞減 (−−)` 的運算，也就是 `後一項` 和 `前一項`\n3. 單向迭代器：只能做 `遞增 (++)` 的運算，也就是 `後一項`\n\n利用迭代器可**遍歷容器中的元素**，又分為 `iterator` 和 `reverse_iterator`（反向迭代器）\n- iterator\n  - .begin()：指向容器的起始元素\n  - .end()：指向容器最後一個元素的下一個位置\n- reverse_iterator\n  - .rbegin()：指向容器的最後一個元素\n  - .rend()：指向容器起始元素的前一個位置\n\n`iterator` 示意圖 ([圖片來源](https://crmne0707.pixnet.net/blog/post/318479072-c%2B%2B-%E8%BF%AD%E4%BB%A3%E5%99%A8-iterator))\n\n![iterator 示意圖](https://hackmd.io/_uploads/HJbllasvp.png)\n\n---\n\n# 資料結構的詳細介紹\n\n本篇介紹以下 C++ STL 內建基礎資料結構：\n\n- 動態陣列 vector\n- 串列 list\n- 字串 string \n- 數對 pair \n- 數組 tuple \n- 堆疊 stack \n- 佇列 queue \n- 雙端佇列 deque \n- 優先佇列 priority_queue\n- 集合 set \n- 映射 map \n- 多重集合 multiset \n- 多重映射 multimap \n- 無序集合 unordered_set\n- 無序映射 unordered_map\n- 多重無序集合 unordered_multiset \n- 多重無序映射 unordered_multimap \n- 位集 bitset\n\n\n## vector 動態陣列\n\n可以當作是 C++ `陣列（array）` 的擴充版，能支援原有的操作，還可以`動態新增元素`且會自行改變長度，也就是說不用事先宣告固定大小，基本上學完 `vector` 大多數情況可以直接取代 `array`\n\n### 可支援的操作方法\n\n| 編號 | 操作方法 | 功能介紹 | 時間複雜度 |\n| --- | --- | --- | --- |\n| 1 | `v[i]` | 支援下標讀取 `v` 的第 `i` 項（不做邊界檢查） | $O(1)$ |\n| 2 | `v.empty()` | 回傳一個 `bool`，表示 `v` 是否為空的 | $O(1)$ |\n| 3 | `v.clear()` | 清空 `v`，但原本的**容量**不會被釋放 | $O(n)$ |\n| 4 | `v.size()` | 回傳 `v` 目前的長度 | $O(1)$ |\n| 5 | `v.resize(S, val)` | 將 `v` 的長度變為 `S`：若比原本長，則在尾端添加 val 直到長度為 S；反之則將多餘的元素捨去 | 平均 $O(S - S_{old})$ |\n| 6 | `v.insert(it, val)` | 在 `it` 位置插入 `val`，必須向後搬動其餘元素 | 均攤 $O(n)$（尾端 $O(1)$） |\n| 7 | `v.erase(it)` | 刪除 it 位置元素，也須向前搬動其餘元素 | 均攤 $O(n)$（尾端 $O(1)$） |\n| 8 | `v.begin() / v.end()` | 回傳首個元素或最後一個元素的 `iterator` | $O(1)$ |\n| 9 | `v.front() / v.back()` | 回傳容器的首個元素或最後一個元素（未檢查是否為空） | $O(1)$ |\n| 10 | `v.push_back(val)` / `v.emplace_back(args...)` | 在 `v` 的尾端加入 `val / args`（`push_back` 複製/移動 `val`；`emplace_back` 原地建構） | $O(1)$ |\n| 11 | `v.pop_back()` | 刪除 `v` 的最末項，若 `v` 為空則是未定義行為 | $O(1)$ |\n\n<!-- \n| 12 | `v.reserve(S)` | 預留容量 `S`，若 `S > capacity()` 會重新配置 | $O(1)$（不重配置）or $O(n)$（重新配置） |\n| 13 | `v.capacity()` | 取得目前的容量（預分配的內存空間）  | $O(1)$ |\n| 14 | `v.shrink_to_fit()` | 請求將 `v` 的容量 `capacity()` 縮到剛好等於大小 `size()` | $O(n)$ or $O(1)$（若未執行） | \n-->\n\n### 可支援的演算法函數\n\n| 編號 | 演算法函數 | 功能介紹 | 時間複雜度 |\n| --- | --- | --- | --- |\n| 1 | `swap(v1, v2)` / `v1.swap(v2)` | 交換兩 vector | $O(1)$ |\n| 2 | `find(v.begin(), v.end(), val)` | 在 `v` 中搜尋 val，找到就返回對應元素的迭代器，否則返回 `v.end()` | $O(n)$ |\n| 3 | `count(v.begin(), v.end(), val)` | 計算 `v` 中 `val` 出現的次數 | $O(n)$ |\n| 4 | `replace(v.begin(), v.end(), val, new_val)` | 將 `v` 中所有的 `val` 替換成 `new_val` | $O(n)$ |\n| 5 | `sort(v.begin(), v.end())` | 排序 `v` ，預設為遞增 | $O(n \\log n)$ |\n| 6 | `reverse(v.begin(), v.end())` | 反轉 `v` 內所有元素 | $O(n)$ |\n| 7 | `merge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin())` | **將已排序**的 `v1` 和 `v2` 合併至 `v3`（結果為已排序狀態） | $O(v1 + v2)$ |\n| 8 | `binary_search(v.begin(), v.end(), val)` | 二分搜尋：若找到 `val` 回傳 `true`，否則回傳 `false`（v 須排序） | $O(\\log n)$ |\n| 9 | `lower_bound(v.begin(), v.end(), val)` | 回傳在包含 `v.begin()` 到不含 `v.end()` 的區間中第一個 $\\ge$`val` 的 iterator（`v` 須排序） | $O(\\log n)$ |\n| 10 | `upper_bound(v.begin(), v.end(), val)` | 回傳在包含 `v.begin()` 到不含 `v.end()` 的區間中第一個 >`val` 的 iterator（`v` 須排序） | $O(\\log n)$ |\n| 11 | `next_permutation(v.begin(), v.end())` | 變成下一个排列 | $O(n)$ |\n| 12 | `prev_permutation(v.begin(), v.end())` | 變成上一个排列 | $O(n)$ |\n| 13 | `unique(v.begin(), v.end())` | 移除**相鄰重複元素**（保留第一個），回傳新結尾 iterator，需搭配 `erase` 真正刪除 | $O(n)$ |\n| 14 | `max_element(v.begin(), v.end())` / `min_element(...)` | 找出最大或最小值的 iterator | $O(n)$ |\n| 15 | `fill(v.begin(), v.end(), val)` | 將整個區間都填上 `val` | $O(n)$ |\n| 16 | `copy(v1.begin(), v1.end(), v2.begin())` | 將 `v1` 的內容複製到 `v2`（須保證 `v2` 有足夠空間） | $O(n)$ |\n| 17 | `equal(v1.begin(), v1.end(), v2.begin())` | 比較 `v1` 和 `v2` 內容是否完全相等 | $O(n)$ |\n\n> `lower_bound` / `upper_bound` 可透過 ` * ` 取值，需在**由小到大排列好的陣列**中才可使用，若回傳的值是 `v.end()`，代表沒有符合的元素\n\n### 常用基本操作 Code\n\n```cpp=\n// 宣告\nvector<int> v;    // 長度為 0 的空 vector\nvector<int> v(5); // 長度為 5 的 vector\nvector<int> v(5, 10); \n// 長度為 5 且每個元素皆被初始化為 10 的 vector，複雜度為 O(n)\nvector<int> v = {1, 2, 3};\n\n// 宣告雙層 vector\nvector< vector<int> > vv;    // 可想像成二維陣列，但每一列長度可以不一樣\n\n// 宣告雙層 vector 同時初始化為大小為 10x10 且每個元素皆為 0\nvector< vector<int> > vv(10, vector<int>(10, 0));\n\n// 下標取值\nint n = v[0];    // 與陣列一樣可使用 index 取值\n\n// 取得長度\nint s = v.size();\n\n// 更改大小\nv.resize(5);    // 將 v 的長度更改為 5\n\n// 在尾端加入元素\nint n = 10;\nv.push_back(n);\nv.emplace_back(n);\n\n// 移除尾端元素\nv.pop_back();\n\n// 尋找\nvector<int> v = {1,3,5,7,9};\nint val; cin >> val\nif(find(v.begin(), v.end(), val) == v.end()) {\n    cout << \"Not find\\n\";\n} else cout << \"Find!\";\n// input : 5 , output : Find!\n// input : 6 , output : Not Find\n\n// 排序（預設升冪：由小到大）\nsort(v.begin(), v.end());\nsort(v, v+v.size());\n\n// 排序（降冪：由大到小）\nsort(v.rbegin(), v.rend());\nsort(v.begin(), v.end(), greater<int>());\n\n// 反轉\nreverse(v.begin(), v.end());\n\n// 二分搜\nbinary_search(v.begin(), v.end(), val)\nupper_bound(v.begin(), v.end(), val);\nlower_bound(v.begin(), v.end(), val);\n\n// 合併\nvector<int> v1 = {1,3,5},\n            v2 = {2,4,6},\n            v3(6);\nmerge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin());\nfor(auto i : v3) cout << i << \" \";\n// output : 1 2 3 4 5 6\n\n// 全排列\nvector<int> v = {1,3,5};\nwhile(next_permutation(v.begin(),v.end())) \n{\n    for(auto i : v) cout << i << \" \";\n    cout << \"\\n\";\n}\n// output : \n// 1 5 3 \n// 3 1 5 \n// 3 5 1 \n// 5 1 3 \n// 5 3 1\n```\n\n> 注意：`vector` **不支援**對**前端元素**使用 `新增` 或 `刪除` 的操作\n\n### 補充\n\n> `push_back()` 與 `emplace_back()` 功能相同，但如果以效能為優先，`emplace_back()` 通常比 `push_back()` 更快一點，因為是直接呼叫 constructor 不會複製 object，所以有時候執行效率會比較快。\n[延伸閱讀：codingninjas - emplace_back() vs push_back() in C++ Vectors\n](https://www.codingninjas.com/studio/library/vector-push_back-vs-emplace_back)\n\n\n\n> 在知道需要多少元素後，可以先對 `vector` 做 `reserve()` 擴充 `capacity` 再 `emplace_back()` ，會比 `空 vector` 慢慢 `emplace_back()` 快\n[延伸閱讀：ping 不見路 - STL vector 效率小記](https://arc.net/l/quote/tslhdeoj)\n示意圖 ([圖片來源](https://blog.csdn.net/JACKSONMHLK/article/details/114396650))\n![vector 示意圖](https://hackmd.io/_uploads/H1CgPoTva.png)\n\n\n## list 串列\n\nlist 是雙向鏈結串列（Doubly Linked List），每個節點包含前一個節點與下一個節點的指標，因此可以從任意位置快速插入或刪除元素，且不需要搬移其他元素。\n不同於 vector，list 不支援下標，也就是不能使用 `[index]` 隨機存取\n\n| 編號 | 操作方法                                         | 功能介紹                | 時間複雜度         |\n| -- | -------------------------------------------- | ------------------- | ------------- |\n| 1  | `lt.size()`                                 | 取得元素個數              | $O(1)$        |\n| 2  | `lt.empty()`                                | 判斷是否為空              | $O(1)$        |\n| 3  | `lt.front()` / `lt.back()`                 | 取得首尾元素              | $O(1)$        |\n| 4  | `lt.push_front(val)` / `lt.push_back(val)` | 在前/後加入元素            | $O(1)$        |\n| 5  | `lt.pop_front()` / `lt.pop_back()`         | 移除前/後元素             | $O(1)$        |\n| 6  | `lt.insert(it, val)`                        | 在迭代器 `it` 前插入 `val` | $O(1)$        |\n| 7  | `lt.erase(it)`                              | 刪除迭代器 `it` 指向的元素    | $O(1)$        |\n| 8  | `lt.clear()`                                | 清空整個 list           | $O(n)$        |\n| 9  | `lt.sort()`                                 | 對 list 元素排序         | $O(n \\log n)$ |\n| 10 | `lt.reverse()`                              | 反轉 list             | $O(n)$        |\n| 11 | `lt.merge(lt2)`                            | 合併另一個已排序 list，結果為排序 | $O(n+m)$      |\n\n\n### 常用基本操作 Code\n\n```cpp=\nlist<int> lt;\n\n// 尾端加入元素\nlt.push_back(1);\nlt.push_back(2);\n\n// 前端加入元素\nlt.push_front(0);\n\n// 遍歷\nfor(auto x : lt) cout << x << \" \";\ncout << \"\\n\"; \n// output : 0 1 2\n\n// 插入\nauto it = lt.begin();\nadvance(it, 2); // 移動到 index 2\nlt.insert(it, 5); \nfor(auto x : lt) cout << x << \" \";\ncout << \"\\n\"; \n// output : 0 1 5 2\n\n// 刪除\nlt.pop_front();\nlt.pop_back();\nfor(auto x : lt) cout << x << \" \";\ncout << \"\\n\"; \n// output : 1 5\n\n// 反轉\nlt.reverse();\nfor(auto x : lt) cout << x << \" \";\ncout << \"\\n\"; \n// output : 5 1\n```\n\n## string 字串\n\n雖然 string 不在 STL 裡，但是由**連續的字元**組成，實際上就是 `vector<char>`，加上有一些字串的操作，所以我就順便放進來了\n\n### 可支援的操作方法\n\n`vector` 有的 `string` 幾乎都有\n\n### 常用基本操作 Code\n\n```cpp=\n// 宣告\nstring s;    // 預設為空字串\nstring s1 = \"ABC\";\n\n// 賦值\ncin >> s;        // 以空白作為輸入分隔\ngetline(cin,s);  // 以換行作為輸入分隔\ns = \"ShiYu\";\ns = s1;\n\n// 串接\ns = \"ShiYu\";\ns1 = \"ABC\";\ns += s1;\ncout << s;\n// output : ShiYuABC\n\n// 字串轉數字\nint a = stoi(\"123\");            // stoi : string to int\nlong b = stol(\"12345678900\");   // stol : string to long\ndouble c = stod(\"3.14159\");     // stod : string to double\n\n// 字串轉數字\nint a = 123;\ndouble b = 3.14159;\nstring sa = to_string(a);\nstring sb = to_string(b);\n\n// 刪除最後一個字元\ns.pop_back();\n\n// 下標讀取字元\ncout << s[3];\n// output : Y\n\n// 擷取子字串\ncout << s.substr(0,3);\n// output : Shi\n\n// 取得長度\ncout << s1.size();\n// output : 5\n```\n\n> 注意：取得字串長度請不要用 `strlen()`，應該要用 `.size()`，因為前者複雜度為 $O(n)$，後者為 $O(1)$\n\n\n## pair 數對\n\n**可將兩個型態的資料合併**，透過成員變數 `first` 和 `second` 來存取元素，`pair` 支援以**元素字典序**來比較或排序，以 `first` 為優先\n\n### 常用基本操作 Code\n\n```cpp=\n// 宣告\npair<int, double> p;\n\n// 賦值\np = {1, 2.5};\np = make_pair(1, 2.5);\n\n// 取值\nint f = p.first;    // 1\ndouble s = p.second;// 2.5\n\n// 比較\npair<int, double> a, b;\na = {1, 2.5};\nb = {1, 2.6};\ncout << (a < b) << \"\\n\"; \n// output : 1 (true)\n\n// 交換兩 pair\npair<int, int> a,b;\na = {1, 3};\nb = {2, 4};\nswap(a, b); // or a.swap(b)\ncout << a.first << \" \" << a.second << \"\\n\"; \n// output : 2 4\n\n// pair 搭配 vector 新增元素\nvector< pair<int,int> > vp;\nvp.push_back(make_pair(1,2));\nvp.emplace_back(3,4); // 用 emplace_back 可以不用 make_pair\nfor(auto i : vp) {\n    cout << i.first << \" \" << i.second << \"\\n\";\n}\n// output : \n// 1 2\n// 3 4\n\n// 使用 vector 排序多個 pair\npair<int,int> a = {1,3},\n              b = {2,4},\n              c = {1,2};\nvector< pair<int, int> > v{a, b, c};\n\nsort(v.begin(), v.end());\n\nfor(auto i : v) {\n    cout << i.first << \" \" << i.second << \"\\n\";\n}\n// output : \n// 1 2\n// 1 3\n// 2 4\n```\n\n## tuple 數組\n\n與 `pair` 相似，但可以**同時組合多個不同型別的元素**( `pair` 只能 2 個)\n\n### 常用基本操作 Code\n\n```cpp=\n// 宣告\ntuple<string, int, bool> tp;\n\n// 初始化\ntuple<string, int, bool> tp(\"ShiYu\", 16, true); \n\n// 賦值\ntp = {\"ShiYu\", 16, true};\ntp = make_tuple(\"ShiYu\", 16, true);\n\n// 賦值（使用 tie，須放變數）\nstring name = \"ShiYu\"; \nint age = 16;\nbool b = true;\ntie(name, age, b) = tp;\n\n// 取值\nint age = get<1>(tp); // 16\n\n// 修改值\nget<2>(tp) = false;\n\n// 取得元素個數\ncout << tuple_size<decltype(tp)>::value << \"\\n\"; \n// output : 3\n\n// tuple 搭配 vector 新增元素\nvector< tuple<int, int, int> > vt;\nvt.push_back(make_tuple(1, 2, 3));\nvt.emplace_back(4, 5, 6); // 用 emplace_back 可以不用 make_tuple\n\nfor(auto& [a,b,c] : vt) {\n    cout << a << \" \" << b << \" \" << c << \"\\n\";\n}\n// output : \n// 1 2 3\n// 4 5 6\n```\n\n## stack 堆疊\n\n可以想像成**一疊盤子**，每次只能在**最上面** `放置` 或 `拿走` 一個盤子\n有著 `後進先出 Last In First Out (LIFO)` 的規則\n> C++ 的 `stack` 是 `容器適配器（Container Adapter）`，預設以 `deque` 為底層容器，也可使用 `vector` 或 `list`\n\n### 可支援的操作方法\n\n| 編號 | 操作方法 | 功能介紹 |\n| --- | --- | --- |\n| 1 | `s.size()` | 取得 s 大小 |\n| 2 | `s.empty()` | 回傳 s 是否為空 |\n| 3 | `s.top()` | 取得 s 頂端元素 |\n| 4 | `s.push(val) / s.emplace(val)` | 將 val 放入 s 頂端 |\n| 5 | `s.pop()` | 移除 s 頂端元素 |\n\n> 複雜度皆為 `O(1)`\n> stack 不支援隨機存取，只能操作頂端元素，也不支援迭代器，無法直接遍歷\n> 注意：.top() 與 .pop() 不會檢查 stack 是否為空，若 stack 為空則是未定義行為，使用前須自行以 .empty() 檢查確保不會出錯\n\n### 示意圖\n\n![stack 示意圖](https://hackmd.io/_uploads/S1U5nn0wT.png)\n\n([圖片來源](https://www.programiz.com/dsa/stack))\n\n### 常用基本操作 Code\n\n依照示意圖實作\n\n```cpp=\nstack<int> stk;\nfor(int i=1;i<=3;++i) {\n    stk.push(i);\n}\nwhile(!stk.empty()) {\n    cout << stk.top() << \"\\n\";\n    stk.pop();\n}\n// output : \n// 3\n// 2\n// 1\n```\n\n### 常見應用\n\n- 表達式求值\n- 括號匹配\n- 維護單調序列\n\n## queue 佇列\n\n可以想像為**排隊的人群**：新來的人排在隊伍的尾端，最前面的人結完帳離開隊伍\n有著 `先進先出 First In First Out (FIFO)` 的規則\n> C++ 的 queue 是 `容器適配器（Container Adapter）`，預設以 `deque` 為底層容器，也可以使用 `list`\n\n### 可支援的操作方法\n\n| 編號 | 操作方法 | 功能介紹 |\n| --- | --- | --- |\n| 1 | `q.size()` | 取得 q 長度 |\n| 2 | `q.empty()` | 回傳 q 是否為空 |\n| 3 | `q.front()` | 取得 q 最前端（最早加入）的元素 |\n| 4 | `q.back()` | 取得 q 最尾端（最後加入）的元素 |\n| 5 | `q.push(val) / q.emplace(val)` | 將 val 加入  q 尾端 |\n| 6 | `q.pop()` | 移除 q 最前端元素 |\n\n> 複雜度皆為 `O(1)`\n> queue 不支援隨機存取，只能操作前端元素，也不支援迭代器，無法直接遍歷\n> 注意：.front() 與 .pop() 不會檢查 queue 是否為空，若 queue 為空則是未定義行為，使用前須自行以 .empty() 檢查確保不會出錯\n\n\n### 示意圖\n\n![queue 示意圖](https://hackmd.io/_uploads/HytPb6RDp.png)\n\n([圖片來源](https://www.boardinfinity.com/blog/working-of-queue-using-stl))\n\n### 常用基本操作 Code\n\n```cpp=\nqueue<int> q;\nq.emplace(1);\nq.emplace(2);\nq.emplace(3);\nwhile(!q.empty()) {\n    cout << q.size() << \" \" << q.front() << \" \" << q.back() << \"\\n\";\n    q.pop();\n}\n// output : \n// 3 1 3\n// 2 2 3\n// 1 3 3\n```\n\n### 常見應用\n\n- BFS\n- 拓墣排序\n- 任務排程\n\n## deque 雙端佇列\n\n為 `double ended queue` 的縮寫，唸作 `deck` 而非 `de-queue`\n一般的 `queue` 只能從尾端新增元素、從前端刪除元素，而 `deque` 的**前後**都可以使用**新增**和**刪除**的操作，\n也支援下標隨機讀取 `dq[i]`，基本上就是多了 `emplace_front()`、`pop_front()` 的 `vector`\n雖然功能方便但由於**常數較大**，在程式競技比賽中非必要不會去使用\n\n### 示意圖\n\n![deque 示意圖](https://hackmd.io/_uploads/SkmEUT0v6.png)\n\n([圖片來源](https://www.codingninjas.com/studio/library/difference-between-queue-and-deque-in-c))\n\n### 可支援的操作方法\n\n`deque` 與 `vector` 相比只是多了針對 `front` 的操作，少了針對記憶體的操作，因為 `vector` 記憶體連續，`deque` 則是分段儲存\n\n| 編號 | 操作方法 | 功能介紹 |\n| --- | --- | --- |\n| 1 | `dq[i]` | 隨機讀取第 i 個元素 | \n| 2 | `dq.size()` | 取得元素個數 |\n| 3 | `dq.empty()` | 判斷是否為空 |\n| 4 | `dq.push_front(val) / dq.emplace_front(val)` | 將 val 加入  dq 前端 |\n| 5 | `dq.push_back(val) / dq.emplace_back(val)` | 將 val 加入  dq 尾端 |\n| 6 |` dq.pop_front()` | 移除 dq 最前端元素 |\n| 7 | `dq.pop_back()` | 移除 dq 最尾端元素 |\n\n> 複雜度皆為 `O(1)`\n\n### 常用基本操作 Code\n\n```cpp=\ndeque<int> dq;\n\n// 前後新增元素\ndq.emplace_front(1);\ndq.emplace_back(2);\nfor(auto i : dq) cout << i << \" \";\ncout << \"\\n\";\n\n// 刪除前端元素\ndq.pop_front();\nfor(auto i : dq) cout << i << \" \";\ncout << \"\\n\";\n\n// 刪除尾端元素\ndq.pop_back();\ncout << dq.size() << \"\\n\";\n\n// output : \n// 1 2 \n// 2 \n// 0\n```\n\n### 常見應用\n\n- 滑動窗口\n- 0-1 BFS\n\n## priority_queue 優先佇列\n\n`priority_queue` 是基於`堆積（heap）`結構實作的容器適配器，它可以維持最頂端的元素永遠是最大或最小的，所以可以很方便且**快速地存取極值**\n\n### 示意圖\n\n![priority queue 示意圖](https://hackmd.io/_uploads/rJqPcT0PT.png)\n\n([圖片來源](https://www.programiz.com/dsa/priority-queue))\n\n### 可支援的操作方法\n\n| 編號 | 操作方法 | 功能介紹 | 時間複雜度 |\n| --- | --- | --- | --- |\n| 1 | `pq.size()`  | 取得元素個數 | $O(1)$ |\n| 2 | `pq.empty()` | 判斷是否為空 | $O(1)$ |\n| 2 | `pq.top()` | 回傳 pq 中最大或最小的元素 | $O(1)$ |\n| 3 | `pq.push(val)` / pq.emplace(val)  | 將 val 加入 pq 中| $O(\\log n)$ |\n| 4 | `pq.pop()` | 將 pq 中最大或最小的元素移除 | $O(\\log n)$ |\n\n### 常用基本操作 Code\n\n```cpp=\npriority_queue<int> pq;\npq.emplace(3);\npq.emplace(5);\npq.emplace(9);\ncout << pq.top();\n// output : 9\n\n// 最小堆\npriority_queue< int, vector<int>, greater<int> > pq;\npq.emplace(3);\npq.emplace(5);\npq.emplace(9);\ncout << pq.top();\n// output : 3\n```\n\n### 補充\n\n> `priority_queue` 有三個型別參數 `T`、`C`、`Cmp`\n`T` 是**內容物的型別**，`C` 是**所採用的容器**，`Cmp` 是**比大小的依據**\n`priority_queue` 能使用的容器有 `vector` 和 `deque`\n`Cmp` 的預設值是 `less<T>`，此時的 `priority_queue` 是**最大堆 max heap**\n若改成 `greater<T>`，則 `priority_queue` 為 **最小堆 min heap**\n建構式如上方 Code 第 8 行，而 output 為最小值\n\n### 延伸閱讀\n\n- [Binary Heap 的排序原理](https://medium.com/starbugs/%E4%BE%86%E5%BE%81%E6%9C%8D%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95%E5%90%A7-%E6%90%9E%E6%87%82-binary-heap-%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86-96768ea30d3f)\n- [資料結構大便當： Binary Heap](https://arc.net/l/quote/asrwfvnj)\n\n### 常見應用\n\n- 動態維護極值\n- 動態第 K 大\n- 最短路徑演算法（Dijkstra）\n\n## set 集合\n`set` 是一個平衡二元搜尋樹容器，底層使用 紅黑樹（Red-Black Tree）實作\n主要的特性為以下三種：\n1. 內部元素自動排序（從小到大）\n2. 沒有重複元素（方便去重）\n3. 插入、刪除和查詢的時間複雜度皆為 $O(\\log n)$\n\n### 示意圖\n\n![image](https://hackmd.io/_uploads/SyYmoACPT.png)\n\n([圖片來源](http://www.ccplusplus.com/2014/01/std-set-example-c.html))\n\n\n\n### 可支援的操作方法\n\n| 編號 | 操作方法 | 功能介紹 | 時間複雜度 |\n| --- | --- | --- | --- |\n| 1 | `s.size()`  | 取得元素個數 | $O(1)$ |\n| 2 | `s.empty()`  | 判斷是否為空 | $O(1)$ |\n| 3 | `s.insert(K)` | 插入元素 K，若已存在則忽略 | $O(\\log n)$ |\n| 4 | `s.erase(K)` | 刪除鍵為 K 的元素，回傳刪除數量（0 或 1） | $O(\\log n)$ |\n| 5 | `s.erase(it)` | 刪除迭代器指向元素 | $O(\\log n)$ |\n| 6 | `s.erase(it_first, it_last)` | 刪除區間 `[first,last)` | $O(k \\log n)$，k = 刪除數量 |\n| 7 | `s.find(K)` | 尋找 K，回傳迭代器，找不到則回傳 `s.end()` | $O(\\log n)$ |\n| 8 | `s.count(K)` | 回傳鍵為 K 的個數（0 或 1） | $O(\\log n)$ |\n| 9 | `s.lower_bound(K)` | 回傳第一個大於等於 K 的元素迭代器 | $O(\\log n)$ |\n| 10 | `s.upper_bound(K)` | 回傳第一個大於 K 的元素迭代器 | $O(\\log n)$ |\n\n### 常用基本操作 Code\n\n```cpp=\n// 宣告\nset<int> s;\n\n// 插入\ns.insert(10);\n\n// 刪除\ns.erase(10);\ns.erase(s.begin());\n\n// 回傳該元素的 iterator，若 set 內部無該元素，則回傳 end()\ns.find(10);\n\n// 問一個元素在不在 set 裡。可透過 find 的 return 值，或使用 s.count\nif(s.find(10) != s.end()) cout << \"In!\\n\";\nif(s.count(10)) cout << \"In!\\n\";\n\n// 遍歷 set 元素\nfor(auto &i : s) cout << i << \" \";\n```\n\n### 延伸閱讀\n\n- [資料結構 — 紅黑樹(Red-Black Tree)](https://ithelp.ithome.com.tw/m/articles/10333136)\n- [Shengyuu - 紅黑樹 - HackMD](https://hackmd.io/@_01X9rimQmWH33Djf8QhoA/Bkm3enQ8N)\n- [hwdong - 最好懂的红黑树教程 - Youtube](https://www.youtube.com/watch?v=Ij8-xX3PreE)![紅黑樹 示意圖](https://hackmd.io/_uploads/rk4_5RRw6.png)\n\n\n## map 映射\n\n類似於 python 中的 `字典 dict`，內部為 `鍵值對 key-value pair`，\n主要的特性為以下三種：\n\n1. 每個元素都是 `pair<key, value>`\n2. 內部依 `鍵 key` 自動排序\n3. 可以修改 `值 value` ，但不能修改 `鍵 key` （因為會破壞排序）\n4. 插入/刪除/查詢鍵的值，時間複雜度皆為 $O(\\log n)$\n\n\n### 示意圖\n\n![image](https://hackmd.io/_uploads/HkrI0A0Dp.png)\n\n([圖片來源](https://www.mropengate.com/2015/12/cc-map-stl.html))\n\n### 可支援的操作方法\n\n| 編號 | 操作方法 | 功能介紹 | 時間複雜度 |\n| --- | --- | --- | --- |\n| 1 | `m[k]` | 存取鍵值 k 對應的 value，若不存在則插入預設值 | $O(\\log n)$ |\n| 2 | `m.size()` | 取得元素數量 | $O(1)$ |\n| 3 | `m.empty()` | 判斷是否為空 | $O(1)$ |\n| 4 | `m.insert(pair<K,T> p)` | 插入鍵值對 p，若 key 已存在則不修改 value；回傳 pair（first=迭代器，second=是否插入成功） | $O(\\log n)$ |\n| 5 | `m.erase(k)` | 刪除 key 為 k 的元素，回傳刪除數量（0 或 1） | $O(\\log n)$ |\n| 6 | `m.erase(it)` | 刪除迭代器指向的元素 | $O(\\log n)$ |\n| 7 | `m.erase(it_first, it_last)` | 刪除區間 `[first,last)` 的元素 | $O(k \\log n)$，k=刪除數量 |\n| 8 | `m.find(k)` | 查找 key=k，回傳指向元素的迭代器，找不到回傳 `m.end()` | $O(\\log n)$ |\n| 9 | `m.count(k)` | 回傳 key=k 的元素數量（map 中 0 或 1） | $O(\\log n)$ |\n| 10 | `m.lower_bound(k)` | 回傳第一個 key >= k 的元素迭代器 | $O(\\log n)$ |\n| 11 | `m.upper_bound(k)` | 回傳第一個 key > k 的元素迭代器 | $O(\\log n)$ |\n| 12 | `m.clear()` | 清空 map | $O(n)$ |\n\n### 常用基本操作 Code\n\n```cpp=\nmap<int, string> m;\n\n// 讀取指定 key 的 value\ncout << m[1] << \"\\n\";        // output: one\ncout << m[2] << \"\\n\";        // output: two\n\n// 插入元素\nm[1] = \"one\";                // 使用 operator[]\nm.insert({2, \"two\"});        // 使用 insert\nm.insert(make_pair(3, \"three\"));\n\n// 刪除元素\nm.erase(2);\nm.erase(m.begin());\n\n// 查詢 key 是否存在\nif(m.find(3) != m.end()) cout << \"3 in map\\n\";\n\n// 遍歷 map\nfor(auto &p : m) cout << p.first << \":\" << p.second << \" \";\ncout << \"\\n\";\n```\n\n## multiset 多重集合 & multimap 多重映射\n\n兩者為 `set`、`map` 的延伸，用法相似但**允許有重複元素**，且 `multimap` 中一個鍵值可能對應到不同的值，所以**不支援下標**\n\n### 示意圖\n\n![multiset 示意圖](https://hackmd.io/_uploads/SJrLqACwa.png)\n\n([圖片來源](http://www.ccplusplus.com/2014/01/std-set-example-c.html))\n\n## unordered_set 無序集合 & unordered_map 無序映射\n\n兩者為 `set`、`map` 的延伸，用法相似但因為底層使用 `雜湊表 Hash Table` 實作，所以**內部不排序**\n因為無序，所以當然沒有 `lower_bound()`、`upper_bound()`，`unordered_map` 支援下標\n插入/刪除/查詢的時間複雜度平均 $O(1)$，最壞 $O(n)$（Hash 碰撞）\n常數較大，競賽中非必要時不常用\n\n\n\n### 示意圖\n\n![image](https://hackmd.io/_uploads/Hy_gSk1uT.png)\n\n([圖片來源](https://conglang.github.io/2015/01/01/stl-unordered-container/))\n\n\n### 延伸閱讀\n\n- [資料結構 - 雜湊表 Hash Table](https://ithelp.ithome.com.tw/articles/10268077?sc=iThelpR)\n- [雜湊表（Hash Table）- 拉爾夫的技術隨筆](https://medium.com/@ralph-tech/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E9%9B%9C%E6%B9%8A%E8%A1%A8-hash-table-15f490f8ede6)\n示意圖([圖片來源](https://conglang.github.io/2015/01/01/stl-unordered-container/))\n![image](https://hackmd.io/_uploads/Hk_j4ykda.png)\n\n\n\n## unordered_multiset 無序多重集合 & unordered_multimap 無序多重映射\n\n依名稱即可知道為前兩者的結合，**內部不排序且可允許重複元素**\n\n\n### set / map 延伸容器對照表\n| 容器 | 是否排序 | 是否允許重複 | 下標支援 | 插入/刪除/查找平均時間複雜度 |\n| --- | --- | --- | --- | --- |\n| set | ✅ | ❌ | ❌ | $O(\\log n)$ |\n| map | ✅ | ❌ | ✅ | $O(\\log n)$ |\n| multiset | ✅ | ✅ | ❌ | $O(\\log n)$ |\n| multimap | ✅ | ✅ | ❌ | $O(\\log n)$ |\n| unordered_set | ❌ | ❌ | ❌ | 平均 $O(1)$ |\n| unordered_map | ❌ | ❌ | ✅ | 平均 $O(1)$ |\n| unordered_multiset | ❌ | ✅ | ❌ | 平均 $O(1)$ |\n| unordered_multimap | ❌ | ✅ | ❌ | 平均 $O(1)$ |\n\n\n## bitset 位集\n\n`bitset` 為固定長度的位元集合，可以視為一個**效率很快的 bool 陣列**\n因為 `bool` 這個型別明明只能表示 `true` 或 `false`，但通常卻佔了 `1 byte` 的記憶體空間\n用 `bitset` 可以**宣告固定長度的 bits**，可以想像為一堆 0 和 1 的陣列\n並且 `bitset` 的**位元運算**是被優化過的，對常數優化及空間壓縮有不錯的效果，速度大約是 **bool 的 32 倍**\n\n### 可支援的操作函數\n\n| 編號 | 操作方法                   | 功能介紹                            | 時間複雜度  |\n| -- | ---------------------- | ------------------------------- | ------ |\n| 1  | `b[i]`                 | 存取第 i 位                   | $O(1)$ |\n| 2  | `b.size()`             | 回傳 b 的總位數                       | $O(1)$ |\n| 3  | `b.count()`            | 計算 b 中為 1 的位數                   | $O(N)$ |\n| 4  | `b.set()`              | 將所有位元設為 1                       | $O(N)$ |\n| 5  | `b.reset()`            | 將所有位元設為 0                       | $O(N)$ |\n| 6  | `b.flip()`             | 將所有位元取反（0 ↔ 1）                  | $O(N)$ |\n| 7  | `b.any()` / `b.none()` | 檢查是否有至少一個位元為 1 / 全部為 0          | $O(N)$ |\n| 8  | `b.to_string()`        | 將 bitset 轉為字串                   | $O(N)$ |\n| 9  | `b.to_ulong()`         | 將 bitset 轉為 unsigned long（注意溢位） | $O(N)$ |\n\n\n### 常用基本操作 Code\n\n```cpp=\n// 宣告\nbitset<5> b; // 大小為 5，初始值 00000\n\n// 賦值\nb[0] = 1; // 00001 以右邊為低位\n\n// 設置\nb.set();\t// 11111\nb.reset();  // 00000\nb.flip();   // 11111\n\n// 計數與檢查\ncout << b.count() << \"\\n\"; // 5\ncout << b.any() << \"\\n\";   // 1 (true)\ncout << b.none() << \"\\n\";  // 0 (false)\n\n// 轉換\ncout << b.to_string() << \"\\n\";  // \"11111\"\ncout << b.to_ulong() << \"\\n\";   // 31\n\n// 位元運算\nbitset<5> a(\"10101\"), b(\"01110\");\ncout << (a & b) << \"\\n\"; // 00100\ncout << (a | b) << \"\\n\"; // 11111\ncout << (a ^ b) << \"\\n\"; // 11011\n```\n\n### 常見應用\n\n- 空間優化\n- 狀態壓縮 DP\n\n---\n\n# 容器分類表格\n| 類別分類 | 主要容器 | 用途 / 特點 |\n| --- | --- | --- |\n| **序列式容器** | `vector`, `deque`, `list` | 存放有序元素，支援迭代器操作；`vector` 隨機存取快，`deque` 前後操作靈活，`list` 雙向鏈結串列，插入刪除快 |\n| **容器適配器** | `stack`, `queue`, `priority_queue` | 封裝序列式容器，提供特定操作：`stack`（後進先出）、`queue`（先進先出）、`priority_queue`（依優先權排序） |\n| **關聯容器** | `set`, `map`, `multiset`, `multimap` | 自動排序，快速查找、插入、刪除；`set` 存唯一元素，`map` 存 key-value；`multiset`/`multimap` 允許重複 |\n| **無序容器** | `unordered_set`, `unordered_map`, `unordered_multiset`, `unordered_multimap` | 基於 Hash 表，平均 O(1) 查找、插入；最壞情況 O(n)；元素無序 |\n| **工具型容器** | `pair`, `tuple`, `bitset` | 儲存固定數量元素或位元資訊；`pair` 兩個元素，`tuple` 多個元素，`bitset` 二進位操作與狀態壓縮 |\n\n\n# 題單\n\n看完這篇筆記相信大家對 STL 有一定的瞭解了，不過還是要實際練習才能掌握，所以我把曾經寫過的題目整理成資料庫，來自各大 Online Judge，有依照不同的難度及不同資料結構分類好，歡迎大家自行運用，多練習才能讓你更加熟練。\n## [STL 題單連結 - Notion](https://shiyu0318.notion.site/C-STL-ShiYu-s-Blog-c2ed8c6b22fb4118bab30b62dbad5299?pvs=4)\n\n---\n\n# Outro\n\n這篇文章只用了兩天的時間，從收集資料、整理資訊、規劃架構，再來開始寫每個資料結構的內容，製作表格、寫 Code、找圖片（每張圖片皆有附上來源）、找補充資料，到最後不斷地重複新增和修改內容，直到整篇文章逐漸完整，我從中學習到的不只有這篇文章所呈現的知識，還有很多重要的能力，也感受到了學習的快樂，日後會不斷地學習新知識，也會針對各主題寫成一篇筆記發佈，感謝大家的閱讀\n\n## 下回預告：{% btn /post/Data-Structures/,點擊前往,fa-solid fa-hand-point-right,blue %} C++ 實作資料結構\n\n---\n\n# 參考資料\n\n- [The C++ Standard Template Library (STL)\n](https://www.geeksforgeeks.org/the-c-standard-template-library-stl/)\n- [從零開始的演算法競賽入門教學 - STL](https://emanlaicepsa.github.io/2020/11/30/0-16/)\n- [Ian Shih - STL Containers - HackMD](https://hackmd.io/@konchin/BkGVGVd9I)\n- [C++ 中 STL 用法超詳細總結 - Github](https://github.com/0voice/cpp_backend_awsome_blog/blob/main/%E3%80%90NO.19%E3%80%91C++%E4%B8%ADSTL%E7%94%A8%E6%B3%95%E8%B6%85%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93%EF%BC%88%E6%94%B6%E8%97%8F%E7%BA%A7%EF%BC%89.md)\n- [進階 C++ STL 迭代器 - HackMD](https://hackmd.io/@Greenleaf/advanced_cpp)\n- [C++ STL 常用容器以及操作簡介](https://blog.csdn.net/zygood_/article/details/122457444)\n- [C++ STL 學習總結(全面)](https://jasonblog.github.io/note/c++/c++_stl_xue_xi_zong_7d5028_quan_976229.html)\n- [STL in C++ - Youtube](https://youtube.com/playlist?list=PLk6CEY9XxSIA-xo3HRYC3M0Aitzdut7AA&si=q5I7ppldSRGBKsKq)\n- [cplusplus reference](https://cplusplus.com/reference/)\n- [cppreference](https://en.cppreference.com/w/)\n\n---\n\n{% btn '/post/Sitemap/',回到導覽頁面,far fa-hand-point-right,blue block center larger %}\n\n---","tags":["C++","資料結構 Data Structures","動態陣列 vector","串列 list","字串 string","數對 pair","數組 tuple","堆疊 stack","佇列 queue","雙端佇列 deque","優先佇列 priority_queue","集合 set","映射 map","多重集合 multiset","多重映射 multimap","無序集合 unordered_set","無序映射 unordered_map","位集 bitset"],"categories":["筆記","DSA"]},{"title":"訓練神經網路計算過程","url":"/post/Neural-Network/","content":"\n這是一個具有一層隱藏層的神經網路：\n\n![神經網路示意圖](https://hackmd.io/_uploads/S1zIPbGw6.png)\n\n# 假設\n\n- 輸入層有 3 個節點，輸入 X 中有 3 筆數據，其標籤為 Y：\n$$  \n    X = \n        \\begin{bmatrix}\n            1 & 2 & 0   \\\\\n            2 & -3 & 2  \\\\\n            -1 & -1 & 3 \\\\\n        \\end{bmatrix},\n    Y = \n        \\begin{bmatrix}\n            1  \\\\\n            2  \\\\\n            -3 \\\\\n        \\end{bmatrix}\n$$\n\n$$  \n    W_1 = \n        \\begin{bmatrix}\n            -1 & 0 \\\\\n            -1 & 1 \\\\\n            1 & -1 \\\\\n        \\end{bmatrix}\n$$\n\n- 隱藏層有 2 個節點，隱藏層權重矩陣為 $W_1$，線性組合 $Z=XW_1$，\n  經過激活函數 $\\sigma$ 後的值為 $K$，即 $K = \\sigma(Z)$\n- 另激活函數 $\\sigma$ 為 $Relu$ 函數， $\\sigma(x)=Relu(x)=max(x,0)$\n- 輸出層有 1 個節點，其權重矩陣為 $W_2$，線性輸出 $O=KW_2$\n\n$$  \n    W_2 = \n        \\begin{bmatrix}\n            1  \\\\\n            -2 \\\\\n        \\end{bmatrix}\n$$\n\n- 將輸出值與標籤去計算損失，令損失為 $J$，假設使用加總型式的最小平方損失\n\n$$ J = \\sum (\\frac{1}{2}(O-Y)^2) $$\n\n此時，已知輸出層梯度：\n\n$$G_{out} = \\frac{\\partial J}{\\partial O}=O-Y$$\n\n- 隱藏層梯度：\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        G_2\n        &= \n            \\frac{\\partial J}{\\partial W_2}\n         = \n            \\frac{\\partial J}{\\partial O} \\frac{\\partial O}{\\partial W_2} \n            \\\\\\\\\n        &= \n            ((G_{out})^T \\cdot K)^T \n         = \n            K^TG_{out}\n    \\end{aligned}\n\\end{equation}\n$$\n\n- $Relu$ 函數的微分式：\n\n$$\n\\sigma^{\\prime}(x) = \n    \\begin{cases}\n        0 \\quad x < 0   \\\\\n        1 \\quad x \\ge 0 \\\\\n    \\end{cases}\n$$\n\n- 先假定一個暫存的 $G_{temp}$ ：\n\n$$ G_{temp} = (G_{out} \\cdot W^T_2) \\circ \\sigma^{\\prime}(Z) $$\n\n其中的 $\\cdot$ 代表一般的矩陣乘法、$\\circ$ 代表阿達瑪乘積，為對應位置的矩陣元素乘積\n\n- 輸入層梯度：\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        G_1\n        &= \n            \\frac{\\partial J}{\\partial W_1}\n         = \n            \\frac{\\partial J}{\\partial O} \n            \\frac{\\partial O}{\\partial K}\n            \\frac{\\partial K}{\\partial Z}\n            \\frac{\\partial Z}{\\partial W_1} \n            \\\\\\\\\n        &= \n            (((G_{out} \\cdot W^T_2) \\circ \\sigma^{\\prime} (Z))^T \\cdot X)^T \n            \\\\\\\\\n        &= \n            ((G_{temp})^T \\cdot X)^T \n            \\\\\\\\\n        &= \n            X^TG_{temp}\n    \\end{aligned}\n\\end{equation}\n$$\n\n- 可用 $G_1,G_2$ 梯度更新權重 $W_1,W_2$ 的值，得到新權重 $W_1^{new},W_2^{new}$，\n\n假設我們採用隨機梯度下降法來進行更新，且學習率令為 $0.1$，則\n\n$$\n\\begin{cases}\n    W_1^{new} = W_1 - 0.1 \\times G_1 \\\\\n    W_2^{new} = W_2 - 0.1 \\times G_2 \\\\\n\\end{cases}\n$$\n\n# 問題\n\n求矩陣 $Z,K,O,G_{out},G_2,\\sigma^{\\prime}(Z),G_{temp},G_1,W_1^{new},W_2^{new}$\n\n> 求解過程皆省略公式推導過程，將直接使用最終結果代入計算\n\n---\n\n$Z$\n\n由線性組合 $Z=XW_1$：\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        Z\n        &= \n            XW_1 \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                1 & 2 & 0   \\\\\n                2 & -3 & 2  \\\\\n                -1 & -1 & 3 \\\\\n            \\end{bmatrix} \n            \\cdot\n            \\begin{bmatrix}\n                -1 & 0 \\\\\n                -1 & 1 \\\\\n                1 & -1 \\\\\n            \\end{bmatrix} \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -3 & 2 \\\\\n                3 & -5 \\\\\n                5 & -4 \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n$K$\n\n由經過激活函數 $\\sigma$ 後的值 $K = \\sigma(Z)$，且激活函數 $\\sigma$ 為 $Relu$ 函數， $\\sigma(x)=Relu(x)=max(x,0)$：\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        K \n        &= \n            \\sigma(Z) \n            \\\\\\\\\n        &= \n            \\sigma\\ \n            (\n            \\begin{bmatrix}\n                -3 & 2 \\\\\n                3 & -5 \\\\\n                5 & -4 \\\\\n            \\end{bmatrix}\n            ) \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                0 & 2 \\\\\n                3 & 0 \\\\\n                5 & 0 \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n$O$\n\n輸出層有 1 個節點，其權重矩陣為 $W_2$，由線性輸出 $O=KW_2$：\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        O \n        &= \n            KW_2 \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                0 & 2 \\\\\n                3 & 0 \\\\\n                5 & 0 \\\\\n            \\end{bmatrix} \n            \\cdot\n            \\begin{bmatrix}\n                1  \\\\\n                -2 \\\\\n            \\end{bmatrix} \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -4 \\\\\n                3  \\\\\n                5  \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n$G_{out}$\n\n由輸出層梯度 $G_{out} = O-Y$：\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        G_{out} \n        &= \n            O-Y \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -4 \\\\\n                3  \\\\\n                5  \\\\\n            \\end{bmatrix} \n            - \n            \\begin{bmatrix}\n                1  \\\\\n                2  \\\\\n                -3 \\\\\n            \\end{bmatrix} \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -5 \\\\\n                1  \\\\\n                8  \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n$G_2$\n\n由隱藏層梯度 $G_2 = K^TG_{out}$，其中 $K^T$ 為 矩陣 $K$ 的轉置：\n\n$$\nK = \n    \\begin{bmatrix}\n        0 & 2 \\\\\n        3 & 0 \\\\\n        5 & 0 \\\\\n    \\end{bmatrix},\nK^T = \n    \\begin{bmatrix}\n        0 & 3 & 5 \\\\\n        2 & 0 & 0 \\\\\n    \\end{bmatrix}\n$$\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        G_2 \n        &= \n            K^TG_{out} \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                0 & 3 & 5 \\\\\n                2 & 0 & 0 \\\\\n            \\end{bmatrix} \n            \\cdot\n            \\begin{bmatrix}\n                -5 \\\\\n                1  \\\\\n                8  \\\\\n            \\end{bmatrix} \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                43   \\\\\n                -10  \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n$\\sigma^{\\prime}(Z)$\n\n其中 $\\sigma^{\\prime}$ 為 $Relu$ 函數的微分式：\n\n$$\n\\sigma^{\\prime}(x) = \n\\begin{cases}\n    0 \\quad x < 0   \\\\\n    1 \\quad x \\ge 0 \\\\\n\\end{cases}\n$$\n$$\n\\begin{equation}\n    \\begin{aligned}\n        \\sigma^{\\prime}(Z)\n        &= \n            \\sigma^{\\prime}(\n            \\begin{bmatrix}\n                -3 & 2 \\\\\n                3 & -5 \\\\\n                5 & -4 \\\\\n            \\end{bmatrix}) \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                0 & 1 \\\\\n                1 & 0 \\\\\n                1 & 0 \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n$G_{temp}$\n\n由假定暫存的 $G_{temp} = (G_{out} \\cdot W^T_2) \\circ \\sigma^{\\prime}(Z)$\n其中的 $\\cdot$ 代表一般的矩陣乘法、$\\circ$ 代表阿達瑪乘積，為對應位置的矩陣元素乘積，且 $W_2^T$ 為矩陣 $W_2$ 的轉置：\n\n$$\nW_2 = \n    \\begin{bmatrix}\n        1  \\\\\n        -2 \\\\\n    \\end{bmatrix},\nW_2^T = \n    \\begin{bmatrix}\n        1 & -2 \\\\\n    \\end{bmatrix}\n$$\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        G_{temp} \n        &= \n            (G_{out} \\cdot W^T_2) \\circ \\sigma^{\\prime}(Z) \n            \\\\\\\\\n        &=  (\n            \\begin{bmatrix}\n                -5 \\\\\n                1  \\\\\n                8  \\\\\n            \\end{bmatrix} \\cdot\n            \\begin{bmatrix}\n                1 & -2\n            \\end{bmatrix}\n            ) \\circ \n            \\begin{bmatrix}\n                0 & 1 \\\\\n                1 & 0 \\\\\n                1 & 0 \\\\\n            \\end{bmatrix}\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -5 & 10 \\\\\n                1 & -2 \\\\\n                8 & -16 \\\\\n            \\end{bmatrix}\n            \\circ \n            \\begin{bmatrix}\n                0 & 1 \\\\\n                1 & 0 \\\\\n                1 & 0 \\\\\n            \\end{bmatrix} \n            \\\\\\\\\n        &=\n            \\begin{bmatrix}\n                0 & 10 \\\\\n                1 & 0 \\\\\n                8 & 0 \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n$G_1$\n\n由輸入層梯度 $G_1 = X^TG_{temp}$，其中 $X^T$ 為 矩陣 $X$ 的轉置：\n\n$$\nX = \n    \\begin{bmatrix}\n        1 & 2 & 0   \\\\\n        2 & -3 & 2  \\\\\n        -1 & -1 & 3 \\\\\n    \\end{bmatrix},\nX^T = \n    \\begin{bmatrix}\n        1 & 2 & -1   \\\\\n        2 & -3 & -1  \\\\\n        0 & 2 & 3    \\\\\n    \\end{bmatrix},\n$$\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        G_1\n        &= \n            X^TG_{temp}\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                1 & 2 & -1   \\\\\n                2 & -3 & -1  \\\\\n                0 & 2 & 3    \\\\\n            \\end{bmatrix}\n            \\cdot\n            \\begin{bmatrix}\n                0 & 10 \\\\\n                1 & 0  \\\\\n                8 & 0  \\\\\n            \\end{bmatrix}\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -6 & 10  \\\\\n                -11 & 20 \\\\\n                26 & 0   \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n$W_1^{new},W_2^{new}$\n\n- 可用 $G_1,G_2$ 梯度更新權重 $W_1,W_2$ 的值，得到新權重 $W_1^{new},W_2^{new}$，\n已知我們採用隨機梯度下降法來進行更新，且學習率為 $0.1$，則\n\n$$\n\\begin{cases}\n    W_1^{new} = W_1 - 0.1 \\times G_1 \\\\\n    W_2^{new} = W_2 - 0.1 \\times G_2 \\\\\n\\end{cases}\n$$\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        W_1^{new}\n        &= \n            W_1 - 0.1 \\times G_1\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -1 & 0 \\\\\n                -1 & 1 \\\\\n                1 & -1 \\\\\n            \\end{bmatrix}\n            - 0.1 \\times\n            \\begin{bmatrix}\n                -6 & 10  \\\\\n                -11 & 20 \\\\\n                26 & 0   \\\\\n            \\end{bmatrix}\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -1 & 0 \\\\\n                -1 & 1 \\\\\n                1 & -1 \\\\\n            \\end{bmatrix}\n            - \n            \\begin{bmatrix}\n                -0.6 & 1  \\\\\n                -1.1 & 2  \\\\\n                2.6 & 0   \\\\\n            \\end{bmatrix}\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -0.4 & -1 \\\\\n                0.1 & -1  \\\\\n                -1.6 & -1 \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        W_2^{new}\n        &= \n            W_2 - 0.1 \\times G_2\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                1  \\\\\n                -2 \\\\\n            \\end{bmatrix}\n            - 0.1 \\times\n            \\begin{bmatrix}\n                43   \\\\\n                -10  \\\\\n            \\end{bmatrix}\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -1 & 0 \\\\\n                -1 & 1 \\\\\n                1 & -1 \\\\\n            \\end{bmatrix}\n            - \n            \\begin{bmatrix}\n                4.3 \\\\\n                -1  \\\\\n            \\end{bmatrix}\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -3.3 \\\\\n                -1   \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n{% btn '/post/Sitemap/',回到導覽頁面,far fa-hand-point-right,blue block center larger %}\n\n---","tags":["神經網路 Neural Network","損失函數 Loss Function","梯度下降演算法 Gradient Descent","激活函數 Activity Function","AI 人工智慧","矩陣 Matrix"],"categories":["筆記","AI"]},{"title":"資訊學科能力競賽 參賽心得","url":"/post/NHSPC/","content":"\n## 競賽資訊\n- 名稱：112 學年度學科能力競賽 複賽 資訊科 \n- 賽區：國教署負責區第四區（台南）\n- 時間：2023/11/2\n- 地點：台南女中\n- 比賽人數：50 人（資訊科）\n- 獲獎人數：1 ~ 5 名進全國賽 再大約取前三分之一的人獲得佳作\n- 當天詳細時程：\n![IMG_3075.jpeg](https://hackmd.io/_uploads/SyMM0IGXp.jpg)\n\n## 前言\n這是我第一次比資訊學科能力競賽 高一時不知道在幹嘛 那時不太關注資訊比賽\n南大附中好像也沒什麼人比過資訊能競 所以我跟 @Yudong 不用校內初選就直接進複賽了\n南區去年只有選 3 名進全國賽 今年因為去年的南一中有人全國賽一等二等獎 所以新增了 2 個 總共有 5 個名額 ~~賽前猜測沒意外應該都是南一中的~~\n我們第一次比賽就遇到主辦方各種出錯 這個留到文章最後再說\n此篇文章就是寫我參加此競賽的過程、解題程式碼、心得、和檢討\n純粹記錄自己這個時候有多菜 讓自己幾年後可以回顧一下\n如果你也是資訊選手或打競程的 那這篇其實可以滑掉不用看了\n因為對你來說可能是一篇廢文 沒什麼參考價值\n\n## 上午場\n報到抽籤後 發現只有我們學校沒有領隊...\n到了我們學校的座位 被排在最後一排\n我跟 Yudong 在猜這座位配置是不是依照學校的得獎次數排的哈哈\n![IMG_3133.jpeg](https://hackmd.io/_uploads/HkkafDMQp.jpg)\n我在活動中心其實滿緊張的 雖然前幾個禮拜也有參加比賽：CodeWars、金盾獎 但都是抱持著輕鬆愉快的心情比的\n可能是因為這場能競對我來說算是滿重要的比賽 整個狀態有點緊繃\n到了電腦教室測試時 主辦就開始出現錯誤了 我先跳過這部分最後再說\n來寫一下解題過程 \n\n### p1 \n第 1 題明顯滿難的 我看到就先跳過了\n\n### p2\n- 題意\n```\n有各不同的分數種類： 50 25 10 5 1 \n求總和為 N 分的組合數\n```\n\n- Input\n```\n2\n11\n26\n```\n\n- Output\n```\n4\n13\n```\n\n\n- 解題想法\n```\n3 層 for 迴圈枚舉每種分數各取幾次\n因為取完 前幾種分數 剩餘的都可以用 1 分來湊\n看了數字範圍 確認此做法不會超時後開始寫 Code\n```\n\n- <span style=\"color:green\">AC</span> Code\n```cpp=\n#include <bits/stdc++.h>\nusing namespace std;\n#define ShiYu ios::sync_with_stdio(0),cin.tie(0)\n#define FOR(i,n) for(int i=0; i<=n; ++i)\n\nsigned main(void)\n{\n    ShiYu;\n    int t; cin >> t;\n    int n;\n    while(t--)\n    {\n        cin >> n;\n        int ans = 0;\n        FOR(i, n / 50)\n        {\n            FOR(j, (n - i*50) / 25)\n            {\n                FOR(k, (n - i*50 - j*25) / 10)\n                {\n                    ans += (n - i*50 - j*25 - k*10) / 5 + 1;\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n}\n```\n\n### p3 疊蛋餅\n\n- 題意\n```\n要疊 n 層圓形蛋餅 最底層的蛋餅半徑是 1\n每層的半徑都不能比下面整疊的最大半徑多出 1 以上\n求有幾種可能\n```\n\n- 解題想法\n\n一開始就先寫出 1 2 3 4 層的可能性\n我用樹狀圖來畫出每層的可能性 然後試著尋找規律\n![1 (1).png](https://hackmd.io/_uploads/HyDkovMmT.png)\n後來觀察出會有重複計算的地方\n![1 (2).png](https://hackmd.io/_uploads/SkiMswf76.png)\n但就算這樣我還是不知道該如何用程式去計算出所有可能\n因為有會重複計算到的數值 所以不能用暴力枚舉的方法 \n我猜應該是用動態規劃 DP 把算完的東西記下來 不過在賽中我沒有解出來\n後來跟新化高中的 Eason 與 Silv 討論\n他們也覺得這題很難讀懂題目意思\n\n### p4 最大矩形面積\n- 題意\n```\n給一張大小為 n x m 且由 0 與 1 所組成的二維陣列\n1 是有種樹, 0 是沒樹\n求沒種樹的最大面積\n```\n\n- Input\n```\n6 7\n0010100\n0100001\n1010000\n1100001\n0010001\n0110101\n```\n\n- Output\n```\n12\n```\n\n顯然是找出中間這塊算出面積就好\n![IMG_3135.jpeg](https://hackmd.io/_uploads/HknXCvzQp.jpg)\n我在賽中不知道該如何用程式實作出來\n聽 Silv 說這是 CSES 的經典題 用**二維前綴和**就能解出來了\n但我學會的沒有很多而且練習的題目太少了 不知道能這樣做\n\n### p5\n- 題意\n```\n有人把一條方程式中的 + 與 * 寫反了\n所以給整數 a\n求有幾組整數 b , c \n能滿足 a + (b * c) = a * (b + c)\n若有無限解 則輸出 -1\n```\n\n- 解題想法\n一看就是個數學題\n我把式子移項後變成 $b \\times c = a \\times (b + c - 1)$\n腦中馬上想到了算幾不等式 $\\frac{a+b}{2} \\ge \\sqrt{ab}$ 感覺解法會往這個方向走\n但因為題目說可能會有無限解 所以我在賽中想不到如何判斷是否有無限解的方法就沒解出來了\n\n### p6 p7\n不在我能力範圍內 跳過\n\n### p8 \n- 題意\n```\n給 n 個整數\n若選擇了第 i 個整數 \n則 i+1 與 i-1 （前後兩數）都不能選\n求最大總和\n```\n- 解題想法\n我原本用 Greedy 來做 每次都選最大的數字\n後來發現如果第 i 個數字最大 我選了 i \n但前後兩數加起來比 i 大我卻不能選 這樣就不是最大總和了\n所以這題要用 DP 來做 聽說 CSES 也有這種題目\n我真的練太少題目了 連這種簡單經典題都寫不出來\n\n### p9\n\n- 題意\n```\n有 n 人要分組\n給 i = 0 ~ n-1\nai 為 i 的組員\n求每組成員及組數\n```\n\n- Input\n```\n6\n2 4 3 5 1 0\n```\n把輸入做成表格\n\n|    人的編號    | 0   | 1   | 2   | 3   | 4   | 5   |\n|:--------------:| --- | --- | --- | --- | --- | --- |\n| 他的組員的編號 | 2   | 4   | 3   | 5   | 1   | 0   |\n\n- Output\n```\n0 2 3 5\n1 4\n2\n```\n把輸出做成表格\n| 組別   | 組員    |\n| ------ | ------- |\n| 第一組 | 0 2 3 5 |\n| 第二組 | 1 4     |\n\n- 解題想法\n~~來自 SCIST S4 總召 Fishhh 的梗~~\n![image.png](https://hackmd.io/_uploads/r1noZXbma.png)\n\n- <span style=\"color:green\">AC</span> Code\n```cpp=\n#include <bits/stdc++.h>\nusing namespace std;\n#define ShiYu ios::sync_with_stdio(0),cin.tie(0)\n#define FOR(i,n) for(int i=0; i<n; ++i)\n\nsigned main(void)\n{\n    ShiYu;\n    int n; cin >> n;\n    int a[n]; FOR(i,n) cin >> a[i];\n    vector<vector<int> > v;\n    FOR(i,n)\n    {\n        if(a[i] == -1) continue;\n        vector<int> t;\n        t.push_back(i);\n        int next = a[i], b = i;\n        while(a[next] != -1)\n        {\n            t.push_back(next);\n            a[b] = -1;\n            b = next;\n            next = a[next];\n        }\n        a[b] = -1;\n        v.push_back(t);   \n    }\n    FOR(i,v.size())\n    {\n        FOR(j,v[i].size())\n        {\n            cout << v[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n    cout << v.size() << \"\\n\";\n}\n```\n\n---\n\n## 下午場 2 小時 <span style=\"color:green\">2</span> / 6\n\n\n### p1\n- 題意\n```\n每天有 10 小時可以用\n給很多組活動的 起始時間 與 結束時間\n求如何安排才能在 10 小時中舉辦最多活動\n```\n這題感覺很簡單不過一樣的我也沒有寫過類似的題目所以跳過\n後來聽新化的 Silv 說只要過濾較多時間的活動\n然後依結束時間排序活動 再依開始時間挑選活動就可以了\n\n### p2\n我把下午的比賽時間都砸在這題上了\n\n- 題意\n```\n給 n 間糖果店\n每間不同的店花 1 塊錢可以買到不同的 a 顆糖果\n且每間店都會額外贈送 b 顆糖果\n有 q 筆操作\n分為兩類\n1. 把第 x 間店 移動到 第 y 個位置\n2. 詢問在 L 與 R 間店中 可以選擇「一間」買糖果 有 x 塊錢可以買 求糖果最大值\n```\n\n- Input\n```\n5\n2 2\n4 5\n1 3\n3 6\n1 7\n3\n2 2 3 3\n1 2 4\n2 2 3 3\n```\n\n- Output\n```\n17\n15\n```\n\n- <span style=\"color:green\">AC</span> Code\n```cpp=\n#include <bits/stdc++.h>\nusing namespace std;\n#define ShiYu ios::sync_with_stdio(0),cin.tie(0)\n#define FOR(i,n) for(int i=0; i<n; ++i)\n#define vpii vector<pair<int,int> >\n\nsigned main(void)\n{\n    ShiYu;\n    int n; cin >> n;\n    vpii v;\n    int a,b;\n    while(n--)\n    {\n        cin >> a >> b;\n        v.push_back(make_pair(a,b));\n    }\n    int q; cin >> q;\n    int t;\n    while(q--)\n    {\n        cin >> t;\n        if(t == 1)\n        {\n            int x, y; cin >> x >> y;\n            vpii vt;\n            pair<int,int> p;\n            FOR(i,v.size())\n            {\n                if(i + 1 == x)\n                {\n                    p = v[i];\n                    continue;\n                }\n                else if(i == y)\n                {\n                    vt.push_back(p);\n                }\n                vt.push_back(v[i]);\n            }\n            v = vt;\n        }\n        else if(t == 2)\n        {\n            int l, r, x; cin >> l >> r >> x;\n            int maxn = -1;\n            for(int i=l-1; i<r; ++i)\n            {\n                int sum = v[i].first * x + v[i].second;\n                if(sum > maxn) maxn = sum;\n            }\n            cout << maxn << \"\\n\";\n        }\n    }\n}\n```\n\n一開始以為第 1 種操作是交換兩間店的位置\n後來才知道是把第 x 間店抽掉後 插入到 第 y 個位置 其餘的順延補上\n但寫完還是錯 因為後來這題題目在賽中被主辦方改過題目意思\n害我原本照著原題目意思寫的程式碼都要改掉\n上面的版本是已經重新寫過而且在最後幾分鐘通過的\n原版意思是可以去「任何」糖果店買糖果 後來才改成只能去「一間」買\n這個題目意思改動浪費了我超級多時間修改程式碼＝＝\n原版程式碼多用了 bool 記錄每間糖果店有沒有去買過\n用了 `vector< pair< pair<int,int>,bool > >`\n（事後感覺用 tuple 或 struct 會比較好）\n也判斷了每塊硬幣要去哪間糖果店買才會得到最多糖果\n寫完比上面的程式碼還要多了整整 20 行\n原版 Code：\n```cpp=\n#include <bits/stdc++.h>\nusing namespace std;\n#define ShiYu ios::sync_with_stdio(0),cin.tie(0)\n#define FOR(i,n) for(int i=0; i<n; ++i)\n#define  \n\nsigned main(void)\n{\n    ShiYu;\n    int n; cin >> n;\n    vector<pair<pair<int,int>,bool> > v;\n    int a,b;\n    while(n--)\n    {\n        cin >> a >> b;\n        v.push_back(make_pair(make_pair(a,b),true));\n    }\n    int q; cin >> q;\n    int t;\n    while(q--)\n    {\n        cin >> t;\n        if(t == 1)\n        {\n            int x, y; cin >> x >> y;\n            vector<pair<pair<int,int>,bool> > vt;\n            pair<pair<int,int>,bool> p;\n            FOR(i,v.size())\n            {\n                if(i + 1 == x)\n                {\n                    p = v[i];\n                    continue;\n                }\n                else if(i == y)\n                {\n                    vt.push_back(p);\n                }\n                vt.push_back(v[i]);\n            }\n            v = vt;\n        }\n        else if(t == 2)\n        {\n            int l, r, x; cin >> l >> r >> x;\n            int maxn = -1,now=-1,sum = 0;\n            while(x--)\n            {\n                for(int i=l-1; i<r; ++i)\n                {\n                    if(v[i].second == true)\n                    {\n                        if(v[i].first.first + v[i].first.second > maxn)\n                        {\n                            maxn = v[i].first.first + v[i].first.second;\n                            now = i;\n                        }\n                    }\n                    else if(v[i].second == false)\n                    {\n                        if(v[i].first.first > maxn)\n                        {\n                            maxn = v[i].first.first;\n                            now = i;\n                        }\n                    }\n                }\n                sum += maxn;\n                v[now].second = false;\n            }\n            cout << sum << \"\\n\";\n        }\n    }\n}\n\n```\n\n### p3 ~ p5\n由於花太多時間在 p2 了 根本來不及想這 3 題要怎麼做\n\n### p6\n\n- 題意 \n~~這題題目超長 花了一整頁的文字在介紹 2 進制如何進位  根本素養題 所以我直接濃縮成兩句話~~\n```\n給 a b 兩正整數\n求相乘後的 2 進制與 10 進制\n```\n\n- Input\n```\n31\n26\n```\n\n- Output\n```\n1100100110\n806\n```\n\n- 解題想法\n```\n先直接 a * b 求 10 進位後用字串的方法換成 2 進位\n這題新化社長 Eason 說他是用位元左移右移來做 但我太笨了不會那種方法\n```\n\n```cpp=\n#include <bits/stdc++.h>\nusing namespace std;\n#define ShiYu ios::sync_with_stdio(0),cin.tie(0)\n#define FOR(i,n) for(int i=0; i<n; ++i)\n\nsigned main(void)\n{\n    ShiYu;\n    int a, b; cin >> a >> b;\n    int n = a * b, t = n;\n    string s = \"\";\n    while(t != 0)\n    {\n        if(t % 2) s = \"1\" + s;\n        else s = \"0\" + s;\n        t /= 2;\n    }\n    cout << s << \"\\n\" << n << \"\\n\";\n}\n```\n\n---\n\n{% hideToggle 抱怨區 可跳過或忽視 %}\n\n這裡詳細講一下主辦方這次競賽發生的一堆錯誤\n1. 賽前測試沒有把系統用好 導致大家上傳測試題的程式碼時都發生 SE（系統錯誤）主辦卻說這不影響正式比賽 延誤了很久才開始\n2. 正式開始之後 評測系統又掛掉了 大家都沒辦法登進去提交程式碼 於是主辦就開始做起超荒謬的事：人工評測 我當下是超級傻眼 ~~都 2023 年了還在人工 Judge~~\n3. 人工評測只是叫你執行程式然後輸入範例測資看有沒有跟範例輸出一樣 然後簡單看了一下程式碼就直接算你通過 我認為這喪失了公平性因為人工評測是直接用範例測資來看輸出是否正確 但正常比賽用的線上評測是由很多筆測試資料測試你的程式碼是否通過 如果用人工評測範例測資輸出正確 但程式碼錯誤 卻沒被檢查到呢？\n4. 在系統正常後 我提交了剛剛人工評測通過的題目程式碼看看是否在評測平台也能通過 雖然成功通過 但主辦方過了一陣子才出來說：人工評測通過的人不用傳線上評測 又說上傳的話會影響原本人工評測時紀錄的時間 我都已經在平台正常的那刻上傳通過了之後才說不用傳＝＝ 而且重點是不傳怎麼知道程式碼通過或不通過？那如果有人人工評測正確但程式碼錯誤卻又不用上傳線上評測 是不是就多賺別人一題？\n5. 主辦出題感覺真的很不用心 不知道有沒有認真審題 題目很多數字都沒給範圍 然後很多題都需要在賽中出來大聲講解補充題目意思 很多題都是在比賽時改了又改 還有重新拿一張題目給我們的 一堆題目連範例側資都是錯的 還叫我們整個打叉不要看 然後我都已經照著原版題目意思寫完程式碼了 才出來把題目意思改掉讓我重新修改程式碼\n\n{% endhideToggle %}\n\n---\n\n## 心得 & 檢討\n\n這次比賽總共 15 題 我只解出 4 題\n有很多都是出自 CSES 的簡單經典題\n而我卻因為練太少題目 都想不出解法\n這場比賽集結了很多電神 整個比賽會場都充滿著高壓電\n全場最強第一名的自學生趙翊佑（聽說是陳水扁的孫子）\n還有前幾名有進全國賽的郭X愷、葉X揚、陳X宏、鄭x軒 都南一中的\n還有因為 SCIST 而認識新化高中的 Eason 跟 Silv 他們都有得佳作\n我看到些人就會覺得我自己超級弱\n我本身實力與其他選手相比實在差太多了\n最後雖然跟 silv 一樣都是解出 4 題 但他有佳作我卻沒有 \n我認為可能真的是被主辦方說的上傳線上評測的時間影響到成績\n或是他有解到第一題會多一分 或是我最後花的時間確實比較多\n心裡其實滿沮喪的 一直在想為什麼會這樣 也一直很想抱怨主辦方\n但又覺得我實力比不上別人 好像也沒什麼資格抱怨的\n總而言之 見識到有那麼多人都比我更厲害而且比我更努力\n我會多多練題 持續精進自己\n\n---\n\n## 11/03 更新 我得佳作了？！\n廢話不多說 直接附上得獎名單\n![IMG_3129.jpeg](https://hackmd.io/_uploads/Hkmanuf76.jpg)\n明明現場沒喊到我的名字\n今天公布的得獎名單裡佳作竟然有我？？？\n心中滿滿問號與懷疑\n不過後來猜測是因為主辦方重新整理過分數與解題時間\n調整了名次 讓我成功獲得佳作\n心情慢慢轉變為喜悅\n我把這次的成績視為對自己的一種肯定\n作為我之後的動力\n\n高二的一堆比賽 讓我心裡也不知道該怎麼平衡課業與競賽\n一直在擔心如果把時間花在比賽 卻沒有比出成績的話怎麼辦\n我的段考分數也因為社團與競賽 相比高一真的變差太多了\n高一時校排前 10 % 還以為自己可以靠繁星升學\n接觸程式競賽後感覺打臉了自己\n身邊的同學也一直在問為什麼我成績變得不好\n但我真的無法解釋 只能做好我該做的事 做我想做的事\n希望我能漸漸學會如何分配我自己的時間\n我相信我能越來越好的\n\n## 特別感謝\nYudong 每次比賽的搭檔 沒有你我也不會有佳作 \n感謝你常常陪我打線上程式競賽到半夜 每天討論程式題目怎麼解 \n我們都在共同進步 希望這一年可以一起把社團經營好\n最後也謝謝賽前給我加油打氣的老師與同學朋友們\n\n\n## 延伸閱讀\n[競賽心得 @Yudong](https://yudong-0222.github.io/post/NHSPC112)\n[競賽心得 @tw20000807](https://hackmd.io/@tw20000807/2023south_contest)\n\n---\n\n{% btn '/post/Sitemap/',回到導覽頁面,far fa-hand-point-right,blue block center larger %}\n\n---","tags":["C++","資訊競賽","競程","題解"],"categories":["心得","競賽"]},{"title":"排序演算法 Sort Algorithm","url":"/post/Sort-Algorithm/","content":"\n> 本篇文章連結：https://4yu.dev/post/Sort-Algorithm/\n> 公開發布日期：2023/02/25\n\n---\n\n# 本文架構\n\n## 線性排序演算法種類\n\n1. 氣泡排序 Bubble Sort\n2. 選擇排序 Selection Sort\n3. 插入排序 Insertion Sort\n4. 快速排序 Quick Sort\n5. 合併排序 Merge Sort\n6. 堆排序 Heap Sort\n7. 希爾排序 Shell Sort\n8. 計數排序 Counting Sort\n9. 桶排序 Bucket Sort\n10. 基數排序 Radix Sort\n\n## 每個排序演算法的內容\n\n- 排序介紹\n- 動畫演示\n- 實作步驟\n- C++ 程式碼\n- 注意事項\n- 時間複雜度\n- 總結\n\n## 測試模板\n\n本文介紹的 10 種排序演算法都會附上寫好的函式，這裡提供可 EOF 輸入的測試模版，請在區塊中加上各種排序演算法函式，若沒有指定呼叫方法則直接呼叫函式名稱即可運作\n\n```cpp=\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> v;\n\n// 可以將底下的某個排序演算法函式複製起來放進來這個區塊\n// ----------------------------------------------\n\n\n\n\n\n// ----------------------------------------------\n\nint main(void)\n{\n    int n;\n    while (cin >> n) v.emplace_back(n);\n\n    // 這行放入某個排序演算法函式名稱用來呼叫 例如：BubbleSort();\n    // ------------------------------------------\n\n    // ------------------------------------------\n    \n    for (auto &i : v) cout << v[i] << \" \";\n    return 0;\n}\n```\n\n---\n\n# 排序演算法的詳細介紹\n\n## 氣泡排序 Bubble Sort\n\n氣泡排序是一種簡單的排序演算法，原理是依序比較相鄰的兩個元素，如果前一個元素大於後一個元素，就交換它們的位置，重複進行直到排序完成。\n因為排序過程中較大的元素會像氣泡一樣慢慢浮到數列的右端，所以叫氣泡排序。\n\n### 動畫演示\n\n![BubbleSort 動畫演示](https://hackmd.io/_uploads/HJMv3OadT.gif)\n\n### 實作步驟\n\n1. 外層 for 迴圈控制待排序的數量，每一輪會減少一個，直到排序完成\n2. 內層 for 迴圈表示每輪需要比較的次數\n3. 如果前一個數大於後一個數，則使用 swap() 交換\n\n### C++ Code\n\n```cpp=\nvoid BubbleSort()\n{\n    int n = v.size();\n    for (int i=n; i>1; --i)\n    {\n        for (int j=0; j<i-1; ++j)\n        {\n            if (v[j] > v[j+1]) \n            {\n                swap(v[j],v[j+1]);\n            }\n        }\n    }\n}\n```\n\n### 優化\n\n如果某輪沒有發生交換，就代表數列已經排好了可以提前結束，這樣可以減少後面發生不必要的比較\n\n### C++ Code\n\n```cpp=\nvoid BubbleSort()\n{\n    int n = v.size();\n    for (int i=n; i>1; --i)\n    {\n        bool check = false;\n        for (int j=0; j<i-1; ++j)\n        {\n            if (v[j] > v[j+1]) \n            {\n                swap(v[j],v[j+1]);\n                check = true;\n            }\n        }\n        if (!check) break;\n    }\n}\n```\n\n\n### 時間複雜度\n\n- 時間複雜度：$O(n^2)$\n    > 每一輪排序都需要進行 $n-i$ 次比較，而最多需要進行 $n-1$ 輪排序。\n    > 因此，總的比較次數為 $(n-1)+(n-2)+...+2+1=(n^2-n)/2$ \n    > 取最高次項所以時間複雜度為 $O(n^2)$\n\n\n### 總結\n\n氣泡排序演算法是一種簡單但效率較低的排序演算法，通常只適用於小規模資料的排序。\n\n## 選擇排序 Selection Sort\n\n選擇排序是一種簡單的排序演算法，它的原理是選擇最小的元素，與第一個元素交換位置，然後在剩下的元素中選擇最小的元素，與第二個元素交換位置，以此類推，重複直到排序完成。\n\n### 動畫演示\n\n![Selection Sort 動畫演示](https://i.imgur.com/VGRenb7.gif)\n\n### 實作步驟\n\n1. 外層 for 迴圈遍歷 $0 \\to n-1$ 個元素\n2. 每輪設最小值為第 $i$ 個元素\n3. 內層迴圈從 $i$ 開始往後遍歷到底，更新最小值位置\n5. 交換第 $i$ 個元素與最小值\n\n### C++ Code\n\n```cpp\nvoid SelectionSort()\n{\n    int n = v.size();\n    for (int i=0; i<n-1;++i)\n    {\n        int mini = i;\n        for (int j=i; j<n; ++j)\n        {\n            if (v[j] < v[mini])\n            {\n                mini = j;   \n            }\n        }\n        swap(v[i], v[mini]);\n    }\n}\n```\n\n### 時間複雜度\n\n- 時間複雜度：$O(n^2)$\n    > 選擇排序的核心操作是選擇最小元素，將其與當前位置交換，而選擇最小元素需要在未排序的序列中進行線性搜索，因此需要執行 $n$ 次循環和 $n$ 次內層循環，時間複雜度為 $O(n^2)$。\n\n### 總結\n\n選擇排序演算法是一種簡單但效率較低的排序演算法，通常只適用於小規模資料的排序，且較不穩定，如當元素相等時，彼此順序還是會改變。\n\n## 插入排序 Insertion Sort\n\n將未排序的資料依次插入已排序序列中，形成新的已排序序列。\n\n### 動畫演示\n\n![Insertion Sort 動畫演示](https://i.imgur.com/5F2355M.gif)\n\n### 實作步驟\n\n1. for 遍歷 $1 \\to n-1$ 個元素 \n2. 暫時取出 $v[i]$ 為待插入元素 設 $j$ 為插入點 初始為 $i-1$\n3. 用 while 迴圈開始由後往前掃描 確認在範圍內且待插入元素小於掃到的元素\n4. 把掃過的元素往後面搬 且 $j$ 遞減\n5. 若碰到最前面了或是遇到比待插入元素還要大的就退出 while 迴圈\n6. 將 插入點 設為待插入元素 $v[i]$ \n\n### C++ Code\n\n```cpp=\nvoid InsertSort()\n{\n    int n = v.size();\n    for (int i=1; i<n;++i)\n    {\n        int temp = v[i], j = i-1;\n        while (j >= 0 && temp < v[j])\n        {\n            v[j+1] = v[j];\n            j--;\n        }\n        v[j+1] = temp;\n    }\n}\n```\n\n### 注意事項\n\n- while 迴圈條件要設定邊界，插入點須 $\\ge 0$。\n\n### 時間複雜度\n\n- 時間複雜度：$O(n^2)$\n    > 要遍歷 $n-1$ 個元素，每次要往前掃瞄並搬動元素\n\n### 總結\n\n插入排序演算法是一種簡單但效率較低的排序演算法，通常只適用於小規模資料的排序。\n\n## 合併排序 Merge Sort\n\n合併排序 Merge Sort 是一種基於分治法的排序演算法，也是一種比較經典且常用的排序演算法之一。\n\n合併排序的主要流程包括分解、排序和合併三個步驟。\n首先將要排序的序列分成兩部分，分別對這兩部分進行排序，最後將排好序的兩個部分合併起來即可得到排序後的序列。\n在排序的過程中，通過遞歸地將序列分解成小問題，再利用合併操作將小問題的解合併成原問題的解。\n\n### 動畫演示\n\n![Merge Sort 動畫演示](https://i.imgur.com/cGkLdI8.gif)\n\n### 實作步驟\n\n1. 定義 MergeSort() 將 l、r 作為參數\n2. 算出 mid 拆成兩半 當 l == r 代表已排好可以返回，否則分別遞迴做拆分\n3. 呼叫 merge() 帶入 l,r 將 [l,r] 區間中兩個已排序的數列合併成一個已排序的數列\n4. merge() 先算出 mid 以及建立一個暫存的數列，長度設為合併後的數列長度\n5. for 用兩個指針分別從 l 和 mid 開始遍歷，哪個較小就先放入暫存數列中（注意邊界）\n6. 將排序好的暫存數列全部更新至原數列中\n\n### C++ Code\n\n呼叫時請用 `MergeSort(0, v.size());`\n```cpp\nvoid merge(int l, int r)\n{\n    int mid = (l+r)/2, tmp[r-l+1];\n    for(int i=l, j=mid+1, k=0; i<=mid || j<=r; ++k)\n    {\n        if((v[i] <= v[j] && i <= mid) || j > r) tmp[k] = v[i++];\n        else tmp[k] = v[j++];\n    }\n    for(int i=l, j=0; i<=r; ++i, ++j) v[i] = tmp[j];\n}\n\nvoid MergeSort(int l, int r)\n{\n    if(l == r) return;\n    int mid = (l+r)/2;\n    MergeSort(l, mid); MergeSort(mid+1, r);\n    merge(l, r);\n}\n```\n\n### 注意事項\n\n- 注意邊界 在 $merge()$ 中 確保 $i,j$ 兩指針不會跑出兩數列\n- 注意分割遞迴終止條件 是 `l == r`\n- `tmp` 的長度是 $r-l+1$\n- for 的 $k$ 從 $0$ 開始 取左時 `++i` 取右時 `++j`\n- 比大小時注意要多加上邊界條件 且若右數列取完了就直接取左列元素\n- 最後要把暫存元素更新到原數列中時 注意初始位置\n\n### 時間＆空間複雜度\n\n- 平均時間複雜度：$O(n\\log n)$\n    > 在平均情況下，合併排序的時間複雜度為 $O(n\\log n)$。這是因為在合併排序的過程中，每個元素都需要進行一次比較，而且每個元素都需要被移動到新數組中的正確位置，這樣每個元素都需要進行 $\\log n$ 級別的操作。\n\n- 空間複雜度：$O(n)$\n    > 合併排序需要額外的空間來存儲排序過程中的元素，這些儲存空間的大小與待排序數列的大小相同。\n\n### 總結\n\n合併排序是一種高效穩定的排序算法，通過分治的思想，先拆分問題再合併解決。其時間複雜度為 $O(n \\log n)$，在處理大量資料時表現良好。在實作時需要注意指針的起始值、合併區間的邊界問題等細節。\n\n## 快速排序 Quick Sort\n\n快速排序 Quick Sort 是一種常見的分治演算法，被認為是最快的排序演算法之一。\n它是選擇一個基準元素（通常是中間點），通過一趟排序將待排序列分為兩部分，\n其中一部分的所有元素都比基準元素小，另一部分的所有元素都比基準元素大，\n然後再按照此方法對這兩部分分別進行快速排序，直到整個序列有序。\n\n### 動畫演示\n\n本動畫以左邊當基準點\n![Quick Sort 動畫演示](https://i.imgur.com/0WcpwyB.gif)\n\n### 實作步驟\n\n1. 選擇中間點為基準點元素 pivot\n2. 找到左邊大於等於基準點的元素以及右邊小於等於基準點的元素\n3. 如果左邊大於等於右邊，交換它們\n4. 遞迴排序左半部分以及右半部分\n\n### C++ Code\n\n呼叫時請用 `QuickSort(0, v.size());`\n\n```cpp\nvoid QuickSort(int l, int r) \n{\n    if (l >= r) return;\n    int i = l, j = r, pivot = v[(l + r) / 2];\n    while (i <= j) \n    {\n        while (v[i] < pivot) i++;\n        while (v[j] > pivot) j--;\n        if (i <= j) \n        {\n            swap(v[i], v[j]);\n            i++; j--;\n        }\n    }\n    QuickSort(l, j); QuickSort(i, r);\n}\n```\n\n### 時間複雜度\n\n\n- 平均時間複雜度：$O(n\\log n)$\n\n    > 在平均情況下，每次切分都能將數列分為近似相等的兩個子數列，快速排序的時間複雜度為 $O(n\\log n)$。\n    > \n- 最壞時間複雜度：$O(n^2)$\n\n    > 當數列已經排好序或接近排好序時，選擇第一個或最後一個元素作為基準元素，時間複雜度會退化為 $O(n^2)$。\n\n### 注意事項\n\n- 需要注意邊界條件，例如遞迴結束的條件。\n- 快速排序是一個不穩定的排序演算法，相同元素的相對位置可能會在排序後發生變化。\n- 在選擇 pivot 時，可以選擇任意一個元素作為 pivot，但選擇哪個 pivot 會影響到排序的效率。如果每次都選擇最小或最大的元素作為 pivot，就會導致最壞情況下的時間複雜度從 $O(n\\log n)$ 暴增為 $O(n^2)$。因此，為了避免這種情況，可以選擇隨機的 pivot，通常選擇數列的中間元素作為 pivot，這樣可以確保每次排序的平均時間複雜度都是 $O(n\\log n)$。\n\n### 總結\n\n快速排序演算法是透過分治，達成高效率的排序演算法。它可以在短時間內對大型資料進行排序。儘管最壞情況下的時間複雜度較高，但在大多數情況下，它的表現都很優秀。\n\n## 堆積排序 Heap Sort\n\n堆積排序 Heap Sort 是一種使用二元樹 Binary Tree 資料結構的排序演算法。\n\n堆可以看作是一個完全二元樹，它具有以下兩個性質：\n\n1. 父節點的值永遠大於或等於（小於或等於）子節點的值。\n2. 堆中任意節點的子樹都符合上述特點。\n\n### 實作步驟\n\n1. 建立堆：將待排序的數列轉換成一個堆。這一步可以通過從最後一個非葉子節點開始，對每個節點進行調整來實現。具體來說，對於一個父節點，如果它的子節點的值比它的值大（或小），就交換它們，直到子樹也是一個堆，調整完成後就得到了一個初始的大根堆。\n2. 排序：從堆的尾部開始，每次取出堆頂元素與堆尾元素交換位置。交換後，堆的長度減1，重複此操作直到堆的大小為1，由於每次都是取出堆頂元素，所以得到的數列就是有序的，以保證元素依然構成一個大根堆。\n\n### C++ Code\n\n```cpp\nvoid heapify(int n, int i) \n{\n    int mx = i; // 初始化最大值為根節點\n    int lt = 2 * i + 1; // 找到左子節點的索引\n    int rt = 2 * i + 2; // 找到右子節點的索引\n    if (lt < n && v[lt] > v[mx]) // 如果左子節點的值比最大值還要大\n    { \n        mx = lt; // 更新最大值的索引為左子節點的索引\n    }\n    if (rt < n && v[rt] > v[mx]) // 如果右子節點的值比最大值還要大\n    { \n        mx = rt; // 更新最大值的索引為右子節點的索引\n    }\n    if (mx != i) // 如果最大值不是根節點\n    { \n        swap(v[i], v[mx]); // 把最大值交換到根節點\n        heapify(n, mx); // 遞迴對以最大值為根的子樹進行heapify操作\n    }\n}\n\nvoid HeapSort() \n{\n    int n = v.size();\n    for (int i = n / 2 - 1; i >= 0; i--) // 建立最大堆\n    { \n        heapify(n, i);\n    }\n    for (int i = n - 1; i > 0; i--) // 進行堆排序\n    { \n        swap(v[0], v[i]); // 把最大值與根節點交換\n        heapify(i, 0); // 對剩餘元素進行 heapify 操作\n    }\n}\n```\n\n### 時間＆空間複雜度\n\n- 時間複雜度：$O(nlogn)$\n    \n    > 在堆積排序中，排序的主要操作是下潛，即將堆頂元素下潛到合適的位置，這個操作的時間複雜度是 O(logn)。在排序過程中，需要執行 n 次下潛操作，因此排序的時間複雜度為 $O(nlogn)$。\n    > \n- 空間複雜度：$O(1)$\n    \n    > 由於堆積排序是一種原地排序算法，因此它的空間複雜度是 $O(1)$，即不需要額外的空間。在堆排序中，只需要用到常數個變量作為中間變量，不需要額外的數組或其他資料結構。\n    > \n\n### 注意事項\n\n1. 記得使用交換操作來實現堆的調整和排序。\n2. 調整堆的時候，要先找到子節點中的最大值，然後再和父節點比較，如果子節點的值比父節點大，就將子節點的值上移。\n3. 調整堆的時候，要特別注意邊界情況，例如在定位左右子節點的時候，要判斷右子節點是否存在。\n\n### 總結\n\n堆排序是一種高效的排序算法，它具有良好的時間複雜度和空間複雜度，並且它只需要一個輔助空間來存儲堆，可以實現原地排序，因此堆排序在排序大資料時非常有效。但是在實際應用中，由於堆排序的常數因子比較大，因此實際運行速度可能不如快速排序和插入排序等算法。\n\n## 希爾排序（Shell Sort）\n\n希爾排序（Shell Sort）是一種插入排序的改進版，其基本思想是先將待排序的序列按照一定間隔分成幾個子序列，然後對每個子序列進行插入排序。接著逐步縮小間隔，重複進行上述操作，直到間隔縮小到1時，最後對整個序列進行一次插入排序，完成排序。\n\n希爾排序的主要優點是在比較次數和移動次數上都有所改進，因為希爾排序採用分組的方式進行插入排序，每次排序可以使得一定程度上有序，因此在進行後面的排序時就可以利用前面排序時建立的有序性，減少比較次數和移動次數，此外希爾排序不需要額外的儲存空間。\n\n### 實作步驟\n\n1. 首先選擇一個增量序列，這個序列的選擇可以影響希爾排序的效率。\n2. 將待排序的序列按照增量序列分成幾個子序列，對每個子序列進行插入排序。\n3. 逐步縮小增量序列，重複上述操作，直到增量為 1 時，最後對整個序列進行一次插入排序，完成排序。\n\n### C++ Code\n\n```cpp\nvoid ShellSort() \n{\n    int n = v.size();\n    // 初始化增量 gap，設為 n/2、n/4、n/8、...直到 1\n    for (int gap = n / 2; gap > 0; gap /= 2) \n    {\n        // 以 gap 為間隔，對每個子序列進行插入排序\n        for (int i = gap; i < n; i++) \n        {\n            int temp = v[i], j;\n            for (j = i; j >= gap && v[j - gap] > temp; j -= gap) \n            {\n                v[j] = v[j - gap];\n            }\n            v[j] = temp;\n        }\n    }\n}\n```\n\n### 時間＆空間複雜度\n\n- 時間複雜度：\n    \n    > 希爾排序的時間複雜度取決於子序列的間隔序列（Increment sequence），一般會使用 Hibbard 增量序列（Hibbard's increment sequence），其公式為：$h_k = 2^k - 1$，其中 k 為子序列的索引，h_k 為對應的增量。\n    > \n    - 平均時間複雜度：$O(n(logn)^2)$\n    - 最壞時間複雜度：$O(n(logn)^2)$\n    - 最佳時間複雜度：$O(n)$\n- 空間複雜度：$O(1)$\n    \n    > 希爾排序是一種原地排序算法，只需要一個輔助變量來進行元素交換，因此空間複雜度為 $O(1)$\n\n### 注意事項\n\n1. 在實際應用中，希爾排序的實現需要根據具體情況進行優化，選擇合適的增量序列，以及在實現中注意避免不必要的交換和比較操作，從而提高排序的效率。\n2. 增量序列的選擇很重要，通常建議使用 Shell 提出的增量序列（1, 4, 13, 40, ...），但也可以根據具體情況進行調整。\n3. 插入排序可以使用直接插入排序或折半插入排序，具體選擇哪種排序算法可以根據實際情況進行選擇。\n4. 希爾排序的實現比較複雜，需要較好的理解和熟練的實現技巧。此外，在某些特殊情況下，希爾排序的效率可能會比其他排序算法低，因此在實際應用中需要仔細選擇排序算法。\n\n### 總結\n\n希爾排序是一種高效的排序算法，它通常比傳統的插入排序要快很多，特別是對於大型資料集。希爾排序采用分組的方式進行插入排序，每次排序可以使得一定程度上有序，因此在進行後面的排序時就可以利用前面排序時建立的有序性，減少比較次數和移動次數。\n\n## 計數排序（Counting Sort）\n\n計數排序（Counting Sort）是一種線性時間的排序算法，它可以用於排序一定範圍內的整數。計數排序的核心思想是先統計每個元素出現的次數，然後根據元素出現的次數，將元素排列成有序序列。\n\n### 動畫演示\n\n![計數排序動畫演示](https://i.imgur.com/5iGCVc1.gif)\n\n### 實作步驟\n\n1. 計算待排序數組中每個元素出現的次數。假設待排序的元素範圍為 [0, k]，則可以創建一個長度為 k+1 的計數數組，對於每個出現的元素值，在計數數組中相應的位置上加一。\n2. 對計數數組進行遍歷，依次累加前面所有元素的值，得到每個元素在有序序列中的位置。從計數數組的第二個元素開始，依次將前一個元素的值加到當前元素上，最終得到一個每個元素在有序序列中的位置的累加數組。\n3. 根據計數數組和有序序列的位置信息，將元素依次放入有序序列中。從原數組末尾開始，對每個元素值，從累加數組中取得對應的位置，把該元素放入有序序列中的該位置。每放入一個元素，該位置在累加數組中的值就需要減一。\n4. 將有序序列返回到原數組中。\n\n### C++ Code\n\n```cpp\nvoid CountingSort() \n{\n    int n = v.size();\n    int max_val = 100;  // 假設元素的範圍為[0,100]\n\n    // 計算元素出現的次數，初始化計數數組為0\n    vector<int> count(max_val + 1, 0);\n    for (int i = 0; i < n; i++) \n    {\n        count[v[i]]++;  // 計算v[i]出現的次數\n    }\n\n    // 累加前面所有元素的值，得到每個元素在有序序列中的位置\n    for (int i = 1; i <= max_val; i++) \n    {\n        count[i] += count[i - 1];  // 累加前面所有元素的值\n    }\n\n    // 根據計數數組和有序序列的位置信息，將元素依次放入有序序列中\n    vector<int> result(n, 0);\n    for (int i = n - 1; i >= 0; i--) \n    {\n        result[count[v[i]] - 1] = v[i];  // 將v[i]放到有序序列的對應位置上\n        count[v[i]]--;  // 將計數數組中對應元素的值減1\n    }\n\n    // 將結果返回到原數組中\n    for (int i = 0; i < n; i++) \n    {\n        v[i] = result[i];\n    }\n}\n```\n\n### 注意事項\n\n- 計數排序只適用於元素範圍較小的情況。如果元素範圍過大，則需要創建過大的計數數組，進而影響排序的效率和空間複雜度。\n- 計數排序是一種穩定的排序演算法。如果待排序數組中有相等的元素，排序後相等元素的相對位置不會改變。\n- 計數排序對於浮點數和負整數排序的支援不好。\n\n### 時間＆空間複雜度\n\n- 時間複雜度：$O(n+k)$\n    \n    > 計數排序的時間複雜度可以分為兩部分：計數過程和排序過程。首先是計數過程，需要對整個序列進行一次遍歷，把每個元素出現的次數記錄在計數數組中。由於計數數組的大小等於待排序序列的範圍，因此計數過程的時間複雜度為 $O(n+k)$，其中 n 是序列的長度，k 是序列中元素的範圍。接下來是排序過程，需要遍歷待排序序列，根據計數數組中的信息將每個元素放置到排序好的位置上。由於只需要遍歷一次待排序序列，因此排序過程的時間複雜度為 $O(n)$。因此，計數排序的時間複雜度為 $O(n+k)$，其中 n 為待排序元素的數量，k 為待排序元素的最大值。需要注意的是，當範圍 k 比較大時，計數排序的效率可能會比較低。\n- 空間複雜度：$O(k)$\n    \n    > 計數排序的空間複雜度主要取決於計數數組的大小 k。因此，計數排序的空間複雜度為 O(k)。需要注意的是，當範圍 k 比較大時，計數排序的空間複雜度也會相應增加。\n\n### 總結\n\n計數排序是一種高效的排序算法，適用於元素範圍較小的場景，在各種應用中都有著廣泛的應用，例如對於年齡、成績等數值型資料的排序。\n\n儘管它的時間複雜度比其他常用排序算法（如快速排序和合併排序）更小，但是它的應用受到了很大的限制，因為它需要在內存中創建一個大小為k的計數數組，如果k太大，計數數組將占用大量內存。此外，計數排序也不適用於具有負值元素的數組。\n\n## 桶排序（Bucket Sort）\n\n桶排序（Bucket Sort）是一種非常簡單的排序演算法，它的基本思想是將要排序的資料分為幾個桶，每個桶裡的資料都有一定的範圍。然後，對每個桶中的資料進行排序，最後按照桶的順序將所有桶中的資料合併起來。\n\n### 實作步驟\n\n1. 建立一個 vector 來儲存待排序數列。\n2. 找出數列中的最大值和最小值，並算出每個桶的範圍。\n3. 建立桶(bucket)的數量，這裡以 10 個桶作為範例，並建立一個 vector，裡面包含了 10 個子 vector，分別代表每個桶的元素。\n4. 將資料分配到對應的桶中，具體的方法是透過取整和乘法來判斷資料應該放在哪個桶中。\n5. 對每個桶中的資料進行排序，可以使用 std::sort 函式。\n6. 將排序後的資料依次放回原數組中。\n\n### C++ Code\n\n```cpp\nvoid bucketSort() \n{\n    int n = v.size();\n\n    // 建立桶（bucket）的數量，這裡以 10 個桶作為範例\n    const int bucket_num = 10;\n    vector<vector<int>> buckets(bucket_num);\n\n    // 將資料分配到對應的桶中\n    for (int i = 0; i < n; i++) \n    {\n        int index = v[i] / bucket_num;\n        buckets[index].push_back(v[i]);\n    }\n\n    // 對每個桶中的資料進行排序\n    for (int i = 0; i < bucket_num; i++) \n    {\n        sort(buckets[i].begin(), buckets[i].end());\n    }\n\n    // 將排序後的資料依次放回原數組中\n    int k = 0;\n    for (int i = 0; i < bucket_num; i++) \n    {\n        for (int j = 0; j < buckets[i].size(); j++)\n        {\n            v[k] = buckets[i][j];\n            k++;\n        }\n    }\n}\n```\n\n### 注意事項\n\n- 桶的大小設置：桶的大小應當選擇適中的值，太小會增加排序的時間複雜度，太大會佔用過多的空間。\n- 桶的數量：桶的數量應當根據資料的範圍和桶的大小進行設置。桶的數量不夠，會造成資料的堆積；桶的數量太多，會浪費空間。\n- 將資料分配到桶(bucket)中時，要注意取整和乘法的方法，避免產生錯誤。\n- 桶內部排序算法的選擇：桶內部的排序算法可以是任何一種穩定的排序算法，例如插入排序、冒泡排序等等。需要根據具體的應用場景選擇最優的算法。\n\n### 時間＆空間複雜度\n\n- 時間複雜度：$O(n+k)$\n    \n    > 計數排序的時間複雜度可以分為兩部分：計數過程和排序過程。首先是計數過程，需要對整個序列進行一次遍歷，把每個元素出現的次數記錄在計數數組中。由於計數數組的大小等於待排序序列的範圍，因此計數過程的時間複雜度為 $O(n+k)$，其中 n 是序列的長度，k 是序列中元素的範圍。接下來是排序過程，需要遍歷待排序序列，根據計數數組中的信息將每個元素放置到排序好的位置上。由於只需要遍歷一次待排序序列，因此排序過程的時間複雜度為 $O(n)$。因此，計數排序的時間複雜度為 $O(n+k)$，其中 n 為待排序元素的數量，k 為待排序元素的最大值。需要注意的是，當範圍 k 比較大時，計數排序的效率可能會比較低。\n- 空間複雜度：$O(n+k)$\n    \n    > 桶排序的空間複雜度取決於桶的數量和每個桶內部元素的個數。由於每個桶內部的元素個數都不超過n/k，因此每個桶所需的空間是 $O(n/k)$。總空間複雜度就是 $O(n + k)$。如果k接近n，則空間複雜度就會接近 $O(n)$。需要注意的是，當k比較大時，可能會出現空間浪費的情況，因此需要根據具體情況來選擇適當的桶數量。\n\n### 總結\n\n桶排序是一種簡單但有效的線性時間複雜度排序算法，優點是簡單易懂，而且比較容易實現。桶排序在資料分佈比較集中的情況下效果較好，但當資料分佈比較分散時，則會產生較多的桶(bucket)。適用於待排序資料分布範圍有限的情況。\n\n## 基數排序（Radix Sort）\n\n基數排序是一種非比較排序算法，適用於整數排序。基本思想是根據排序元素的位數，將整數按照位數從低到高或者從高到低進行排序，可以使用桶排序或計數排序等算法來實現。它的排序過程是先從最低有效位開始，依次對每一位進行排序，直到最高有效位。\n\n例如，將一個整數序列按照個位、十位、百位的順序來排序。首先，按照個位進行排序，將序列中所有數字根據個位數分成10個桶，分別把它們放進對應的桶中。然後，按照桶的順序把數字放回原序列中。接下來，再按照十位進行排序，以此類推，直到按照最高有效位進行排序為止。\n\n### 動畫演示\n\n![基數排序動畫演示](https://i.imgur.com/Gn1kHX9.gif)\n\n### 實作步驟\n\n1. 找出數組中最大的元素，確定最高位數，用變數 digit 記錄；\n2. 從最低位數開始，將數組中的元素按照該位數的值放入相應的桶子（桶子數量為 10，分別代表 0~9）中，並計算每個桶子中的元素個數；\n3. 計算每個桶子中元素在暫存陣列中的結束位置；\n4. 把元素按照桶子中的順序放入暫存陣列中；\n5. 把暫存陣列中的元素放回原陣列；\n6. 重複步驟 2~5 直到排序完成。\n\n### C++ Code\n\n```cpp\nvoid RadixSort() \n{\n    int max = *max_element(v.begin(), v.end()); // 找出最大值\n    int digit = 1;\n    vector<int> tmp(v.size()); // 建立暫存的 vector\n\n    while (max / digit > 0) \n    {\n        vector<int> count(10); // 計數排序用的計數陣列\n\n        // 計算每個桶子中的元素個數\n        for (int i = 0; i < v.size(); i++) \n        {\n            int bucket = (v[i] / digit) % 10;\n            count[bucket]++;\n        }\n\n        // 計算每個桶子中元素在暫存陣列中的結束位置\n        for (int i = 1; i < count.size(); i++) \n        {\n            count[i] += count[i-1];\n        }\n\n        // 把元素放入暫存陣列\n        for (int i = v.size() - 1; i >= 0; i--) \n        {\n            int bucket = (v[i] / digit) % 10;\n            tmp[count[bucket] - 1] = v[i];\n            count[bucket]--;\n        }\n\n        // 把暫存陣列中的元素放回原陣列\n        for (int i = 0; i < v.size(); i++) \n        {\n            v[i] = tmp[i];\n        }\n\n        digit *= 10; // 到下一個數位\n    }\n}\n```\n\n### 注意事項\n\n- 基數排序適用於位數相同的數列排序，如果位數不同，需將所有數字補齊至相同位數。\n- 每個位數的排序需要使用穩定排序算法，以保證相同位數上的數字相對位置不變。\n- 實作時需要用到桶來存儲數字，桶的數量與基數相同，這將需要額外的空間開銷。\n\n### 時間＆空間複雜度\n\n- 時間複雜度：$O(d(n+k))$\n    \n    > 其中 d 為最大位數，n 為數組大小，k 為桶子數量，通常為 10（代表數字 0~9）。因為每一位數都要進行一次計數排序，計數排序的時間複雜度為 $O(n+k)$，所以時間複雜度為 O(d(n+k))。\n- 空間複雜度：$O(n+k)$\n    \n    > 基數排序的空間複雜度主要由暫存陣列和計數陣列決定，因此空間複雜度為 $O(n+k)$。\n\n### 總結\n\n總結來說，基數排序是一種穩定性較好且時間複雜度為線性的排序算法，但對於數字位數較大的情況下，其空間複雜度較高，可能需要額外的存儲空間。基數排序的優點是能夠處理不同長度的數字，且在數字大小範圍有限的情況下，表現優於快速排序和堆排序。但是，它需要額外的空間儲存桶，且當數字大小範圍非常大時，需要大量的額外空間，並且其時間複雜度也會增加。\n\n# 排序演算法的分類\n\n## 比較排序 Comparison Sort\n\n- 交換類排序 Exchange Sort\n    - 氣泡排序\n    - 快速排序\n- 選擇類排序 Selection Sort\n    - 選擇排序\n    - 堆積排序\n- 插入類排序 Insertion Sort\n    - 插入排序\n    - 希爾排序\n- 合併類排序 Merge Sort\n    - 合併排序\n\n## 非比較排序 Non-Comparison Sort\n\n- 計數排序\n- 桶排序\n- 基數排序\n\n# 排序演算法的比較\n\n| 排序演算法 | 最差時間複雜度  | 平均時間複雜度  | 最佳時間複雜度  | 空間複雜度  | 方式      | 穩定度 |\n| ---------- | --------------- | --------------- | --------------- | ----------- | --------- | ------ |\n| 氣泡排序   | $O(n^2)$        | $\\theta(n^2)$        | $\\omega(n)$          | $O(1)$      | In-place  | ✅     |\n| 選擇排序   | $O(n^2)$        | $\\theta(n^2)$        | $\\omega(n^2)$        | $O(1)$      | In-place  | ❌     |\n| 插入排序   | $O(n^2)$        | $\\theta(n^2)$        | $\\omega(n)$          | $O(1)$      | In-place  | ✅     |\n| 合併排序   | $O(n\\log n)$    | $\\theta(n \\log n)$   | $\\omega(n\\log n)$    | $O(n)$      | Out-place | ✅     |\n| 快速排序   | $O(n^2)$        | $\\theta(n\\log n)$    | $\\omega(n\\log n)$    | $O(\\log n)$ | In-place  | ❌     |\n| 堆積排序   | $O(n\\log n)$    | $\\theta(n\\log n)$    | $\\omega(n\\log n)$    | $O(1)$      | In-place  | ❌     |\n| 希爾排序   | $O(n \\log^2 n)$ | $\\theta(n\\log n)$    | $\\omega(n \\log^2 n)$ | $O(1)$      | In-place  | ❌     |\n| 計數排序   | $O(n+k)$        | $\\theta(n+k)$        | $\\omega(n+k)$        | $O(k)$      | Out-place | ✅     |\n| 桶排序     | $O(n^2)$        | $\\theta(n+k)$        | $\\omega(n+k)$        | $O(n+k)$    | Out-place | ❌     |\n| 基數排序   | $O(n \\times k)$ | $\\theta(n \\times k)$ | $\\omega(n \\times k)$ | $O(n+k)$    | Out-place | ✅     |\n\n\n## 特點與優缺點\n\n| 排序演算法 | 主要特點 | 優點 | 缺點 |\n| --- | --- | --- | --- |\n| 氣泡排序 | 一種簡單的交換排序演算法，每次將相鄰的元素進行比較和交換 | 實現簡單，程式易懂 | 時間複雜度較高，效率低 |\n| 選擇排序 | 每次選出最小（大）的元素放到已排序序列的末尾 | 實現簡單，程式易懂，穩定 | 時間複雜度較高，效率低 |\n| 插入排序 | 將未排序元素逐個插入到已排序的序列中，從後往前比較 | 實現簡單，對小規模資料排序效率高 | 時間複雜度較高，對大規模資料排序效率較低 |\n| 合併排序 | 分治策略，將序列遞迴划分為子序列，然後將子序列合併 | 時間複雜度較低，效率較高，穩定 | 需要較大的輔助空間 |\n| 快速排序 | 分治策略，選定一個基準元素，將序列分為左右兩部分，遞迴排序 | 時間複雜度較低，效率較高，適用於大規模資料排序 | 不穩定，最壞情況下時間複雜度較高 |\n| 堆積排序 | 將序列構建成大根堆（小根堆），每次將堆頂元素與末尾元素交換，重新調整堆 | 時間複雜度較低，效率較高，適用於大規模資料排序 | 不穩定 |\n| 希爾排序 | 插入排序的改進版本，設定一個增量，將序列劃分為若干子序列進行排序 | 對於中等規模資料排序效率較高 | 不穩定 |\n| 計數排序 | 統計序列中各元素的出現次數，根據出現次數和元素值的關係排序 | 時間複雜度較低，適用於資料範圍較小的整數排序 | 對於資料範圍較大的情況需要較大的輔助空間 |\n| 桶排序 | 將元素劃分到不同的桶中，對每個桶中的元素進行排序，最後合併 | 適用於元素值分佈較均勻的情況，時間複雜度較低 | 對於元素值分佈不均勻的情況效率較低 |\n| 基數排序 | 按照元素的位數進行排序，從低位到高位進行排序，每一位使用穩定排序演算法進行排序 | 適用於大規模資料排序且穩定，可以處理多關鍵字排序 | 需要額外的記憶體空間且時間複雜度高，效率較低 |\n\n# 文章總結\n\n在本文中，我們介紹了 10 種常見的排序演算法，每種演算法都有其優點和缺點。\n在實際應用中，需要根據具體的情況選擇最適合的排序演算法。\n如果你想學習排序演算法，我建議利用本文章及網路上各種資源，理解各個演算法中的原理，並且嘗試自己實作出這些演算法。\n通過不斷的練習，你將能更深入地理解這些排序演算法的原理和應用，或許能夠應用來解決現實中的問題，希望此篇文章能讓你有所收穫！\n\n![All 排序動畫](https://i.imgur.com/rvpFvDt.gif)\n\n# 參考資料\n\n- [維基百科：排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)\n- [資料結構和演算法：排序演算法](https://www.csie.ntu.edu.tw/~b98902112/cpp_and_algo/index.html)\n- [菜鳥教程：排序算法](https://www.runoob.com/w3cnote/sort-algorithm-summary.html)\n- [排序算法動畫](https://www.toptal.com/developers/sorting-algorithms)\n- [Sorting Algorithm](https://www.freecodecamp.org/news/sorting-algorithms-explained-with-examples-in-python-java-and-c/)\n- [Sorting algorithms on GeeksforGeeks](https://www.geeksforgeeks.org/sorting-algorithms/?ref=lbp)\n- [15 Sorting Algorithms in 6 Minutes - YT](https://www.youtube.com/watch?v=kPRA0W1kECg)\n\n> 此篇文章因內容繁多，所以在整理資料及撰寫上，可能會有些錯誤，也請大家多留言或善用右側聊天室提出問題，我會馬上勘誤修正，謝謝。\n\n---\n\n{% btn '/post/Sitemap/',回到導覽頁面,far fa-hand-point-right,blue block center larger %}\n\n---","tags":["C++","實作","時間 & 空間複雜度","排序演算法 Sort Algorithm","氣泡排序 Bubble Sort","選擇排序 Selection Sort","插入排序 Insertion Sort","合併排序 Merge Sort","快速排序 Quick Sort","堆積排序 Heap Sort","希爾排序 Shell Sort","計數排序 Counting Sort","桶排序 Bucket Sort","基數排序 Radix Sort"],"categories":["筆記","DSA"]},{"title":"網站頁面導覽","url":"/post/Sitemap/","content":"\n# 歡迎來到 4yu Blog\n\n可自由探索整個網頁，也可依照以下導覽列表閱讀，每篇文章的最末端都可以導回此頁\n\n## 導覽\n\n1. {% btn /about/,點擊前往,fa-solid fa-hand-point-right,blue %} 自我介紹 About me \n2. {% btn /post/Hello-World/,點擊前往,fa-solid fa-hand-point-right,blue %} 第一篇文章 Hello, World. \n\n### DSA 系列\n皆以 C++ 為主，有很多篇都是學過但還沒整理成筆記的（其實就是懶），請耐心等待發布，歡迎使用右側聊天室催更某篇你有興趣的文章\n1. (修改中...即將發布) 複雜度分析（Complexity Analysis）\n2. {% btn /post/STL/,點擊前往,fa-solid fa-hand-point-right,blue %} C++ STL 大全\n3. (修改中...即將發布) 暴力＆枚舉演算法\n4. {% btn /post/Sort-Algorithm/,點擊前往,fa-solid fa-hand-point-right,blue %} 排序演算法（Sort Algorithm）\n5. (修改中...即將發布) 搜尋演算法：線性、二分搜、三分搜、Upper & Lower bound\n6. (修改中...即將發布) 圖論 I：基礎名詞、BFS & DFS\n7. (撰寫中...) Greedy：思想、證明、經典題\n8. (撰寫中...) DP 動態規劃 I：基本、背包、Kadane、LCS & LIS、bitmask\n9. {% btn /post/Data-Structures/,點擊前往,fa-solid fa-hand-point-right,blue %} 資料結構 進階實作（C++）\n10. (規劃中...) DP 動態規劃 II：區間 DP、樹 DP、DAG DP\n11. (規劃中...) DP 動態規劃 III：各種優化（滾動、單調性、分治、斜率、狀壓、四邊形）\n12. (規劃中...) 分治 I：逆序數對、(矩陣)快速冪、最近點對\n13. (規劃中...) 分治 II：CDQ、FFT/NTT、Master Theorem\n14. (規劃中...) 圖論 II：最小生成樹 MST、拓墣排序、最短路徑\n15. (規劃中...) 樹論：LCA、Tree DP、輕重鏈剖分\n16. (規劃中...) 圖論 III：聯通分量（SCC & BCC）、Tarjan、2-SAT\n17. (規劃中...) 圖論 IV：最大流＆最小割（Flow & Cut）、Dinic、二分匹配\n18. (規劃中...) 計算幾何：基本、凸包、掃描線、最近點對\n19. (規劃中...) 數論：質數篩、費馬小定理、歐拉定理、CRT、EGCD\n20. (規劃中...) 字串演算法：Manacher、Trie、KMP、Z-algorithm\n21. (規劃中...) 分塊 & 莫隊\n22. (規劃中...) 其他雜項技巧\n23. (規劃中...) 賽局理論\n24. (規劃中...) 計算複雜度類別：P/NP/NP-Hard/NP-Complete、歸約\n25. (規劃中...) 隨機算法、啟發算法、近似算法\n\n### AI 系列\n1. {% btn /post/AI/,點擊前往,fa-solid fa-hand-point-right,blue %} AI 概論與實作入門\n2. (撰寫中...) ML 演算法\n3. (修改中...即將發布) 梯度下降演算法\n4. (規劃中...) Optimizers\n5. (規劃中...) Loss Functions\n6. (規劃中...) Activity Functions\n7. {% btn /post/Neural-Network/,點擊前往,fa-solid fa-hand-point-right,blue %} 訓練神經網路計算過程\n8. (撰寫中...) DL Models\n9. (規劃中...) LoRA Fine-Tuning\n10. (規劃中...) RAG\n11. (撰寫中...) RL 專案分享\n\n### 量子計算 Quantum Computer 系列\n1. (持續撰寫補充中...) 量子計算概論 & IBM Qiskit 實作筆記\n2. (學習中...) 量子計算數學基礎\n3. (規劃中...) 量子演算法（Deutsch-Jozsa、Grover、Shor & Simon）\n4. (撰寫中...) QUBO 二進位二次式最佳化\n5. (撰寫中...) 量子退火演算法（Quantum Annealing）\n6. (規劃中...) QNN 量子機器學習\n\n### 其他待開發的系列\n以下是我除了程式以外的技能，但這些系列在我文章發佈的 priority_queue 最末端，可能需要等非常久之後才會開始撰寫。。。\n1. Figma\n2. Blender\n3. FL Studio\n\n### 心得系列\n文筆沒有很好，純粹紀錄當下心情，提供自己回顧\n1. {% btn /post/NHSPC/,點擊前往,fa-solid fa-hand-point-right,blue %} 資訊學科能力競賽 心得\n2. {% btn /post/NFIRC/,點擊前往,fa-solid fa-hand-point-right,blue %} NFIRC 南附資研社 - 從零開始的社團創辦與經營之路\n3. {% btn /post/SCIST-Camp-2024/,點擊前往,fa-solid fa-hand-point-right,blue %} SCIST Camp 2024 籌辦心得\n4. (補充照片中...即將發布) SCIST Camp 2025 籌辦 & 授課心得（過了一年還沒補完哈哈）\n5. (補充照片中...即將發布) FunAI Winter Camp 2024 & 2025 參與心得\n6. (修改中...即將發布) SCIST x NHDK 演算法培訓課程 季中季末賽 競賽出題心得\n7. {% btn /post/SPC-CSIE/,點擊前往,fa-solid fa-hand-point-right,blue %} 特殊選才資訊工程學系 心得彙整\n8. {% btn https://slides.com/shiyu/share,點擊前往,fa-solid fa-hand-point-right,blue %} 經驗分享演講 - 2025 南十校聯合迎新\n9. (撰寫中...) SCIST x SCAICT Camp 2026 聯合寒訓 - AI 系列課程 授課心得\n\n\n---\n\n## 網頁架構\n\n- {% hideToggle 本網頁組成架構 %}\n- 主頁 Home\n    - 網頁封面\n    - 側邊資訊欄\n    - 文章推薦\n- 文章 Posts\n    - 此網頁所有文章\n- 標籤 Tags\n    - 所有文章所提及的標籤、關鍵字\n- 分類 Categories\n    - 針對特定主題分類文章\n- 音樂\n    - 分享我的網易雲歌單\n- 連結 Link\n    - 聯繫資訊\n    - 友站\n    - SCIST\n    - Discord Server\n    - 學習資源\n    - 程式平台\n    - 軟體工具\n    - Blogs\n    - 相關技術\n- 關於\n    - 自我介紹\n    - 個人經歷\n{% endhideToggle %}\n\n# 感謝閱覽此網頁！\n\n---","tags":["網頁導覽 Site map"]},{"title":"Hello, World.","url":"/post/Hello-World/","content":"## 歡迎來到士育的部落格！\n\n### 網頁介紹\n\n此網頁使用了 [Hexo 靜態網頁框架](https://hexo.io/zh-tw/) \n\n部署在 [Github pages](https://pages.github.com/) 上\n\n我使用的 Theme 主題是 [Butterfly](https://butterfly.js.org/) \n\n創建日期為 2022/12/01（高一）版本使用 4.5.1（已在 2025/07/06 升級為 5.4.1）\n\n### 網頁用途\n\n這裡是我的程式筆記網頁\n\n內容包括資料結構與演算法、機器學習和量子計算等領域\n\n不會有程式語言基礎語法，因為網路上資源多且詳細\n\n筆記中的內容或許會有小錯誤或不完整，我會不斷的更新修改\n\n我也會不定期的發佈各種心得紀錄\n\n有興趣的人可以參閱其他文章或到上方其他頁面看看\n\n如果你對文章有任何想法或建議，歡迎在文章下方評論區登入 GitHub 帳號留言你的想法\n\n或是可以直接使用右下角的「線上聊天室功能」傳訊息給我，我會盡快回覆你的訊息\n\n若你想開始學程式，請到上方「link 連結」的頁面，我有放許多資源可以提供你學習\n\n提供的資源涵蓋各種程式語言的基礎語法以及各種程式相關平台與工具\n\n以及各大程式社群的 Discord 伺服器\n\n希望能對你有所幫助！\n\n### 本網站網址\n\n```\nhttps://4yu.dev\n```\n\n---\n\n{% btn '/post/Sitemap/',回到導覽頁面,far fa-hand-point-right,blue block center larger %}\n\n---"}]