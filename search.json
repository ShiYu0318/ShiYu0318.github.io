[{"title":"資工特選 - 成功大學","url":"/post/SPC-NCKU/","content":"\n\n# 待更新\n\n\n---\n\n## [點擊回到導覽頁面](https://4yu.dev/post/Sitemap/)\n\n---","tags":["資訊工程學系","特殊選才","成功大學"],"categories":["特殊選才"]},{"title":"資工特選 - 中興大學","url":"/post/SPC-NCHU/","content":"\n\n# 更新\n\n\n---\n\n## [點擊回到導覽頁面](https://4yu.dev/post/Sitemap/)\n\n---","tags":["資訊工程學系","特殊選才","中興大學"],"categories":["特殊選才"]},{"title":"資工特選 - 中央大學","url":"/post/SPC-NCU/","content":"\n# 人數\n- 錄取名額：3\n    - 一般組：2\n    - 資安組：1\n    - 採聯招方式\n- 符合報名資格人數：56\n- 過書審進面試人數：15\n# 時程\n- 簡章公告：09/20\n- 報名：10/04 ~ 10/09\n- 面試名單：10/22\n- 面試：10/29\n- 放榜：11/19\n\n\n\n\n\n\n# 面試前\n\n我早起從臺南趕高鐵去桃園，然後坐計程車到中央準時報到，門口滿壯觀的是一個上坡跟中央校徽\n![IMG_6325](https://hackmd.io/_uploads/rJof6MYSlg.jpg)\n\n面試地點在工程五館\n![IMG_6327](https://hackmd.io/_uploads/HJrd0zYSgg.jpg)\n\n\n我們先在二樓特選生休息室等待，冰川超社牛問其他人要不要加入 Discord 群\n\n\n![IMG_6329](https://hackmd.io/_uploads/S1mLJ7FSgg.jpg)\n\n\n由於那教室裡面網路超爛，所以我就出去走廊陽台透氣滑手機，wifecake 走過來跟我聊天（那時還不知道他是誰）\n面試順序是照書審分數由高到低排序的，我是第五位，前一個是 Eason，後一個是冰川，輪到我時有一個酷酷的學長帶上去三樓門口等待，他人超好一直跟我聊天，然後發現他也是臺南人，更巧的是他姐高中跟我同一間，另一個姐跟 Eason 同一間\n\n# 面試過程\n\n👨🏻‍🏫：教授（有五個，只有中間那個有講話）\n🤡：我\n\n（學長開門，Eason 走出來，我走進去跟教授打個招呼，然後開簡報）\n🤡：（介紹申請動機與家庭背景）\n🤡：（介紹檢定成績）\n👨🏻‍🏫：（打斷我介紹 直接開問）你是怎麼自學的\n🤡：（回答內容摘要：SCIST 線上資源、網路教材）\n👨🏻‍🏫：你為什麼會想考大學生在考的 CPE\n🤡：（回答內容摘要：檢驗自身程式能力、訓練英文閱讀能力，看看自己在大學生中的排名）（👨🏻‍🏫 轉過去對右邊的教授點頭微笑一下）\n（介紹程式競賽與資安領域的表現）\n👨🏻‍🏫：如何維持大學的學業\n🤡：（回答內容摘要：先修、時間管理）\n🤡：（介紹其他特殊經歷）\n👨🏻‍🏫：進大學後的研究方向\n🤡：（回答內容摘要：深度學習）\n🤡：（未來展望與結尾）\n🤡：請問教授還有問答環節嗎\n👩🏻‍🏫（最右邊的女教授）：因為時間滿久的剛剛問題有問完了\n\n\n中央原本公告：![image](https://hackmd.io/_uploads/SyHzL_ybkx.png)\n實際上：教授在自我介紹時打斷直接開問，中間因為還沒介紹完簡報我怕時間不夠用所以回答的沒有很完整就繼續介紹了，最後用了大概 10 分鐘左右\n\n# 面試後\n\n面試完後跟 冰川、Eason、隨風（Eason 的學長 之前的中央資工特選生）一起走去學校外面吃一間不錯的漢堡\n\n![IMG_6331](https://hackmd.io/_uploads/B1c-eXYrxl.jpg)\n\n\n路途一直飄雨感覺中央這地理位置真的很潮濕，後來還去咖啡廳，有聊到他們都沒有被打斷介紹直接問問題，他們覺得是教授是對內容有興趣才會打斷，但我覺得讓我在介紹完簡報後再提問我會回答的更好一點\n\n# 結果\n\n雖然中央資工分成兩組，但是因為採聯招方式，所以報名時可以兩組都選而且只要繳費一次，面試也是只要一次，放榜之後會依照志願序分配組別\n\n放榜結果：\n\n\n- 一般組：備取 1（正取 2 人、備取 7 人）遞補錄取\n- 資安組：正取（正取 1 人、備取 3 人）\n\n\n\n中央放榜之後，我心中放下一塊大石，因為第一間就正取了，後面幾間面試時我其實都沒什麼壓力了，個人認為中央資工教授比較喜歡有接觸 AI 的人（一般組正取兩個都是做 AI 專題的旺宏金牌）還有多方面發展的人，太專精在競程反而會給比較低分，因為教授可能已經覺得這人會錄取特別喜歡競程的清大（實例：今年跟去年都有是清大正取且進過 TOI 選訓營一階的人在中央是備取很後面或未錄取），不過我是沒特別專精在某個領域但有很多特殊經歷的，所以在這裡對我來說會比較有優勢，但在其他學校就不一定了\n\n\n---\n\n## [點擊回到導覽頁面](https://4yu.dev/post/Sitemap/)\n\n---","tags":["資訊工程學系","特殊選才","中央大學"],"categories":["特殊選才"]},{"title":"資工特選 - 清華大學","url":"/post/SPC-NTHU/","content":"\n\n# 待更新\n\n\n---\n\n## [點擊回到導覽頁面](https://4yu.dev/post/Sitemap/)\n\n---","tags":["資訊工程學系","特殊選才","清華大學"],"categories":["特殊選才"]},{"title":"資工特選 - 中山大學","url":"/post/SPC-NSYSU/","content":"\n\n# 待更新\n\n\n---\n\n## [點擊回到導覽頁面](https://4yu.dev/post/Sitemap/)\n\n---","tags":["資訊工程學系","特殊選才","中山大學"],"categories":["特殊選才"]},{"title":"資工特選 - 臺灣師範大學","url":"/post/SPC-NTNU/","content":"\n\n# 人數\n\n\n| 人數             | 一般組 | 資安組 |\n| ---------------- | ------ | ------ |\n| 報名人數         | 83     | 48     |\n| 過書審進面試人數 | 17     | 16     |\n| 錄取名額         | 5      | 3      |\n\n# 時程\n- 簡章公告：09/20\n- 報名：10/01 ~ 10/09\n- 面試名單：11/12\n- 面試：11/15\n- 放榜：12/05\n\n\n# 面試前\n\n臺師大把我這個臺南人排在第二個面試，我必須要超早起搭第一班高鐵才能趕得上，第一次在外面等高鐵站開門，還好有 Eason 陪我一起。之前一日資訊營我有來臺師大公館校區當助教所以路途有熟悉的感覺。\n\n![IMG_6469](https://hackmd.io/_uploads/HkDwr9qBel.jpg)\n\n\n\n# 面試過程\n\n臺師大的面試是最特別的，分為三間教室各一個教授，第一間是 3 分鐘自我介紹並要接受提問，第二間是專業問答，有幾個不同主題選兩個並回答問題，第三間是最輕鬆的聊天，有很多卡片可以選擇跟教授聊哪些主題，因為我一般組跟資安組都有進複試所以要面試兩輪\n\n\n## 第一輪面試\n\n### 第一間：自我介紹\n可使用簡報，我有準備也有在報到時用那邊的電腦上傳到他們給的資料夾，但不知道為什麼進到第一間面試時沒有同步過去導致我是沒有簡報直接講完的\n\n\n🤡：我\n👨🏻‍🏫：陳教授\n![image](https://hackmd.io/_uploads/SJ33EMUMyg.png)\n\n🤡：（自我介紹）\n👨🏻‍🏫：Supervised learning 跟 Unsupervised learning 的差別\n🤡：差別在於訓練時有沒有 Label，監督式學習資料與標籤之間的關係可以用來預測新資料，\n    非監督式學習是要找出資料之間隱藏的內部結構\n👨🏻‍🏫：你的強化學習專案是用什麼算法\n🤡：有用過 DQN 和 PPO\n👨🏻‍🏫：Loss Function 有什麼不同\n🤡：DQN 是透過最小化誤差來學習 Q 值，PPO 比較像是學習一個策略\n👨🏻‍🏫：有考英文檢定嗎\n🤡：目前正在準備多益\n\n\n聊到外面學長敲門才出去，問到的都有回答出來，感覺第一間自我介紹的提問比第二間專業問題的提問還要更專業，還有很多人說在第一間被全英文問答，教授口音又很重，他們感覺滿慌的，我最後一題回答完後剛好學長敲門我才沒被用英文問，後來去查臺師大教授名單找了才知道原來專長是機器學習還在國外留學過難怪會這樣\n\n### 第二間：專業問答\n\n\n\n🤡：我\n👨🏻‍🏫：紀教授\n![image](https://hackmd.io/_uploads/Bk09PfLf1g.png)\n\n🤡：（進去先簡單自我介紹了一分鐘）\n👨🏻‍🏫：螢幕上的主題選兩個，可以不用選資安，因為你這次面完要接著考筆試\n\n| | | |\n|---|---|---|\n| 演算法 | 資料結構 | 程式設計 |\n| ? | ? | ? |\n| 資訊安全 | 人工智慧 | ? |\n| X | 其他 | X |\n> 我忘記 ? 的是什麼了\n\n🤡：人工智慧 和 資料結構\n👨🏻‍🏫：解釋 圖靈測試\n🤡：由艾倫圖靈提出的思想實驗，目的是在測驗電腦能不能讓人類分辨不出來是在跟人還是電腦對話\n👨🏻‍🏫：解釋 K-NN\n🤡：K 近鄰算法，機器學習裡面預測一個新資料是哪個類別時，看看離它最近的 K 個資料是什麼類別來決定答案\n> 然後就開始聊我的強化學習專案技術細節：Reward Funtion 是如何設計之類的\n\n👨🏻‍🏫：好先換資料結構 解釋 stack 特性與應用\n🤡：特性是先進後出，像堆疊盤子一樣，先想到應用的是括號匹配的題目，還有維護單調隊列之類的\n👨🏻‍🏫：BST 最佳 / 最差情況 & 如何解決\n🤡：最佳情況的話 BST 是平衡的 O(log N)，最差會變成一條鏈 O(N)，解決方法就是用像 set 這種底層是紅黑樹之類的資料結構\n\n\n\n### 第三間：卡片閒聊\n\n\n🤡：我\n👨🏻‍🏫：蔣教授\n![image](https://hackmd.io/_uploads/BkFiVGIfkl.png)\n👨🏻‍🏫：應該知道第三關要做什麼吧\n🤡：有先上網看過別人心得，結果真的是卡片\n👨🏻‍🏫：四張主要卡片選幾張介紹自己：\n> 可複選所以我選擇全部都講一次\n1. 高中生活：描述高中生活\n🤡：高一開始考 APCS 並創了校內資訊社團，高二經營社團、到處打比賽、參與社群、擔任各種課程講師、高三擔任社群總召、準備特選，因為一直都有目標而且想持續進步所以過得滿精彩的\n1. 特殊之處：與其他特選生的不同之處\n🤡：除了刷題精進自己能力以外，還有創社、講課、投入社群等不同的多元表現\n1. 特殊選才：為何投入特殊選才、何時開始的、做了什麼準備\n🤡：因為有這些特殊經歷讓我想嘗試、高二暑假、調整心態和規劃未來\n1. 未來展望：希望進大學後成為一個怎樣的人\n🤡：成為自己想要的樣子，為了目標努力，充實自己大學生活的人\n\n\n👨🏻‍🏫：選 3 張卡片描述未來想做的事\n\n1. 社團領導\n2. 師資培育\n3. 學術研究\n4. 海外留學\n5. 程式競賽\n6. 企業培訓\n\n\n> 我其實也想每張都選，但最後選了 3 張能讓我結合自身經歷的\n1. 社團領導：對應我創社當社長和擔任社群總召的經歷\n2. 師資培育：對應擔任課程講師、助教的經歷\n3. 程式競賽：可以組隊打 ICPC 之類的競賽\n\n> 講完之後教授翻開卡片背面，每張背面都有台師大歷屆學生的相關成果，有點宣傳的效果\n\n\n整個過程滿輕鬆的，教授全程笑笑的，感覺真的是想透過卡片與聊天過程認識一個人的經歷與特質，我回答的時候有下意識地挑一些對我比較有優勢的地方特別提出來講，所以第一輪面試很順利也還滿有把握的\n\n## 資安組筆試\n\n資安組除了面試之外還有筆試，我甚至當天到現場才知道這件事，根本完全沒準備 🤡，而且時間超級緊迫，我第一輪面試完要馬上衝去別棟筆試完再回來面試第二輪\n\n### 一、程式設計\n1. ans = ?\n```c\n#include<stdio.h>\nint main(){\n    int ans=0;\n    for(int i=0,j=0;i<5;j+=(i++))\n        ans+=j;\n    printf(\"%d\",ans);\n}\n```\n2. ans = ?\n```c\n#include<stdio.h>\nint f(int x,int y){\n    return x | (1 <<y);\n}\nint main(){\n    int ans = f(2,7);\n    printf(\"%d\" , ans);\n}\n```\n3. 當輸入 50 時\n    - 為何會印出 50 0 0？\n    - 為何會印出stack smashing detected？\n```c\n#include<stdio.h>\nint main(){\n    int8_t a=10 ,b=23, c=44;\n    scanf(\"%d\",&a);\n    printf(\"%d%d%d\",&a,&b,&c);\n}\n```\n\n### 二、系統安全\n\n1. linux 檔案權限中的 s 是什麼意思？\n2. proc/version 為何佔用 0 byte\n3. 如果要將 test.pdf 隱藏起來，那該要怎麼去打 linux command\n\n### 三、網路\n\n1. ping 的原理\n2. 家中的ip分享器原理\n3. 為何網頁有時會顯示不安全，至少寫出3個原因\n\n### 四、密碼學\n\n1. 手算凱撒密碼（密文忘了）\n2. 在 1～124 中取一個數乘以 17，再除以 125 要餘 1，1～143 中與 143 互質的數有幾個\n3. 證明 16 bits 的 key 不安全\n\n\n> 感謝 yih 背出來的題目 Orz\n\n\n寫完之後回到原本那棟的地下一樓休息室等第二輪面試，遇到很多認識的人，大家一起聊天，OsGa 好兄弟剛好在台北還特別過來師大陪我們一起，也遇到了 Ricky，他想從臺科大重特到臺師大，詳細過程可以看 [這篇文章](https://ricky.place/posts/journey-ntust-to-ntnu-20250705/) 真心滿佩服他的勇氣的，然後因為第一間自我介紹我有準備簡報但用不了就去找行政人員問了一下，發現另一個女生也跟我遇到同樣問題一起來問，我覺得他滿眼熟的感覺是我當某一場課程講師教過的學員。後來我重新上傳了一次在第二輪終於有簡報可以用了\n\n## 第二輪面試\n\n### 第一間\n\n> 用簡報快速帶過第一輪介紹過的經歷，因為是資安組面試所以最後有詳細補充我在 AIS3 Junior 2024 拿到最佳專題獎的實作內容\n\n👨🏻‍🏫：LLaMA 是什麼\n\n> 他的反應讓我感覺不是要我解釋 LLM，而是他真的不知道有 LLaMA，直到我說類似 GPT 他才懂）\n\n👨🏻‍🏫：AI 想的漏洞攻擊方法有比人類更好、更快嗎，如果沒有的話，你們專案有 AI 跟沒 AI 有什麼差別\n> 顯然完全放錯重點，我們專案是模擬駭客利用購物網站上的 AI 客服助手透過 Prompt Injection 的方式攻擊網站漏洞，而不是讓 AI 想出攻擊方法，反正他一直重複問類似的問題，我不管回答什麼他都跳針到最後時間結束，感覺他自己不太接觸資安領域，所以隨便想了個問題來一直問，出去之後覺得心情滿差的\n\n\n### 第二間：專業問答\n\n教授看到我又來一次，就不考專業問題了，直接開始聊天\n\n👨🏻‍🏫：你覺得剛剛考資安筆試的題目如何\n> 因為這份題目是他出的\n👨🏻‍🏫：有什麼問題想問嗎\n🤡：我想問關於 APCS 改制的問題，因為看到網路上有消息透露 APCS 要改成類似英檢那樣分級的新制度，這是假消息還是已經確定了\n👨🏻‍🏫：你們消息傳好快，是有這件事不過我是不太清楚詳細內容，而且負責的教授現在人在國外。時間還很多還有想問的嗎\n🤡：那我想了解一下師資培育的一些細節\n👨🏻‍🏫：校內有指定要修師培的課，然後要考核通過才行，我自己也是負責師資培育的，看過外面很多不太合格的資訊老師，所以對臺師大的學生滿有信心的\n🤡：那臺師大有什麼資源可以先修或需要提前準備什麼事情\n👨🏻‍🏫：我有開 TouTube 頻道：[Neokent 的線上課程](https://www.youtube.com/channel/UC1EpSGnc7eX2Cr9XgBUQqIw) 可以去按讚訂閱分享開啟小鈴鐺。不然你之前是透過什麼資源學程式的\n🤡：之前學程式是參加 [SCIST 演算法培訓課程](https://www.youtube.com/c/OfficialSCIST) ，我現在擔任 S5 的總召\n👨🏻‍🏫：每年都會有 SCIST 的人上來這裡面試，印象滿深刻的\n\n\n### 第三間：專業問答\n\n> 教授看到我又來了就說不用翻卡牌了 直接開始閒聊\n👨🏻‍🏫：上面的教授都問了什麼\n👨🏻‍🏫：想問你們考生對目前 APCS 的看法\n👨🏻‍🏫：為什麼會想投資安組 還是想說順便投的\n🤡：雖然資安經歷比較沒有競程經歷多，但對資安和 AI 領域都有興趣\n> 教授看了桌上的表，上面有大家的主要經歷\n👨🏻‍🏫：你會兩組都進是因為有其他特殊經歷是別人沒有的所以加了不少分\n👨🏻‍🏫：你有 AIS3 最佳專題獎，今天很多人也都有，想知道為什麼\n🤡：除了不同年度之外，還分為 AIS3 和 AIS3 Junior，AIS3 有不同類別的主題，每個主題都有最佳專題獎，AIS3 Junior 則是只有前兩名有，所以今天才會有那麼多人有最佳專題獎。\n\n\n## 面試後\n\n面試後跟一群人（OsGa、Ricky、yih、soar）一起去吃師大學餐，自助餐價格跟菜色都還算可以，但是餐廳滿熱的，吃完就跟 Eason 逛北車地下街，最後搭客運還差點趕不上，總之就是行程很趕很累的一天\n\n\n\n## 結果\n\n## 一般組：正取（正取 5 人、備取 9 人）\n## 資安組：未錄取（正取 3 人、備取 7 人）\n\n\n---\n\n## [點擊回到導覽頁面](https://4yu.dev/post/Sitemap/)\n\n---","tags":["資訊工程學系","特殊選才","臺灣師範大學"],"categories":["特殊選才"]},{"title":"SCIST x 南 15 校資訊社 2025 聯合寒訓 - 資深玩家 籌辦心得","url":"/post/SCIST-Winter-Camp-2025/","content":"\n\n# 待更新","tags":["南 15 校","資訊社","SCIST","寒訓","營隊"],"categories":["心得","營隊"]},{"title":"特殊選才資訊工程學系 心得彙整 by 4yu（114 級）","url":"/post/SPC-CSIE/","content":"\n# 前言\n\n我報名的校系全部都是資訊工程學系，以下是我特選前主要的經歷：\n\n- SCIST 南臺灣學生資訊社群 S5 總召 & 演算法助教\n- NFIRC 創辦人 & 社長 & 講師\n- APCS 4+4、CPE Professional 排名 176/2406 前 7.3 %\n- 高中學科能力競賽 資訊科 連續兩年複賽佳作\n- AIS3 Junior 2024 最佳專題獎\n- 南四校聯合社課 - AI 人工智慧主題 講師\n- 南九校資訊社 x 成大資工 x SCIST 2024 聯合寒訓 副召\n\n在報名之前有先透過 [114 特選群](https://discord.gg/RbHxzRAmWb) 裡的調查表單搜集到約 130 筆資工特選生的經歷，因為我屬於競程、資安、AI 各領域都有碰的那種，並且還有很大一部份時間是花在創立社團、擔任社群總召、當課程講師...這些經歷上，所以我的檢定競賽成績與其他專注在刷題的人相比較沒那麼有優勢，但比別人多了一些特殊表現，對比各校系名額後評估自己大概的落點會在中字輩左右，並且多報了台師大與海大當作保底學校。\n\n# 結果總表\n\n> 以面試日期排序\n\n| 學校 | 組別 | 報名人數 | 進複試 | 面試人數 | 錄取名額 | 錄取率 | 最終結果 | 備取人數 | 狀態 |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 中央大學 | 聯招（一般組） | 56 | ✅ | 15 | 2 | 3.57% | 🔵 備取 1 | 7 | 遞補錄取，已報到 |\n| 中央大學 | 聯招（資安組） | 56 | ✅ | 15 | 1 | 1.79% | 🟢 正取 | 3 | 已放棄 |\n| 臺灣師範大學 | 一般組 | 83 | ✅ | 17 | 5 | 6.02% | 🟢 正取 | 9 | 已放棄 |\n| 臺灣師範大學 | 資安組 | 48 | ✅ | 16 | 3 | 6.25% | 🔴 | 7 |  |\n| 成功大學 | 甲組（競程） | 28 | ✅ | 28 | 4 | 14.29% | 🔴 | 10 |  |\n| 中山大學 | 一般組 | 70 | ✅ | 22 | 3 | 4.29% | 🔵 備取 4 | 7 | 遞補錄取，已放棄 |\n| 中興大學 | 一般組 | 57 | ✅ | 8 | 1 | 1.75% | 🔵 備取 4 | 5 |  |\n| 海洋大學 | 一般組 |  | ✅ |  |  |  | 🔴 沒去面試 |  |  |\n| 中興大學 | 資安組 | 44 | ✅ | 19 | 3 | 6.82% | 🟢 正取 | 10 | 已放棄 |\n| 清華大學 | A 組（一般組） | 87 | ✅ | 26 | 6 | 6.90% | 🔴 |  |  |\n| 陽明交通大學 | 一般組 | 109 | ❌ | 32 | 10 | 9.17% | 🔴 |  |  |\n\n最後中字輩全上（中正大學近幾年特選沒開資工系），滿符合我當初預期的結果，也確定會就讀 **國立中央大學 資訊工程學系**\n\n# 各校面試過程\n\n| 學校 | 連結 |\n| --- | --- | \n| 中央大學 | [點擊前往](https://4yu.dev/post/SPC-NCU/) | \n| 臺灣師範大學 | [點擊前往](https://4yu.dev/post/SPC-NTNU/) |\n| 成功大學 | [點擊前往](https://4yu.dev/post/SPC-NCKU/) | \n| 中山大學 | [點擊前往](https://4yu.dev/post/SPC-NSYSU/) |\n| 中興大學 | [點擊前往](https://4yu.dev/post/SPC-NCHU/) |\n| 清華大學 | [點擊前往](https://4yu.dev/post/SPC-NTHU/) |\n\n# 特選心得\n\n> 待更新\n\n# 聯絡資訊\n\n有任何疑問或想瞭解更多關於資訊領域、特殊選才相關的事情，甚至是想邀請我去經驗分享的話都歡迎透過以下管道聯絡我：\n- Discord：`shiyu0318`\n- Instagram：`syprod4yu`\n- Email：`shiyu@scist.org`\n\n---\n\n## [點擊回到導覽頁面](https://4yu.dev/post/Sitemap/)\n\n---","tags":["資訊工程學系","特殊選才","中央大學","中山大學","中興大學","臺灣師範大學","清華大學","成功大學","海洋大學"],"categories":["特殊選才"]},{"title":"NFIRC 南附資研社 - 從零開始的社團經營之路","url":"/post/NFIRC/","content":"\n# [創社計畫](https://hackmd.io/@YuDong/ashsnutn_csirc)\n\n# 創社歷程、成果、心得與反思\n# 撰寫中 ...\n\n# [第一屆年報](https://online.fliphtml5.com/thcty/kwmf/)\n\n---\n\n## [點擊回到導覽頁面](https://4yu.dev/post/Sitemap/)\n\n---","tags":["南附資研社","NFIRC 1st"],"categories":["心得","社團"]},{"title":"南九校資訊社 x 成大資工 x SCIST 2024 聯合寒訓 - 資得其樂 籌辦心得","url":"/post/Winter-Camp-2024/","content":"\n\n\n# [寒訓詳細資訊](https://hackmd.io/@nine-southern-schools/Complete_information)\n\n![資得其樂 LOGO](https://hackmd.io/_uploads/rkoBua7sa.png)\n\n# 引言\n\n在 2023/11/25 這次的寒訓總召 碗蒸 私訊我問說要不要一起辦寒訓，但其實我們南附資研在 2023/11/13 幹部線上開會時就有討論到說寒假要辦營隊，本來沒想說要辦那麼大規模的寒訓，那時的規劃主要是開放給校內的所有學生和老師，大概會舉辦講座提供給校內對資訊領域有興趣的人，且主題訂為資訊領域的多元課程。\n後來思考過後決定接下本次寒訓副召，一開始的召群有南女的總召 碗蒸、一中的副召 KCC 還有我，加上 Fishhh、Eason 和 Curious 這三位 SCIST S4 的總召們協助，還有小白的加入也讓我們日後籌備更順利。\n\n![第一次開會](https://hackmd.io/_uploads/SJOQ63Hsp.png)\n\n# 籌備階段\n\n我們是先開了線上會議，確認好活動目的與受眾，排好 Deadline 後才開始籌備，一開始是要先招募工作人員，因為有茶碗蒸這個 SCIST 文書在，所以各種表單很快就做好了，而且他也有之前辦茶會迎新的經驗，所以初期還挺順利的，也在一開始就把各校的邀請訊息發出去了，最後是找到了 9 間學校聯合主辦，而 SCIST 則是掛協辦，提供我們講師助教等課程上的資源，我們也開始著手撰寫計劃書、排時間表、預估經費、詢問場地租借...等。在計劃書撰寫上感謝小白幫了很大的忙，而其他的事情也很幸運有上一屆寒訓的 PJ、Koying...等人的努力，有留下文檔提供我們很多資訊可作參考，讓我們在初期不容易迷失方向，對我們幫助很大。\n\n在短短的一週內，就收到了個主辦校報名的工作人員 35 人左右，其中我從南附資研中就拉了 10 幾個人來當行政，加上 SCIST 的講師及助教，最後行政組達到了 50 人左右。\n\n![行政組總表](https://hackmd.io/_uploads/rJyZKRBoT.png)\n\n我們接著開放學員報名，一開始報名狀況其實不是很好，我們很怕無法收到預估的學員人數，所以加強了各校的宣傳，我也以擔任小編的經驗到各大社團和營隊網站上刊登廣告，後來發現報名期間只有第一週和最後一週報名人數才會增加的現象...\n在這要感謝成功大學資工系的 Colten 幫忙處理成大場地以及接線讓成大資工系與本次寒訓合作，讓推廣曝光提升了很多，也提供了我們成大超級棒的階梯教室和電腦教室場地給寒訓使用，也要特別感謝副召 KCC 不斷地與南一中接洽，才能有超大的群英堂提供我們舉辦晚會活動。\n\n![Eport 宣傳刊登](https://hackmd.io/_uploads/Hy_oqRBjp.png)\n\n過了學員報名期限，很開心的我們收到了超過 100 多位學生的報名，接下來就是繁瑣篩選學員環節，繁瑣是因為要閱讀大量的試算表內容，根據報名者的意願、動機、對資訊領域的了解及熱忱來篩選出 80 位實體學員參與為期 3 天的寒訓，然後要開始寄錄取和未錄取通知信，也開始開放學員繳費，過程中遇到了一些困難與挑戰。\n\n![報名結果](https://hackmd.io/_uploads/B1tgoRri6.png)\n\n# 挑戰與學習\n\n在做行政的過程中，會不小心放錯連結之類的，當下其實滿慌的，很難及時補救，所以很感謝有行政組的其他人幫忙處理，我也在這次的籌備過程中學到了很多應對問題的方法，讓我了解到做事須謹慎小心且要再三確認，也在當行政的過程中，學習到如何回信、如何應對突發狀況等。\n\n# 團隊分工合作\n\n在籌備期間我們團隊訂好 Deadline，由召群這分派給每個職位工作，行政組招收了活動、隊輔、總務、場務、美宣和醫護，將每個職位開討論區讓各組員交流更便利，且將資訊公開透明，也將各種連結彙整在一起，讓行政組同步且避免落差，很感謝各組組長非常積極的參與和組員的配合，讓我體會到團隊分工合作的重要性。\n\n![行政組討論區](https://hackmd.io/_uploads/HkMg5CHop.png)\n\n## 活動組\n\n這次寒訓的所有遊戲內容和晚會皆由活動組規劃，我覺得他們非常辛苦，比我們召群還要肝，他們從上任就開始想活動、出題、討論流程，常常看到他們在開會，我大部分都會在，感受到他們的忙碌，要絞盡腦汁的思考有什麼團康遊戲可以玩，思考如何讓學員們破冰，讓彼此在短時間內互相熟悉了解，這裡要特別感謝 Yudong、OsGa 和 Joyce 三位超強的活動，前兩位甚至是三天裡最辛苦的主持人，而活動組長 Yudong 和隊輔組長 Joyce 的規劃和執行能力也讓我相當佩服，這三天有這麼精彩的活動真的要歸功於他們\n\n{% gallery %}\n![活動組開會](https://hackmd.io/_uploads/HJxGBXroT.png)\n![活動組規劃](https://hackmd.io/_uploads/rJa7UaQoT.png)\n![題庫](https://hackmd.io/_uploads/Bkf8pASia.png)\n![大地遊戲關主分配](https://hackmd.io/_uploads/rkl48J8sT.png)\n{% endgallery %}\n\n## 隊輔組\n\n隊輔組是人數最多的一組，因為我們總共招收了 85 位實體學員，所以收了 18 位隊輔，負責帶領小隊完成這三天的所有活動，還要做小隊牌、點名、帶跳小隊舞(~~這點子不是我想的~~)...等繁雜的工作，是需要有責任感且能了解活動流程的人擔任\n\n{% gallery %}\n![隊輔組開會](https://hackmd.io/_uploads/SJbTwaQi6.png)\n![小隊舞音樂](https://hackmd.io/_uploads/SkcTL1Usa.png)\n![隊輔組點名](https://hackmd.io/_uploads/H1msjkIsT.png)\n{% endgallery %}\n\n\n## 總務組\n\n總務組只有兩個人，負責事前的訂餐與金錢的管控，是非常重要的角色\n{% gallery %}\n![餐點店家](https://hackmd.io/_uploads/HkGd6y8iT.png)\n![金錢規劃與收支紀錄](https://hackmd.io/_uploads/r1adxgUi6.png)\n{% endgallery %}\n\n## 場務組\n\n場務組負責拍照、餐點搬運、場復...等工作，要在大家休息的時候努力工作，非常辛苦，感謝場務這三天的付出。\n\n## 美宣組\n\n這次的美宣組只有 JT Lin 一個人，他非常辛苦要製作所有工作人員和實體學員的名牌、獎狀、參與證明...等，需要大量的時間製作，還要兼任隊輔，是一個效率高且負責的人，~~只不過這三天滿諧咖的~~\n\n{% gallery %}\n![宣傳圖](https://hackmd.io/_uploads/ByjPvkIi6.png)\n![美宣工作](https://hackmd.io/_uploads/rJWnPyUs6.png)\n![名牌](https://hackmd.io/_uploads/Hyuu_yLjp.jpg)\n{% endgallery %}\n\n# 課程內容\n\n這次因為 SCIST 協辦，所以有了講師以及助教，感謝講師們在寒訓前辛苦的準備課程講義，每位都帶給學員很大的幫助，以下是我整理的課程資源彙整，大家可以善加利用\n\n## [課程資源彙整](https://hackmd.io/@nine-southern-schools/course-link)\n\n{% gallery %}\n![20240206_101644](https://hackmd.io/_uploads/HJGrUmAha.jpg)\n![20240206_101837](https://hackmd.io/_uploads/HkRNI7Rha.jpg)\n![DSC_3378](https://hackmd.io/_uploads/BJKIIX02p.jpg)\n![DSC_3383](https://hackmd.io/_uploads/HyY8IX02p.jpg)\n![DSC_3385](https://hackmd.io/_uploads/BJKU8mCnp.jpg)\n![DSC_3396](https://hackmd.io/_uploads/HkML8QC36.jpg)\n![DSC_3444](https://hackmd.io/_uploads/BkdL8mC3p.jpg)\n![DSC_3452](https://hackmd.io/_uploads/S1tII70hT.jpg)\n![DSC_3456](https://hackmd.io/_uploads/rkHULmC2a.jpg)\n![DSC_3458](https://hackmd.io/_uploads/H1L8UQ0na.jpg)\n![DSC_3460](https://hackmd.io/_uploads/B1wULQR2T.jpg)\n![DSC_3485](https://hackmd.io/_uploads/S1X88QRhT.jpg)\n![DSC_3503](https://hackmd.io/_uploads/HyuILQ036.jpg)\n![DSC_3505](https://hackmd.io/_uploads/HkYUL703T.jpg)\n![DSC_3514](https://hackmd.io/_uploads/SkwUU7R36.jpg)\n![IMG_7065](https://hackmd.io/_uploads/rkeUI7Rha.jpg)\n![IMG_7081](https://hackmd.io/_uploads/SJiH8Q0h6.jpg)\n![IMG_9032](https://hackmd.io/_uploads/SJw4UQ03T.jpg)\n![IMG_9036](https://hackmd.io/_uploads/r1UVUm026.jpg)\n![IMG_9086](https://hackmd.io/_uploads/rJLNU7Rh6.jpg)\n{% endgallery %}\n\n\n# 活動內容\n\n先放照片 下面剩下的文字內容等我有空再補 ...\n\n## 開幕與破冰\n\n{% gallery %}\n![20240205_085547](https://hackmd.io/_uploads/HkhetmAnT.jpg)\n![20240205_085620](https://hackmd.io/_uploads/ry4bFQ03a.jpg)\n![20240205_093011](https://hackmd.io/_uploads/Hk21Y7Ahp.jpg)\n![20240205_093051](https://hackmd.io/_uploads/H1HlFXAh6.jpg)\n![20240205_093139](https://hackmd.io/_uploads/BkagYX02p.jpg)\n![20240205_093648](https://hackmd.io/_uploads/ry1-t7Anp.jpg)\n![20240205_093708](https://hackmd.io/_uploads/S1JbFQC2p.jpg)\n![20240205_093714](https://hackmd.io/_uploads/rkigK7A2p.jpg)\n![20240205_093746](https://hackmd.io/_uploads/ByHxFXR3a.jpg)\n![20240205_093822](https://hackmd.io/_uploads/S16ltX0hT.jpg)\n![20240205_093916](https://hackmd.io/_uploads/SyHlFQAha.jpg)\n![20240205_093947](https://hackmd.io/_uploads/BJlixKQCnT.jpg)\n![20240205_094010](https://hackmd.io/_uploads/HJKeFXC2p.jpg)\n![20240205_094025](https://hackmd.io/_uploads/rJMetmChT.jpg)\n![20240205_094042](https://hackmd.io/_uploads/rJ_xKmAnp.jpg)\n![DSC_3550](https://hackmd.io/_uploads/SyDso7A3T.jpg)\n![DSC_3372](https://hackmd.io/_uploads/rkdooXA3a.jpg)\n![DSC_3263](https://hackmd.io/_uploads/SkDiiXR3p.jpg)\n![20240205_094324](https://hackmd.io/_uploads/HkOssmR2a.jpg)\n![20240205_094148](https://hackmd.io/_uploads/rkujoQ0np.jpg)\n![20240205_094125](https://hackmd.io/_uploads/ryuojXR2T.jpg)\n![20240205_090344](https://hackmd.io/_uploads/Bkusjm0hp.jpg)\n![20240205_094358](https://hackmd.io/_uploads/S1lWYXA3a.jpg)\n![20240205_094504](https://hackmd.io/_uploads/Hy7WF70h6.jpg)\n![20240205_094856](https://hackmd.io/_uploads/BJJxYQC26.jpg)\n![20240205_095313](https://hackmd.io/_uploads/ByPltXA3T.jpg)\n![20240205_095827](https://hackmd.io/_uploads/Bk5gtmRhT.jpg)\n![20240205_100114](https://hackmd.io/_uploads/BJylKQ03p.jpg)\n![20240205_100417](https://hackmd.io/_uploads/HyK1FQR2a.jpg)\n![20240205_101227](https://hackmd.io/_uploads/S1mgYQC3p.jpg)\n{% endgallery %}\n\n\n\n## 贊助商分享\n\n{% gallery %}\n![IMG_7336](https://hackmd.io/_uploads/H1jw37Cnp.jpg)\n![DSC_3652](https://hackmd.io/_uploads/r1hvh7C2a.jpg)\n![DSC_3609](https://hackmd.io/_uploads/SJnv3QRnp.jpg)\n![DSC_3602](https://hackmd.io/_uploads/S13P2QC3a.jpg)\n![DSC_3571](https://hackmd.io/_uploads/rJ2P27Rha.jpg)\n![20240206_132112](https://hackmd.io/_uploads/B12v3XRna.jpg)\n{% endgallery %}\n\n\n## 遊戲活動\n\n{% gallery %}\n![20240205_195634](https://hackmd.io/_uploads/SJ98cmy6T.jpg)\n![20240206_194936](https://hackmd.io/_uploads/SyGu9XyTp.jpg)\n![20240206_195113](https://hackmd.io/_uploads/HJGucQy6p.jpg)\n![20240206_195918](https://hackmd.io/_uploads/HyfO5m166.jpg)\n![20240206_200137](https://hackmd.io/_uploads/HkGu5mJpp.jpg)\n![20240206_200804](https://hackmd.io/_uploads/rkf_cQJT6.jpg)\n![20240206_200805](https://hackmd.io/_uploads/r1fdcmy66.jpg)\n![DSC_3475](https://hackmd.io/_uploads/HJhK5XyaT.jpg)\n![DSC_3480](https://hackmd.io/_uploads/S1e2Yq7JTa.jpg)\n![DSC_3653](https://hackmd.io/_uploads/ryxhF5XJ6T.jpg)\n![DSC_3854](https://hackmd.io/_uploads/SJnY5mypT.jpg)\n![IMG_7110](https://hackmd.io/_uploads/r1hY9mJpp.jpg)\n![IMG_7114](https://hackmd.io/_uploads/S16Yq7k6T.jpg)\n![IMG_7117](https://hackmd.io/_uploads/HkhtcmypT.jpg)\n![IMG_7120](https://hackmd.io/_uploads/S1hK9Q1pT.jpg)\n![IMG_7122](https://hackmd.io/_uploads/HynFqQyTp.jpg)\n![IMG_7125](https://hackmd.io/_uploads/rknK5Q1pp.jpg)\n![IMG_7127](https://hackmd.io/_uploads/HJ3Ycm1a6.jpg)\n![IMG_7133](https://hackmd.io/_uploads/r1htcQ1p6.jpg)\n![IMG_7136](https://hackmd.io/_uploads/SJnYc716p.jpg)\n![IMG_7139](https://hackmd.io/_uploads/ry3F9XyTp.jpg)\n![IMG_7141](https://hackmd.io/_uploads/rJg2Yq7k6T.jpg)\n![IMG_7143](https://hackmd.io/_uploads/ryght57ypp.jpg)\n![IMG_7144](https://hackmd.io/_uploads/SJe3K5mJpa.jpg)\n![IMG_7146](https://hackmd.io/_uploads/S12Y9X1TT.jpg)\n![IMG_7171](https://hackmd.io/_uploads/rJ3Y5QyTp.jpg)\n![IMG_7186](https://hackmd.io/_uploads/HkehF5my6p.jpg)\n![IMG_7196](https://hackmd.io/_uploads/By3YqXJap.jpg)\n![IMG_7224](https://hackmd.io/_uploads/HkxnF571pp.jpg)\n![IMG_7225](https://hackmd.io/_uploads/SJg3Kq7kaT.jpg)\n![IMG_7227](https://hackmd.io/_uploads/SknKq7kTT.jpg)\n![IMG_7228](https://hackmd.io/_uploads/r13K57Jpa.jpg)\n![IMG_7246](https://hackmd.io/_uploads/rJe3KqQ1aT.jpg)\n![IMG_7247](https://hackmd.io/_uploads/rJhF5XyTa.jpg)\n![IMG_7395](https://hackmd.io/_uploads/H1hY97ypa.jpg)\n![IMG_7401](https://hackmd.io/_uploads/Skl2FcXJ6a.jpg)\n![IMG_9050](https://hackmd.io/_uploads/ByAO5XyTT.jpg)\n{% endgallery %}\n\n## 晚會\n\n<!-- 特別感謝邀請到的南女光舞社、南女鎖舞社和活力小精靈帶來的精彩表演，讓整個晚會的氣氛提升了一個檔次 -->\n\n\n## 闖關活動\n\n{% gallery %}\n![20240207_091051](https://hackmd.io/_uploads/ryUD3m1aT.jpg)\n![20240207_092117](https://hackmd.io/_uploads/BkrwhQypa.jpg)\n![20240207_104938](https://hackmd.io/_uploads/H1rvnXyaT.jpg)\n![DSC_3856](https://hackmd.io/_uploads/ByLv2m1aa.jpg)\n![DSC_3875](https://hackmd.io/_uploads/S1Lv3Xkaa.jpg)\n![DSC_3880](https://hackmd.io/_uploads/SJLD37Jap.jpg)\n![DSC_3881](https://hackmd.io/_uploads/S1Dvh7kTT.jpg)\n![DSC_3883](https://hackmd.io/_uploads/H1vw2mk6T.jpg)\n![DSC_3884](https://hackmd.io/_uploads/r18wh716T.jpg)\n![DSC_3887](https://hackmd.io/_uploads/Sywvh7JT6.jpg)\n![DSC_3901](https://hackmd.io/_uploads/By8PhQ1a6.jpg)\n![DSC_3910](https://hackmd.io/_uploads/ry8PhQkpp.jpg)\n![DSC_3911](https://hackmd.io/_uploads/rk8v3m1ap.jpg)\n![DSC_3915](https://hackmd.io/_uploads/B1LDnXkpp.jpg)\n![DSC_3916](https://hackmd.io/_uploads/BkLwnmy66.jpg)\n![DSC_3921](https://hackmd.io/_uploads/BJvD2QkT6.jpg)\n![DSC_3924](https://hackmd.io/_uploads/SJwD27ypT.jpg)\n![DSC_3928](https://hackmd.io/_uploads/BkgIvnQypa.jpg)\n![DSC_3948](https://hackmd.io/_uploads/rJIvhmypT.jpg)\n![DSC_3951](https://hackmd.io/_uploads/SJvv2m1TT.jpg)\n![DSC_3961](https://hackmd.io/_uploads/B1eIv2QJ66.jpg)\n![DSC_3979](https://hackmd.io/_uploads/H1xUP37JTa.jpg)\n![DSC_3994](https://hackmd.io/_uploads/SJlIvh7Jap.jpg)\n![DSC_4010](https://hackmd.io/_uploads/HyIw3QyTa.jpg)\n![DSC_4019](https://hackmd.io/_uploads/ryUD2Xkpa.jpg)\n![DSC_4029](https://hackmd.io/_uploads/r1LDhQkaT.jpg)\n![DSC_4040](https://hackmd.io/_uploads/B1xIP2mJTp.jpg)\n![DSC_4048](https://hackmd.io/_uploads/HyxUv3Q1a6.jpg)\n![DSC_4113](https://hackmd.io/_uploads/ByxIvnXk6T.jpg)\n![DSC_4125](https://hackmd.io/_uploads/HJl8v3mJTp.jpg)\n![DSC_4131](https://hackmd.io/_uploads/BkgLDhm16T.jpg)\n![DSC_4160](https://hackmd.io/_uploads/rkeUPnQyTT.jpg)\n![IMG_7522](https://hackmd.io/_uploads/BygDD27kTa.jpg)\n![IMG_7529](https://hackmd.io/_uploads/ryvP3my6a.jpg)\n![IMG_7530](https://hackmd.io/_uploads/SyPw271p6.jpg)\n![IMG_7532](https://hackmd.io/_uploads/Hk8PhQJap.jpg)\n{% endgallery %}\n\n## 經驗分享\n\n{% gallery %}\n![DSC_4264](https://hackmd.io/_uploads/rJS9jQkTp.jpg)\n![DSC_4255](https://hackmd.io/_uploads/SyS5j71aa.jpg)\n![DSC_4240](https://hackmd.io/_uploads/rkH5iQkaa.jpg)\n![DSC_4247](https://hackmd.io/_uploads/rkr5s7kpT.jpg)\n![DSC_4226](https://hackmd.io/_uploads/Bkrco7kT6.jpg)\n![DSC_4215](https://hackmd.io/_uploads/BkB9oXk6a.jpg)\n![DSC_4220](https://hackmd.io/_uploads/SkH5j7JaT.jpg)\n![DSC_4214](https://hackmd.io/_uploads/S1BqsXkpa.jpg)\n![20240207_135837](https://hackmd.io/_uploads/SkBciXypT.jpg)\n![DSC_4209](https://hackmd.io/_uploads/BJS9s7k6a.jpg)\n![20240207_135437](https://hackmd.io/_uploads/SJr5o7yaT.jpg)\n![20240207_135238](https://hackmd.io/_uploads/rkHqj7J66.jpg)\n![20240207_135221](https://hackmd.io/_uploads/S1S9jm1Tp.jpg)\n![20240207_134445](https://hackmd.io/_uploads/Syrcom1T6.jpg)\n![20240207_134024](https://hackmd.io/_uploads/rkHco716T.jpg)\n{% endgallery %}\n\n## 頒獎與閉幕\n\n{% gallery %}\n\n\n\n{% endgallery %}\n\n\n# 大合照\n\n![大合照](https://hackmd.io/_uploads/rkmsFpXoa.jpg)\n\n# 回饋\n\n{% gallery %}\n![image](https://hackmd.io/_uploads/H1Uq5TQj6.png)\n![image](https://hackmd.io/_uploads/SJFyo6Qja.png)\n![image](https://hackmd.io/_uploads/S1Ylspmjp.png)\n{% endgallery %}\n\n# 檢討與反思\n\n照片整理了很久，等我有空再來回補文字\n\n# 未來展望","tags":["資訊社","SCIST","寒訓","營隊","成大資工"],"categories":["心得","營隊"]},{"title":"C++ STL 全","url":"/post/STL/","content":"\n# Intro\n\n學完 C++ 基礎語法之後，接著就該進入資料結構的世界了！\n本篇筆記要介紹的是 C++ STL，彙整了許多基礎資料結構的概念與用法，文章內容較多，部分內容為收集資料擷取後並經過修改整理而成，文章內容若有任何錯誤或需要補充的地方都歡迎使用右側聊天室傳送訊息給我，我將會儘速修改，謝謝\n\n# 先備知識\n\n標準模板庫(Standard Template Library)，簡稱 **STL** 為 C++ 內建的函式庫\n為了應對各種資料型態，因此採用 `模板 template` 來實作，分為六大部分：\n\n1. 容器 Containers\n2. 演算法 Algotithm\n3. 迭代器 Iterator\n4. 適配器 Adaptor\n5. 仿函數 Function object\n6. 空間配置器 allocator\n\n> 本篇文章內容著重於前四大部分\n\n## 符號解釋\n\n對於本篇文章中各種符號的解釋\n\n- C：某種容器(container)\n- T：某種資料型態(type)\n- S：長度(size)\n- i：索引(index)\n- val：值(value)\n- K：鍵值(key)\n- it：迭代器(iterator)\n\n## 迭代器(iterator)\n\nC++ STL 為每個容器提供一個成員型別：`迭代器 Iterator`，我們可以用 `指標 pointer` 的概念來理解迭代器(實際上，指標算是一種迭代器)\n\n假設現在有個迭代器 `it`，如果要存取 `it` 所指向的內容，那就是在前面加上星號 `*it`，與指標相同\n\n以下有迭代器的三種分類：\n\n1. 隨機存取迭代器：這種迭代器能夠和整數的加減法，往 `後移 x 項`、往 `前移 x 項` 皆可，也可以 `遞增 (++)` 和 `遞減 (−−)`，可以把指標當作這種迭代器\n2. 雙向迭代器：只能做 `遞增 (++)` 和 `遞減 (−−)` 的運算，也就是 `後一項` 和 `前一項`\n3. 單向迭代器：只能做 `遞增 (++)` 的運算，也就是 `後一項`\n\n利用迭代器可**遍歷容器中的元素**，分為 `iterator` 和 `reverse_iterator`（反向迭代器）\n可用 `C.begin(), C.end()` 取得容器的 `起始` 和 `尾端` \n而 `reverse_iterator` 則是 `C.rbegin(), C.rend()`\n\n`iterator` 示意圖 ([圖片來源](https://crmne0707.pixnet.net/blog/post/318479072-c%2B%2B-%E8%BF%AD%E4%BB%A3%E5%99%A8-iterator))\n\n![iterator 示意圖](https://hackmd.io/_uploads/HJbllasvp.png)\n\n---\n\n# 資料結構的詳細介紹\n\n本篇介紹以下 C++ STL 內建基礎資料結構：\n\n- 動態陣列 vector \n- 字串 string \n- 數對 pair \n- 數組 tuple \n- 堆疊 stack \n- 佇列 queue \n- 雙端佇列 deque \n- 優先佇列 priority_queue\n- 集合 set \n- 映射 map \n- 多重集合 multiset \n- 多重映射 multimap \n- 無序集合 unordered_set \n- 無序映射 unordered_map \n- bitset\n\n\n## vector 動態陣列\n\n像是 C++ `陣列 array` 的升級版，可**動態新增元素**且能**改變長度**，不用事先宣告固定大小，且能支援原有的操作，基本上學完 `vector` 可直接取代 `array`\n\n### 可支援的操作方法\n\n| 操作方法 | 功能介紹 |\n| --- | --- |\n| v[i] | 讀取 v 的第 i 項，複雜度 $O(1)$ |\n| v.empty() | 回傳一個 bool，表示 v 是否為空的，複雜度 $O(1)$ |\n| v.clear() | 清空 v，但原本的空間不會被釋放掉，複雜度 $O(n)$ |\n| v.size() | 回傳 v 目前的長度，複雜度 $O(1)$ |\n| v.resize(S,val) | 強制將 v 的長度變為 S，若比原本長，則後面加 val 直到長度為 S，若比原本短則將多出的部分捨去，複雜度 $O(n)$ |\n| v.reserve(S) | 預留 S 個空間，若 S  > v.size()，此函數不造成任何影響 |\n| v.capacity() | 取得容量（預分配的內存空間） |\n| v.insert(it,val) | 在 it 位置插入 val，必須向後搬動其餘元素，複雜度 $O(n)$ |\n| v.erase(it) | 刪除 it 位置元素，也須向前搬動其餘元素，複雜度 $O(n)$ |\n| v.front() / v.back() | 容器的首個元素或最後一個元素 |\n| v.push_back(val) / v.emplace_back(val) | 在 v 的結尾加一個 val，均攤複雜度 $O(1)$ |\n| v.pop_back() | 刪除 v 的最末項，若 v 為空，會發生無法預期的結果，複雜度 $O(1)$ |\n| v.begin() / v.end() | 首個元素或最後一個元素的 iterator |\n| v.shrink_to_fit() | 將 v 的容量縮成剛好 size 的大小 |\n\n### 可支援的演算法函數\n\n| 演算法函數 | 功能介紹 |\n| --- | --- |\n| swap(v1,v2) / v1.swap(v2) | 交換兩 vector |\n| find(v.begin(), v.end(), val) | 在 v 中查找 val，找到返回指定元素的迭代器，找不到返回结束迭代器 end() |\n| count(v.begin(), v.end(), val) | 計算 v 中 val 出現的次數 |\n| replace(v.begin(), v.end(), val, new_val) |  將 v 中的 val 全部替換成 new_val |\n| sort(v.begin(), v.end()) | 排序 v |\n| reverse(v.begin(), v.end()) | 反轉 v |\n| merge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin()) | 將 v1 與 v2 合併到 v3 |\n| binary_search(v.begin(), v.end(), val) | 二分搜，如果在 v 中有找到 val 回傳 1，否則回傳 0 |\n| lower_bound(v.begin(), v.end(), val) | 回傳在 v.begin() 位置(包含)到 v.end() 位置(不含)之間第一個 >= val 的元素的位置 |\n| upper_bound(v.begin(), v.end(), val) | 回傳在 v.begin() 位置(包含)到 v.end() 位置(不含)之間第一個 > val 的元素的位置 |\n| next_permutation(v.begin(),v.end()) | 下一个排列组合 |\n| prev_permutation(v.begin(),v.end()) | 上一个排列组合 |\n\n> `lower_bound` / `upper_bound` 可透過 ` * ` 取值，需在**由小到大排列好的陣列**中才可使用，若回傳的值是 `v.end()`，代表沒有符合的元素\n\n### 常用基本操作 Code\n\n```cpp=\n// 宣告\nvector<int> v;    // 長度為 0 的空 vector\nvector<int> v(5); // 長度為 5 的 vector\nvector<int> v(5,10); \n// 長度為 5 且每個元素皆被初始化為 10 的 vector，複雜度為 O(n)\nvector<int> v = {1,2,3};\n\n// 宣告雙層 vector\nvector< vector<int> > vv;\n// 可想像成二維陣列，但每一列長度可以不一樣\n\n// 取值\nint n = v[0];\n// 與陣列一樣可使用 index 取值\n\n// 取得長度\nint s = v.size();\n\n// 更改大小\nv.resize(5);    // 將 v 的長度更改為 5\n\n// 在尾端加入元素\nint n = 10;\nv.push_back(n);\nv.emplace_back(n);\n\n// 移除尾端元素\nv.pop_back();\n\n// 尋找\nvector<int> v = {1,3,5,7,9};\nint val; cin >> val\nif(find(v.begin(), v.end(), val) == v.end()) {\n    cout << \"Not find\\n\";\n} else cout << \"Find!\";\n// input : 5 , output : Find!\n// input : 6 , output : Not Find\n\n// 排序(升序 由小到大)\nsort(v.begin(), v.end());\nsort(v, v+v.size());\n\n// 排序(降序 由大到小)\nsort(v.rbegin(), v.rend());\nsort(v.begin(), v.end(),greater<int>());\n\n// 反轉\nreverse(v.begin(), v.end());\n\n// 二分搜\nbinary_search(v.begin(), v.end(), val)\nupper_bound(v.begin(), v.end(), val);\nlower_bound(v.begin(), v.end(), val);\n\n// 合併\nvector<int> v1 = {1,3,5},\n            v2 = {2,4,6},\n            v3(6);\nmerge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin());\nfor(auto i : v3) cout << i << \" \";\n// output : 1 2 3 4 5 6\n\n// 全排列\nvector<int> v = {1,3,5};\nwhile(next_permutation(v.begin(),v.end())) \n{\n    for(auto i : v) cout << i << \" \";\n    cout << \"\\n\";\n}\n// output : \n// 1 5 3 \n// 3 1 5 \n// 3 5 1 \n// 5 1 3 \n// 5 3 1\n```\n\n> 注意：`vector` **不支援**對**前端元素**使用 `新增` 或 `刪除` 的操作\n\n### 補充\n\n> `push_back()` 與 `emplace_back()` 功能相同，但如果以效能為優先，`emplace_back()` 通常比 `push_back()` 更快一點，因為是直接呼叫 constructor 不會複製 object，所以有時候執行效率會比較快。\n[延伸閱讀：codingninjas - emplace_back() vs push_back() in C++ Vectors\n](https://www.codingninjas.com/studio/library/vector-push_back-vs-emplace_back)\n\n\n\n> 在知道需要多少元素後，可以先對 `vector` 做 `reserve()` 擴充 `capacity` 再 `emplece_back()` ，會比 `空 vector` 慢慢 `emplece_back()` 快\n[延伸閱讀：ping 不見路 - STL vector 效率小記](https://arc.net/l/quote/tslhdeoj)\n示意圖 ([圖片來源](https://blog.csdn.net/JACKSONMHLK/article/details/114396650))\n![vector 示意圖](https://hackmd.io/_uploads/H1CgPoTva.png)\n\n\n## string 字串\n\n由**連續的字元**組成，其實就是 `vector<char>`，非常方便使用\n\n### 可支援的操作方法\n\n`vector` 有的 `string` 幾乎都有\n\n### 常用基本操作 Code\n\n```cpp=\n// 宣告\nstring s;    // 預設為空字串\nstring s1 = \"ABC\";\n\n// 賦值\ncin >> s;        // 以空白作為輸入分隔\ngetline(cin,s);  // 以換行作為輸入分隔\ns = \"ShiYu\";\ns = s1;\n\n// 串接\ns = \"ShiYu\";\ns1 = \"ABC\";\ns += s1;\ncout << s;\n// output : ShiYuABC\n\n// 刪除最後一個字元\ns.pop_back();\n\n// 讀取\ncout << s[3];\n// output : Y\n\n// 擷取子字串\ncout << s.substr(0,3);\n// output : Shi\n\n// 取得長度\ncout << s1.size();\n// output : 5\n```\n\n> 注意：取得字串長度請不要用 `strlen()`，應該要用 `size()`，因為前者複雜度為 `O(n)`，後者為 `O(1)`\n\n\n## pair 數對\n\n**可將兩個型態的資料合併**，透過成員 `first` 和 `second` 來存取元素，`pair` 也可以**元素字典序**來比較或排序，以 `first` 為優先\n\n### 常用基本操作 Code\n\n```cpp=\n// 宣告\npair<int, double> p;\n\n// 賦值\np = {1, 2.5};\np = make_pair(1, 2.5);\n\n// 取值\nint f = p.first();    // 1\ndouble s = s.second();// 2.5\n\n// 比較\npair<int, double> a, b;\na = {1, 2.5};\nb = {1, 2.6};\ncout << (a < b) << \"\\n\"; \n// output : 1 (true)\n\n// 交換兩 pair\npair<int, int> a,b;\na = {1, 3};\nb = {2, 4};\nswap(a, b); // or a.swap(b)\ncout << a.first << \" \" << a.second << \"\\n\"; \n// output : 2 4\n\n// pair 搭配 vector 新增元素\nvector< pair<int,int> > vp;\nvp.push_back(make_pair(1,2));\nvp.emplace_back(3,4); // 用 emplace_back 可以不用 make_pair\nfor(auto i : vp) {\n    cout << i.first << \" \" << i.second << \"\\n\";\n}\n// output : \n// 1 2\n// 3 4\n\n// 使用 vector 排序多個 pair\npair<int,int> a = {1,3},\n              b = {2,4},\n              c = {1,2};\nvector< pair<int, int> > v{a, b, c};\n\nsort(v.begin(), v.end());\n\nfor(auto i : v) {\n    cout << v[i].first << \" \" << v[i].second << \"\\n\";\n}\n// output : \n// 1 2\n// 1 3\n// 2 4\n```\n\n## tuple 數組\n\n與 `pair` 相似，但可以**同時組合多個不同型別的元素**( `pair` 只能 2 個)\n\n### 常用基本操作 Code\n\n```cpp=\n// 宣告\ntuple<string, int, bool> tp;\n\n// 初始化\ntuple<string, int, bool> tp(\"ShiYu\", 16, true); \n\n// 賦值\ntp = {\"ShiYu\", 16, true};\ntp = make_tuple(\"ShiYu\", 16, true);\ntie(\"ShiYu\", 16, true) = tp;\n\n// 取值\nint age = get<1>(tp); // 16\n\n// 修改值\nget<2>(tp) = false;\n\n// 取得元素個數\ncout << tuple_size<decltype(tp)>::value << \"\\n\"; \n// output : 3\n\n// tuple 搭配 vector 新增元素\nvector< tuple<int, int, int> > vt;\nvt.push_back(make_tuple(1, 2, 3));\nvt.emplace_back(4, 5, 6); // 用 emplace_back 可以不用 make_tuple\n\nfor(auto& [a,b,c] : s) {\n    cout << a << \" \" << b << \" \" << c << \"\\n\";\n}\n// output : \n// 1 2 3\n// 4 5 6\n```\n\n## stack 堆疊\n\n可以想像成**一疊書本**，每次只能在**最上面** `放置` 或 `拿走` 一本書\n有著 `後進先出 Last In First Out` 的規則\n預設以 `Deque` 為基底的 `容器適配器 Container Adaptors`\n\n### 可支援的操作方法\n\n| 操作方法 | 功能介紹 |\n| --- | --- |\n| s.size() | 取得 s 大小 |\n| s.empty() | 回傳 s 是否為空 |\n| s.top() | 取得 s 頂端元素 |\n| s.push(val) / s.emplace(val) | 將 val 放入 s 頂端 |\n| s.pop() | 移除 s 頂端元素 |\n\n> 複雜度皆為 `O(1)`\n\n### 示意圖\n\n![stack 示意圖](https://hackmd.io/_uploads/S1U5nn0wT.png)\n\n([圖片來源](https://www.programiz.com/dsa/stack))\n\n### 常用基本操作 Code\n\n依照示意圖實作\n\n```cpp=\nstack<int> stk;\nfor(int i=1;i<=3;++i) {\n    stk.push(i);\n}\nwhile(!stk.empty()) {\n    cout << stk.top() << \"\\n\";\n    stk.pop();\n}\n// output : \n// 3\n// 2\n// 1\n```\n\n### 常見應用\n\n維護**單調序列**\n\n## queue 佇列\n\n可以想像為**排隊的人群**，有可能是新的一個人來排在隊伍的尾端，或是最前面一個人結完帳離開隊伍\n有著 `先進先出 First In First Out` 的規則\n\n### 可支援的操作方法\n\n| 操作方法 | 功能介紹 |\n| --- | --- |\n| q.size() | 取得 q 長度 |\n| q.empty() | 回傳 q 是否為空 |\n| q.front() | 取得 q 最前端(第一個加入的)元素 |\n| q.back() | 取得 q 最尾端(最後加入的)元素 |\n| q.push(val) / q.emplace(val) | 將 val 加入  q 尾端 |\n| q.pop() | 移除 q 最前端元素 |\n\n> 複雜度皆為 `O(1)`\n\n### 示意圖\n\n![queue 示意圖](https://hackmd.io/_uploads/HytPb6RDp.png)\n\n([圖片來源](https://www.boardinfinity.com/blog/working-of-queue-using-stl))\n\n### 常用基本操作 Code\n\n```cpp=\nqueue<int> q;\nq.emplace(1);\nq.emplace(2);\nq.emplace(3);\nwhile(!q.empty()) {\n    cout << q.size() << \" \" << q.front() << \" \" << q.back() << \"\\n\";\n    q.pop();\n}\n// output : \n// 3 1 3\n// 2 2 3\n// 1 3 3\n```\n\n### 常見應用\n\n圖論中的 **BFS**\n\n## deque 雙端佇列\n\n為 `double ended queue` 的縮寫，唸作 deck 而非 de-queue，一般的 `queue` 只能從尾端加入元素、從前端移除元素，而 `deque` 的**前後都可以使用加入和移除的操作**，基本上就是多了 `emplace_front()`、`pop_front()` 的 `vector`，雖然方便但由於**常數較大**，競技比賽中非必要不會去使用\n\n### 示意圖\n\n![deque 示意圖](https://hackmd.io/_uploads/SkmEUT0v6.png)\n\n([圖片來源](https://www.codingninjas.com/studio/library/difference-between-queue-and-deque-in-c))\n\n### 可支援的操作方法\n\ndeque 與 vector 相比只是多了針對 front 的操作，少了針對記憶體的操作（因為 vector 記憶體連續，deque 則是分段儲存），不過 deeque 也支援隨機存取 dq[i]\n\n| 操作方法 | 功能介紹 |\n| --- | --- |\n| dq.push_front(val) / dq.emplace_front(val) | 將 val 加入  dq 前端 |\n| dq.push_back(val) / dq.emplace_back(val) | 將 val 加入  dq 尾端 |\n| dq.pop_front() | 移除 dq 最前端元素 |\n| dq.pop_back() | 移除 dq 最尾端元素 |\n\n> 複雜度皆為 `O(1)`\n\n### 常用基本操作 Code\n\n```cpp=\ndeque<int> dq;\ndq.emplace_front(1);\ndq.emplace_back(2);\nfor(auto i : dq) cout << i << \" \";\ncout << \"\\n\";\ndq.pop_front();\nfor(auto i : dq) cout << i << \" \";\ncout << \"\\n\";\ndq.pop_back();\ncout << dq.size() << \"\\n\";\n// output : \n// 1 2 \n// 2 \n// 0\n```\n\n## priority_queue 優先佇列\n\n`priority_queue` 利用幾個內建函式實現 `堆積 heap` 結構，它可以維持最頂端的元素永遠是最大或最小的，所以可以很方便**快速的存取極值**\n\n### 示意圖\n\n![priority queue 示意圖](https://hackmd.io/_uploads/rJqPcT0PT.png)\n\n([圖片來源](https://www.programiz.com/dsa/priority-queue))\n\n### 可支援的操作方法\n\n| 操作方法 | 功能介紹 |\n| --- | --- |\n| pq.size(),pq.empty() | 同 vector，複雜度 $O(1)$ |\n| pq.top() | 回傳 pq 中最大或最小的元素，複雜度 $O(1)$ |\n| pq.push(val) / pq.emplace(val)  | 將 val 加入 pq 中，複雜度 $O(\\log n)$ |\n| pq.pop() | 將 pq 中最大或最小的元素移除，複雜度 $O(\\log n)$ |\n\n### 常用基本操作 Code\n\n```cpp=\npriority_queue<int> pq;\npq.emplace(3);\npq.emplace(5);\npq.emplace(9);\ncout << pq.top();\n// output : 9\n\npriority_queue< int, vector<int>, greater<int> > pq;\npq.emplace(3);\npq.emplace(5);\npq.emplace(9);\ncout << pq.top();\n// output : 3\n```\n\n### 補充\n\n> `priority_queue` 有三個型別參數 `T`、`C`、`Cmp`\n`T` 是**內容物的型別**，`C` 是**所採用的容器**，`Cmp` 是**比大小的依據**\n`priority_queue` 能使用的容器有 `vector` 和 `deque`\n`Cmp` 的預設值是 `less<T>`，此時的 `priority_queue` 是**最大堆 max heap**\n若改成 `greater<T>`，則 `priority_queue` 為 **最小堆 min heap**\n建構式如上方 Code 第 8 行，而 output 為最小值\n\n### 延伸閱讀\n\n- [Binary Heap 的排序原理](https://medium.com/starbugs/%E4%BE%86%E5%BE%81%E6%9C%8D%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95%E5%90%A7-%E6%90%9E%E6%87%82-binary-heap-%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86-96768ea30d3f)\n- [資料結構大便當： Binary Heap](https://arc.net/l/quote/asrwfvnj)\n\n\n## set 集合\n\n`set` 實現了 `紅黑樹(二元平衡樹) RB tree`，也就是說可以用 `O(log n)` 的複雜度**插入**、**刪除**或**查詢**一個值是否在其中\n\n**內部自動有序**且與數學的集合概念一樣**不含重複元素**，具有很方便地**去重**功能，且通常會稱元素的值為 `鍵值 Key`\n\n### 示意圖\n\n![image](https://hackmd.io/_uploads/SyYmoACPT.png)\n\n([圖片來源](http://www.ccplusplus.com/2014/01/std-set-example-c.html))\n\n\n\n### 可支援的操作方法\n\n| 操作方法 | 功能介紹 |\n| --- | --- |\n| s.size() / s.empty() | 同 vector |\n| s.insert(K) | 在 s 中放入一個鍵值為 k 的元素，若本來就有，則什麼事都不會做，複雜度 $O(\\log n)$ |\n|  s.erase(K) | 刪除鍵值為 k 的元素，並回傳刪除的個數。複雜度 $O(\\log n)$ |\n| s.erase(it first,it last) | 刪除 `[first,last)`，若沒有指定 last 則只刪除 first，複雜度與刪除的個數呈線性 |\n| s.find(K) | 回傳指向鍵值為 k 的迭代器，若 k 值不存在，則回傳 s.end()。複雜度 $O(\\log n)$ |\n| s.count(K) | 回傳有幾個鍵值為 k 的元素，複雜度 $O(\\log n)$ |\n| s.lower_bound(K) | 回傳迭代器指向第一個鍵值大於等於 k 的項。複雜度 $O(\\log n)$ |\n| s.upper_bound(K) | 回傳迭代器指向第一個鍵值大於 k 的項。複雜度 $O(\\log n)$ |\n\n### 常用基本操作 Code\n\n```cpp=\n// 宣告\nset<int> s;\n\n// 插入\ns.insert(10);\n\n// 刪除\ns.erase(10);\ns.erase(s.begin());\n\n// 回傳該元素的 iterator，若 set 內部無該元素，則回傳 end()\ns.find(10);\n\n// 問一個元素在不在 set 裡。可透過 find 的 return 值，或使用 s.count\nif(s.find(10) != s.end()) cout << \"In!\\n\";\nif(s.count(10)) cout << \"In!\\n\";\n\n// 遍歷 set 元素\nfor(auto &i : s) cout << i << \" \";\n```\n\n### 延伸閱讀\n\n- [資料結構 — 紅黑樹(Red-Black Tree)](https://ithelp.ithome.com.tw/m/articles/10333136)\n- [Shengyuu - 紅黑樹 - HackMD](https://hackmd.io/@_01X9rimQmWH33Djf8QhoA/Bkm3enQ8N)\n- [hwdong - 最好懂的红黑树教程 - Youtube](https://www.youtube.com/watch?v=Ij8-xX3PreE)![紅黑樹 示意圖](https://hackmd.io/_uploads/rk4_5RRw6.png)\n\n\n## map 映射\n\n類似於 python 中的 `字典 dict`，內部為 `鍵值對 key-value`，所以 `map` 中每一個元素其實是 `pair`，可以修改 `value` 值，但不能修改 `key` 值\n`map` 可以用 `O(log n)` 的複雜度**插入**、**刪除**或**查詢**一個鍵值對應的值\n\n### 示意圖\n\n![image](https://hackmd.io/_uploads/HkrI0A0Dp.png)\n\n([圖片來源](https://www.mropengate.com/2015/12/cc-map-stl.html))\n\n### 可支援的操作方法\n\n`set` 有的 `map` 幾乎都有\n\n| 操作方法 | 功能介紹 |\n| --- | --- |\n| m[k] | 存取鍵值 k 對應的值，若 k 沒有對應的值，會插入一個元素，使 k 對應到預設值並回傳之，複雜度 $O(\\log n)$ |\n| m.insert(pair<K,T> k) | 若沒有鍵值為 k.first 的值，插入一個鍵值為 k.first 的值對應到 k.second，並回傳一個 pair，first 是指向剛插入的元素的迭代器、second 是 true；若已經有了，回傳一個 pair，first 是指向鍵值為 k.first 的元素的迭代器，second 是 false。 |\n\n## multiset 多重集合 & multimap 多重映射\n\n兩者用法與 `set`、`map` 用法一樣，但**允許有重複元素**，且 `multimap` 中一個鍵值可能對應到不同的值，所以**不支援下標**\n\n### 示意圖\n\n![multiset 示意圖](https://hackmd.io/_uploads/SJrLqACwa.png)\n\n([圖片來源](http://www.ccplusplus.com/2014/01/std-set-example-c.html))\n\n## unordered_set 無序集合 & unordered_map 無序映射\n\n兩者用法也與 `set`、`map` 用法一樣，但利用 `雜湊表 hash table` 實作，**內部不排序**，因為沒有排序，所以當然沒有 `lower_bound()`、`upper_bound()`\n**插入**、**搜尋**都是 `O(1)`，但**常數大**，不常使用\n\n### 示意圖\n\n![image](https://hackmd.io/_uploads/Hy_gSk1uT.png)\n\n([圖片來源](https://conglang.github.io/2015/01/01/stl-unordered-container/))\n\n\n### 延伸閱讀\n\n- [資料結構 - 雜湊表 Hash Table](https://ithelp.ithome.com.tw/articles/10268077?sc=iThelpR)\n- [雜湊表（Hash Table）- 拉爾夫的技術隨筆](https://medium.com/@ralph-tech/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E9%9B%9C%E6%B9%8A%E8%A1%A8-hash-table-15f490f8ede6)\n示意圖([圖片來源](https://conglang.github.io/2015/01/01/stl-unordered-container/))\n![image](https://hackmd.io/_uploads/Hk_j4ykda.png)\n\n\n\n## unordered_multiset 無序多重集合 & unordered_multimap 無序多重映射\n\n依名稱即可知道為前兩者的結合，**內部不排序且可允許重複元素**\n\n## bitset\n\n可以將 `bitset` 當成是一個**效率很快的 bool 陣列**，因為 `bool` 這個型別明明只能表示 `true` 或 `false`，但通常卻佔了 `1 byte` 的記憶體空間，用 `bitset` 可以**宣告固定長度的 bits**，可以想像為一堆 0 和 1 的陣列，並且 `bitset` 的**位元運算**是被優化過的，對常數優化及空間壓縮有不錯的效用，速度大約是 **bool 的 32 倍**\n\n### 可支援的操作函數\n\n| 操作方法 | 功能介紹 |\n| --- | --- |\n| b[i] | 存取第 i 位。複雜度 $O(1)$ |\n| b.count() | 回傳 b 有幾個位元是 1。複雜度 $O(N)$ |\n| b.size() | 回傳 b 有幾個位元。複雜度 $O(1)$ |\n| b.set() | 將所有位元設為 1。複雜度 $O(N)$ |\n| b.reset() | 將所有位元設為 0。複雜度 $O(N)$ |\n| b.flip() | 將所有位元的 0、1 互換 (反白)。複雜度 $O(N)$ |\n| b.any() / b.none() | 檢查 b 中全 0 的情況，若 b 全 0，any() 返回 false、b.none() 返回 true，若 b 至少有一個 1，則結果相反 |\n| b.to_string() | 回傳一個字串和 b 的內容一樣。複雜度 $O(N)$ |\n| b.to_ulong() | 回傳一個 unsigned long 和 b 的內容一樣 (在沒有溢位的範圍內)。複雜度 $O(N)$ |\n\n### 常用基本操作 Code\n\n```cpp=\n// 宣告\nbitset<5> b; // 大小為 5，初始值 00000\n\n// 賦值\nb[0] = 1; // 00001 以右邊為低位\n\n// 設置\nb.set();\t// 11111\nb.reset();  // 00000\n\n// 計數\nb.count(); // 計算 b 裡有幾個 1\n```\n\n---\n\n\n# 題單\n\n看完這篇教學相信大家對 STL 有一定的瞭解了，不過還是要實際練習才能掌握，所以我把曾經寫過的題目整理成資料庫，來自各大 Online Judge，有依照不同的難度及不同資料結構分類好，歡迎大家自行運用，能讓你更加熟練。\n## [STL 題單連結 - Notion](https://shiyu0318.notion.site/C-STL-ShiYu-s-Blog-c2ed8c6b22fb4118bab30b62dbad5299?pvs=4)\n\n---\n\n# Outro\n\n這篇文章只用了兩天的時間，從收集資料、整理資訊、規劃架構，再來開始寫每個資料結構的內容，製作表格、寫 Code、找圖片(每張圖片皆有附上來源)、找補充資料，到最後不斷地重複新增和修改內容，直到整篇文章逐漸完整，我從中學習到的不只有這篇文章所呈現的知識，還有很多重要的能力，也感受到了學習的快樂，日後會不斷地學習新知識，也會針對各主題寫成一篇筆記發佈，感謝大家的閱讀\n\n## 下回預告：{% btn https://4yu.dev/post/Data-Structures/,點擊前往,fa-solid fa-hand-point-right,blue %} C++ 實作資料結構\n\n---\n\n# 參考資料\n\n- [The C++ Standard Template Library (STL)\n](https://www.geeksforgeeks.org/the-c-standard-template-library-stl/)\n- [STL 容器 (一) - 基本介紹 - Jason note](https://jasonblog.github.io/note/c++/stl_rong_qi_4e0029_-_ji_ben_jie_shao.html)\n- [從零開始的演算法競賽入門教學 - STL](https://emanlaicepsa.github.io/2020/11/30/0-16/)\n- [Ian Shih - STL Containers - HackMD](https://hackmd.io/@konchin/BkGVGVd9I)\n- [C++ 中 STL 用法超詳細總結 - Github](https://github.com/0voice/cpp_backend_awsome_blog/blob/main/%E3%80%90NO.19%E3%80%91C++%E4%B8%ADSTL%E7%94%A8%E6%B3%95%E8%B6%85%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93%EF%BC%88%E6%94%B6%E8%97%8F%E7%BA%A7%EF%BC%89.md)\n- [進階 C++ STL 迭代器 - HackMD](https://hackmd.io/@Greenleaf/advanced_cpp)\n- [C++ STL 常用容器以及操作簡介](https://blog.csdn.net/zygood_/article/details/122457444)\n- [C++標準模板庫容器的常見用法](https://tw511.com/a/01/6897.html)\n- [C++ STL 學習總結(全面)](https://jasonblog.github.io/note/c++/c++_stl_xue_xi_zong_7d5028_quan_976229.html)\n- [STL in C++ - Youtube](https://youtube.com/playlist?list=PLk6CEY9XxSIA-xo3HRYC3M0Aitzdut7AA&si=q5I7ppldSRGBKsKq)\n- [cplusplus reference](https://cplusplus.com/reference/)\n- [cppreference](https://en.cppreference.com/w/)\n\n\n---\n\n## [點擊回到導覽頁面](https://4yu.dev/post/Sitemap/)\n\n---","tags":["C++","資料結構 Data Structures","動態陣列 vector","字串 string","數對 pair","數組 tuple","堆疊 stack","佇列 queue","雙端佇列 deque","集合 set","映射 map","多重集合 multiset","多重映射 multimap","無序集合 unordered_set","無序映射 unordered_map","bitset","優先佇列 priority_queue"],"categories":["筆記","程式"]},{"title":"訓練神經網路計算過程","url":"/post/Neural-Network/","content":"\n這是一個具有一層隱藏層的神經網路：\n\n![神經網路示意圖](https://hackmd.io/_uploads/S1zIPbGw6.png)\n\n# 假設\n\n- 輸入層有 3 個節點，輸入 X 中有 3 筆數據，其標籤為 Y：\n$$  \n    X = \n        \\begin{bmatrix}\n            1 & 2 & 0   \\\\\n            2 & -3 & 2  \\\\\n            -1 & -1 & 3 \\\\\n        \\end{bmatrix},\n    Y = \n        \\begin{bmatrix}\n            1  \\\\\n            2  \\\\\n            -3 \\\\\n        \\end{bmatrix}\n$$\n\n$$  \n    W_1 = \n        \\begin{bmatrix}\n            -1 & 0 \\\\\n            -1 & 1 \\\\\n            1 & -1 \\\\\n        \\end{bmatrix}\n$$\n\n- 隱藏層有 2 個節點，隱藏層權重矩陣為 $W_1$，線性組合 $Z=XW_1$，\n  經過激活函數 $\\sigma$ 後的值為 $K$，即 $K = \\sigma(Z)$\n- 另激活函數 $\\sigma$ 為 $Relu$ 函數， $\\sigma(x)=Relu(x)=max(x,0)$\n- 輸出層有 1 個節點，其權重矩陣為 $W_2$，線性輸出 $O=KW_2$\n\n$$  \n    W_2 = \n        \\begin{bmatrix}\n            1  \\\\\n            -2 \\\\\n        \\end{bmatrix}\n$$\n\n- 將輸出值與標籤去計算損失，令損失為 $J$，假設使用加總型式的最小平方損失\n\n$$ J = \\sum (\\frac{1}{2}(O-Y)^2) $$\n\n此時，已知輸出層梯度：\n\n$$G_{out} = \\frac{\\partial J}{\\partial O}=O-Y$$\n\n- 隱藏層梯度：\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        G_2\n        &= \n            \\frac{\\partial J}{\\partial W_2}\n         = \n            \\frac{\\partial J}{\\partial O} \\frac{\\partial O}{\\partial W_2} \n            \\\\\\\\\n        &= \n            ((G_{out})^T \\cdot K)^T \n         = \n            K^TG_{out}\n    \\end{aligned}\n\\end{equation}\n$$\n\n- $Relu$ 函數的微分式：\n\n$$\n\\sigma^{\\prime}(x) = \n    \\begin{cases}\n        0 \\quad x < 0   \\\\\n        1 \\quad x \\ge 0 \\\\\n    \\end{cases}\n$$\n\n- 先假定一個暫存的 $G_{temp}$ ：\n\n$$ G_{temp} = (G_{out} \\cdot W^T_2) \\circ \\sigma^{\\prime}(Z) $$\n\n其中的 $\\cdot$ 代表一般的矩陣乘法、$\\circ$ 代表阿達瑪乘積，為對應位置的矩陣元素乘積\n\n- 輸入層梯度：\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        G_1\n        &= \n            \\frac{\\partial J}{\\partial W_1}\n         = \n            \\frac{\\partial J}{\\partial O} \n            \\frac{\\partial O}{\\partial K}\n            \\frac{\\partial K}{\\partial Z}\n            \\frac{\\partial Z}{\\partial W_1} \n            \\\\\\\\\n        &= \n            (((G_{out} \\cdot W^T_2) \\circ \\sigma^{\\prime} (Z))^T \\cdot X)^T \n            \\\\\\\\\n        &= \n            ((G_{temp})^T \\cdot X)^T \n            \\\\\\\\\n        &= \n            X^TG_{temp}\n    \\end{aligned}\n\\end{equation}\n$$\n\n- 可用 $G_1,G_2$ 梯度更新權重 $W_1,W_2$ 的值，得到新權重 $W_1^{new},W_2^{new}$，\n\n假設我們採用隨機梯度下降法來進行更新，且學習率令為 $0.1$，則\n\n$$\n\\begin{cases}\n    W_1^{new} = W_1 - 0.1 \\times G_1 \\\\\n    W_2^{new} = W_2 - 0.1 \\times G_2 \\\\\n\\end{cases}\n$$\n\n# 問題\n\n求矩陣 $Z,K,O,G_{out},G_2,\\sigma^{\\prime}(Z),G_{temp},G_1,W_1^{new},W_2^{new}$\n\n> 求解過程皆省略公式推導過程，將直接使用最終結果代入計算\n\n---\n\n$Z$\n\n由線性組合 $Z=XW_1$：\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        Z\n        &= \n            XW_1 \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                1 & 2 & 0   \\\\\n                2 & -3 & 2  \\\\\n                -1 & -1 & 3 \\\\\n            \\end{bmatrix} \n            \\cdot\n            \\begin{bmatrix}\n                -1 & 0 \\\\\n                -1 & 1 \\\\\n                1 & -1 \\\\\n            \\end{bmatrix} \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -3 & 2 \\\\\n                3 & -5 \\\\\n                5 & -4 \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n$K$\n\n由經過激活函數 $\\sigma$ 後的值 $K = \\sigma(Z)$，且激活函數 $\\sigma$ 為 $Relu$ 函數， $\\sigma(x)=Relu(x)=max(x,0)$：\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        K \n        &= \n            \\sigma(Z) \n            \\\\\\\\\n        &= \n            \\sigma\\ \n            (\n            \\begin{bmatrix}\n                -3 & 2 \\\\\n                3 & -5 \\\\\n                5 & -4 \\\\\n            \\end{bmatrix}\n            ) \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                0 & 2 \\\\\n                3 & 0 \\\\\n                5 & 0 \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n$O$\n\n輸出層有 1 個節點，其權重矩陣為 $W_2$，由線性輸出 $O=KW_2$：\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        O \n        &= \n            KW_2 \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                0 & 2 \\\\\n                3 & 0 \\\\\n                5 & 0 \\\\\n            \\end{bmatrix} \n            \\cdot\n            \\begin{bmatrix}\n                1  \\\\\n                -2 \\\\\n            \\end{bmatrix} \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -4 \\\\\n                3  \\\\\n                5  \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n$G_{out}$\n\n由輸出層梯度 $G_{out} = O-Y$：\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        G_{out} \n        &= \n            O-Y \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -4 \\\\\n                3  \\\\\n                5  \\\\\n            \\end{bmatrix} \n            - \n            \\begin{bmatrix}\n                1  \\\\\n                2  \\\\\n                -3 \\\\\n            \\end{bmatrix} \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -5 \\\\\n                1  \\\\\n                8  \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n$G_2$\n\n由隱藏層梯度 $G_2 = K^TG_{out}$，其中 $K^T$ 為 矩陣 $K$ 的轉置：\n\n$$\nK = \n    \\begin{bmatrix}\n        0 & 2 \\\\\n        3 & 0 \\\\\n        5 & 0 \\\\\n    \\end{bmatrix},\nK^T = \n    \\begin{bmatrix}\n        0 & 3 & 5 \\\\\n        2 & 0 & 0 \\\\\n    \\end{bmatrix}\n$$\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        G_2 \n        &= \n            K^TG_{out} \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                0 & 3 & 5 \\\\\n                2 & 0 & 0 \\\\\n            \\end{bmatrix} \n            \\cdot\n            \\begin{bmatrix}\n                -5 \\\\\n                1  \\\\\n                8  \\\\\n            \\end{bmatrix} \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                43   \\\\\n                -10  \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n$\\sigma^{\\prime}(Z)$\n\n其中 $\\sigma^{\\prime}$ 為 $Relu$ 函數的微分式：\n\n$$\n\\sigma^{\\prime}(x) = \n\\begin{cases}\n    0 \\quad x < 0   \\\\\n    1 \\quad x \\ge 0 \\\\\n\\end{cases}\n$$\n$$\n\\begin{equation}\n    \\begin{aligned}\n        \\sigma^{\\prime}(Z)\n        &= \n            \\sigma^{\\prime}(\n            \\begin{bmatrix}\n                -3 & 2 \\\\\n                3 & -5 \\\\\n                5 & -4 \\\\\n            \\end{bmatrix}) \n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                0 & 1 \\\\\n                1 & 0 \\\\\n                1 & 0 \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n$G_{temp}$\n\n由假定暫存的 $G_{temp} = (G_{out} \\cdot W^T_2) \\circ \\sigma^{\\prime}(Z)$\n其中的 $\\cdot$ 代表一般的矩陣乘法、$\\circ$ 代表阿達瑪乘積，為對應位置的矩陣元素乘積，且 $W_2^T$ 為矩陣 $W_2$ 的轉置：\n\n$$\nW_2 = \n    \\begin{bmatrix}\n        1  \\\\\n        -2 \\\\\n    \\end{bmatrix},\nW_2^T = \n    \\begin{bmatrix}\n        1 & -2 \\\\\n    \\end{bmatrix}\n$$\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        G_{temp} \n        &= \n            (G_{out} \\cdot W^T_2) \\circ \\sigma^{\\prime}(Z) \n            \\\\\\\\\n        &=  (\n            \\begin{bmatrix}\n                -5 \\\\\n                1  \\\\\n                8  \\\\\n            \\end{bmatrix} \\cdot\n            \\begin{bmatrix}\n                1 & -2\n            \\end{bmatrix}\n            ) \\circ \n            \\begin{bmatrix}\n                0 & 1 \\\\\n                1 & 0 \\\\\n                1 & 0 \\\\\n            \\end{bmatrix}\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -5 & 10 \\\\\n                1 & -2 \\\\\n                8 & -16 \\\\\n            \\end{bmatrix}\n            \\circ \n            \\begin{bmatrix}\n                0 & 1 \\\\\n                1 & 0 \\\\\n                1 & 0 \\\\\n            \\end{bmatrix} \n            \\\\\\\\\n        &=\n            \\begin{bmatrix}\n                0 & 10 \\\\\n                1 & 0 \\\\\n                8 & 0 \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n$G_1$\n\n由輸入層梯度 $G_1 = X^TG_{temp}$，其中 $X^T$ 為 矩陣 $X$ 的轉置：\n\n$$\nX = \n    \\begin{bmatrix}\n        1 & 2 & 0   \\\\\n        2 & -3 & 2  \\\\\n        -1 & -1 & 3 \\\\\n    \\end{bmatrix},\nX^T = \n    \\begin{bmatrix}\n        1 & 2 & -1   \\\\\n        2 & -3 & -1  \\\\\n        0 & 2 & 3    \\\\\n    \\end{bmatrix},\n$$\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        G_1\n        &= \n            X^TG_{temp}\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                1 & 2 & -1   \\\\\n                2 & -3 & -1  \\\\\n                0 & 2 & 3    \\\\\n            \\end{bmatrix}\n            \\cdot\n            \\begin{bmatrix}\n                0 & 10 \\\\\n                1 & 0  \\\\\n                8 & 0  \\\\\n            \\end{bmatrix}\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -6 & 10  \\\\\n                -11 & 20 \\\\\n                26 & 0   \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n$W_1^{new},W_2^{new}$\n\n- 可用 $G_1,G_2$ 梯度更新權重 $W_1,W_2$ 的值，得到新權重 $W_1^{new},W_2^{new}$，\n已知我們採用隨機梯度下降法來進行更新，且學習率為 $0.1$，則\n\n$$\n\\begin{cases}\n    W_1^{new} = W_1 - 0.1 \\times G_1 \\\\\n    W_2^{new} = W_2 - 0.1 \\times G_2 \\\\\n\\end{cases}\n$$\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        W_1^{new}\n        &= \n            W_1 - 0.1 \\times G_1\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -1 & 0 \\\\\n                -1 & 1 \\\\\n                1 & -1 \\\\\n            \\end{bmatrix}\n            - 0.1 \\times\n            \\begin{bmatrix}\n                -6 & 10  \\\\\n                -11 & 20 \\\\\n                26 & 0   \\\\\n            \\end{bmatrix}\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -1 & 0 \\\\\n                -1 & 1 \\\\\n                1 & -1 \\\\\n            \\end{bmatrix}\n            - \n            \\begin{bmatrix}\n                -0.6 & 1  \\\\\n                -1.1 & 2  \\\\\n                2.6 & 0   \\\\\n            \\end{bmatrix}\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -0.4 & -1 \\\\\n                0.1 & -1  \\\\\n                -1.6 & -1 \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n    \\begin{aligned}\n        W_2^{new}\n        &= \n            W_2 - 0.1 \\times G_2\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                1  \\\\\n                -2 \\\\\n            \\end{bmatrix}\n            - 0.1 \\times\n            \\begin{bmatrix}\n                43   \\\\\n                -10  \\\\\n            \\end{bmatrix}\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -1 & 0 \\\\\n                -1 & 1 \\\\\n                1 & -1 \\\\\n            \\end{bmatrix}\n            - \n            \\begin{bmatrix}\n                4.3 \\\\\n                -1  \\\\\n            \\end{bmatrix}\n            \\\\\\\\\n        &= \n            \\begin{bmatrix}\n                -3.3 \\\\\n                -1   \\\\\n            \\end{bmatrix}\n    \\end{aligned}\n\\end{equation}\n$$\n\n---\n\n## [點擊回到導覽頁面](https://4yu.dev/post/Sitemap/)\n\n---","tags":["AI 人工智慧","神經網路 Neural Network","梯度下降演算法","損失函數 Loss func","矩陣 Matrix","激活函數"],"categories":["筆記","AI 人工智慧"]},{"title":"排序演算法 Sort Algorithm (C++)","url":"/post/Sort-Algorithm/","content":"\n現今社會，資料量不斷地增加，因此排序演算法的重要性日益提升，從大數據排序到網路搜尋引擎排序，排序演算法在我們日常生活中扮演了重要的角色。\n\n本文將介紹10種常見的排序演算法，來和我一起學習掌握排序演算法的原理及實作過程吧！\n\n---\n\n\n# 本文架構\n\n## 線性排序演算法種類\n\n1. 氣泡排序 Bubble Sort\n2. 選擇排序 Selection Sort\n3. 插入排序 Insertion Sort\n4. 快速排序 Quick Sort\n5. 合併排序 Merge Sort\n6. 堆排序 Heap Sort\n7. 希爾排序 Shell Sort\n8. 計數排序 Counting Sort\n9. 桶排序 Bucket Sort\n10. 基數排序 Radix Sort\n\n## 每個排序演算法的內容\n\n- 排序介紹\n- 動畫演示\n- 實作步驟\n- C++程式碼\n- 注意事項\n- 時間複雜度\n- 總結\n\n## 測試模板\n下文介紹的 10 種排序演算法都會附上寫好的函式 這裡提供測試模版 在區域中加上各種排序演算法函式即可運作 可 EOF 輸入\n```cpp=\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> v;\n\n// 可以將底下的某個排序演算法函式複製起來放進來這個區域\n// ----------------------------------------------\n\n\n\n\n\n// ----------------------------------------------\n\nint main(void)\n{\n    int n;\n    while (cin >> n) v.emplace_back(n);\n\n    // 這行放入某個排序演算法函式名稱用來呼叫 例如：BubbleSort();\n    // ------------------------------------------\n\n    // ------------------------------------------\n    \n    for (auto &i : v) cout << v[i] << \" \";\n    return 0;\n}\n```\n\n---\n\n# 排序演算法的詳細介紹\n\n## 氣泡排序 Bubble Sort\n\n氣泡排序是一種簡單的排序演算法，它的原理是依序比較相鄰的兩個元素，如果前一個元素大於後一個元素，就交換它們的位置，重複進行直到排序完成。因為排序過程中較大的元素像氣泡一樣慢慢浮到數列的右端，所以叫氣泡排序。\n\n### 實作步驟\n\n1. 外層 for 初始為待排序的數量 每一輪會減少一個 直到全部被排完\n2. 內層 for 表示每輪須比較的次數\n3. 如果前一個數大於後一個數，則使用 swap() 交換它們的位置\n\n### 動畫演示\n\n![BubbleSort 動畫演示](https://hackmd.io/_uploads/HJMv3OadT.gif)\n\n### C++ code\n\n```cpp=\nvoid BubbleSort()\n{\n    int n = v.size();\n    for (int i=n; i>1; --i)\n    {\n        for (int j=0; j<i-1; ++j)\n        {\n            if (v[j] > v[j+1]) \n            {\n                swap(v[j],v[j+1]);\n            }\n        }\n    }\n}\n```\n\n### 優化\n\n外層 for 控制輪數，每輪內層 for 會比較相鄰的元素並交換它們的位置，如果沒有發生交換，就代表數列已經排好序了，可以提前結束，這樣可以減少後面發生不必要的比較\n\n### C++ code\n\n```cpp=\nvoid BubbleSort()\n{\n    int n = v.size();\n    for (int i=n; i>1; --i)\n    {\n        bool check = false;\n        for (int j=0; j<i-1; ++j)\n        {\n            if (v[j] > v[j+1]) \n            {\n                swap(v[j],v[j+1]);\n                check = true;\n            }\n        }\n        if (!check) break;\n    }\n}\n```\n\n\n### 時間複雜度\n\n- 時間複雜度：$O(n^2)$\n    \n    > 每一輪排序都需要進行 $n-i$ 次比較，而最多需要進行 $n-1$ 輪排序。\n    > 因此，總的比較次數為 $(n-1)+(n-2)+...+2+1=(n^2-n)/2$ \n    > 取最高次項所以時間複雜度為 $O(n^2)$\n\n\n### 總結\n\n氣泡排序演算法是一種簡單但效率較低的排序演算法，通常只適用於小規模數據的排序。\n\n## 選擇排序 Selection Sort\n\n選擇排序是一種簡單的排序演算法，它的原理是選擇最小的元素，與第一個元素交換位置，然後在剩下的元素中選擇最小的元素，與第二個元素交換位置，以此類推，重複直到排序完成。\n\n### 動畫演示\n\n![Selection Sort 動畫演示](https://i.imgur.com/VGRenb7.gif)\n\n### 實作步驟\n\n1. 外層 for 遍歷 $0 \\to n-1$ 個元素\n2. 每輪設最小值為第 $i$ 個元素\n3. 內層從 $i$ 開始往後遍歷到底 更新最小值位置\n5. 交換第 $i$ 個元素與最小值位置\n\n### C++程式碼\n\n```cpp\nvoid SelectionSort()\n{\n    int n = v.size();\n    for (int i=0; i<n-1;++i)\n    {\n        int mini = i;\n        for (int j=i; j<n; ++j)\n        {\n            if (v[j] < v[mini])\n            {\n                mini = j;   \n            }\n        }\n        swap(v[i],v[mini]);\n    }\n}\n```\n\n### 時間複雜度\n\n- 時間複雜度：$O(n^2)$\n    \n    > 選擇排序的核心操作是選擇最小元素，將其與當前位置交換，而選擇最小元素需要在未排序的序列中進行線性搜索，因此需要執行 $n$ 次循環和 $n$ 次內層循環，時間複雜度為 $O(n^2)$。\n\n### 總結\n\n選擇排序演算法是一種簡單但效率較低的排序演算法，通常只適用於小規模數據的排序，且較不穩定，如當元素相等時，彼此順序還是會改變。\n\n## 插入排序 Insertion Sort\n\n將未排序的數據依次插入已排序序列中，形成新的已排序序列。\n\n### 動畫演示\n\n![Insertion Sort 動畫演示](https://i.imgur.com/5F2355M.gif)\n\n### 實作步驟\n\n1. for 遍歷 $1 \\to n-1$ 個元素 \n2. 暫時取出 $v[i]$ 為待插入元素 設 $j$ 為插入點 初始為 $i-1$\n3. 用 while 迴圈開始由後往前掃描 確認在範圍內且待插入元素小於掃到的元素\n4. 把掃過的元素往後面搬 且 $j$ 遞減\n5. 若碰到最前面了或是遇到比待插入元素還要大的就退出 while 迴圈\n6. 將 插入點 設為待插入元素 $v[i]$ \n\n### C++ code\n\n```cpp=\nvoid InsertSort()\n{\n    int n = v.size();\n    for (int i=1; i<n;++i)\n    {\n        int temp = v[i], j = i-1;\n        while (j >= 0 && temp < v[j])\n        {\n            v[j+1] = v[j];\n            j--;\n        }\n        v[j+1] = temp;\n    }\n}\n```\n\n### 注意事項\n\n- while 迴圈條件要設定邊界，插入點須 $\\ge 0$。\n\n### 時間複雜度\n\n- 時間複雜度：$O(n^2)$\n    > 要遍歷 $n-1$ 個元素，每次要往前掃瞄並搬動元素\n\n### 總結\n\n插入排序演算法是一種簡單但效率較低的排序演算法，通常只適用於小規模數據的排序。\n\n## 合併排序 Merge Sort\n\n合併排序 Merge Sort 是一種基於分治法的排序演算法，也是一種比較經典且常用的排序演算法之一。\n\n合併排序的主要流程包括分解、排序和合併三個步驟。首先將要排序的序列分成兩部分，分別對這兩部分進行排序，最後將排好序的兩個部分合併起來即可得到排序後的序列。在排序的過程中，通過遞歸地將序列分解成小問題，再利用合併操作將小問題的解合併成原問題的解。\n\n### 動畫演示\n\n![Merge Sort 動畫演示](https://i.imgur.com/cGkLdI8.gif)\n\n### 實作步驟\n\n1. 定義 MergeSort() 將 l、r 作為參數\n2. 算出 mid 拆成兩半 當 l == r 代表已排好可以返回 否則分別遞迴做拆分\n3. 呼叫 merge() 帶入 l,r 將 [l,r] 區間中兩個已排序的數列合併成一個已排序的數列\n4. merge() 先算出 mid 以及建立一個暫存的數列 長度設為合併後的數列長度\n5. for 用兩個指針分別從 l 和 mid 開始遍歷 哪個較小就先放入暫存數列中 注意邊界\n6. 將排序好的暫存數列全部更新至原數列中\n\n### C++程式碼\n\n呼叫時請用 `MergeSort(0,v.size());`\n```cpp\nvoid merge(int l, int r)\n{\n    int mid = (l+r)/2, tmp[r-l+1];\n    for(int i=l,j=mid+1,k=0; i<=mid || j<=r; ++k)\n    {\n        if((v[i] <= v[j] && i <= mid) || j > r) tmp[k] = v[i++];\n        else tmp[k] = v[j++];\n    }\n    for(int i=l,j=0; i<=r; ++i,++j) v[i] = tmp[j];\n}\n\nvoid MergeSort(int l, int r)\n{\n    if(l == r) return;\n    int mid = (l+r)/2;\n    MergeSort(l,mid); MergeSort(mid+1,r);\n    merge(l,r);\n}\n```\n\n### 注意事項\n\n- 注意邊界 在 $merge()$ 中 確保 $i,j$ 兩指針不會跑出兩數列\n- 注意分割遞迴終止條件 是 $l == r$\n- $tmp$ 的長度是 $r-l+1$\n- for 的 $k$ 從 $0$ 開始 取左時 $++i$ 取右時 ++j\n- 比大小時注意要多加上邊界條件 且若右數列取完了就直接取左列元素\n- 最後要把暫存元素更新到原數列中時 注意初始位置\n\n### 時間＆空間複雜度\n\n\n- 平均時間複雜度：$O(n\\log n)$\n    > 在平均情況下，合併排序的時間複雜度為 $O(n\\log n)$。這是因為在合併排序的過程中，每個數據都需要進行一次比較，而且每個數據都需要被移動到新數組中的正確位置，這樣每個數據都需要進行 $\\log n$ 級別的操作。\n\n- 空間複雜度：$O(n)$\n    > 合併排序需要額外的存儲空間來存儲排序過程中的數據，這些存儲空間的大小與待排序數列的大小相同。\n\n### 總結\n\n合併排序是一種高效穩定的排序算法，通過分治的思想，先拆分問題再合併解決。其時間複雜度為 $O(n \\log n)$，在處理大量數據時表現良好。在實作時需要注意指針的起始值、合併區間的邊界問題等細節。\n\n## 快速排序 Quick Sort\n\n快速排序 Quick Sort 是一種常見的分治演算法，被認為是最快的排序演算法之一。它是選擇一個基準元素，通常是中間點，通過一趟排序將待排序列分為兩部分，其中一部分的所有元素都比基準元素小，另一部分的所有元素都比基準元素大，然後再按照此方法對這兩部分分別進行快速排序，直到整個序列有序。\n\n### 動畫演示\n\n本動畫以左邊當基準點\n![Quick Sort 動畫演示](https://i.imgur.com/0WcpwyB.gif)\n\n### 實作步驟\n\n1. 選擇中間點為基準點元素 pivot\n2. 找到左邊大於等於基準點的元素以及右邊小於等於基準點的元素\n3. 如果左邊大於等於右邊，交換它們\n4. 遞迴排序左半部分以及右半部分\n\n### C++程式碼\n\n呼叫時請用 `QuickSort(0,v.size());`\n```cpp\nvoid QuickSort(int l, int r) \n{\n    if (l >= r) return;\n    int i = l, j = r, pivot = v[(l + r) / 2];\n    while (i <= j) \n    {\n        while (v[i] < pivot) i++;\n        while (v[j] > pivot) j--;\n        if (i <= j) \n        {\n            swap(v[i], v[j]);\n            i++; j--;\n        }\n    }\n    QuickSort(l, j); QuickSort(i, r);\n}\n```\n\n### 時間複雜度\n\n\n- 平均時間複雜度：$O(n\\log n)$\n\n    > 在平均情況下，每次切分都能將數列分為近似相等的兩個子數列，快速排序的時間複雜度為 $O(n\\log n)$。\n    > \n- 最壞時間複雜度：$O(n^2)$\n\n    > 當數列已經排好序或接近排好序時，選擇第一個或最後一個元素作為基準元素，時間複雜度會退化為 $O(n^2)$。\n\n### 注意事項\n\n- 需要注意邊界條件，例如遞迴結束的條件。\n- 快速排序是一個不穩定的排序演算法，相同元素的相對位置可能會在排序後發生變化。\n- 在選擇 pivot 時，可以選擇任意一個元素作為 pivot，但選擇哪個 pivot 會影響到排序的效率。如果每次都選擇最小或最大的元素作為 pivot，就會導致最壞情況下的時間複雜度從 $O(n\\log n)$ 暴增為 $O(n^2)$。因此，為了避免這種情況，可以選擇隨機的 pivot，通常選擇數列的中間元素作為 pivot，這樣可以確保每次排序的平均時間複雜度都是 $O(n\\log n)$。\n\n### 總結\n\n快速排序演算法是透過分治，達成高效率的排序演算法。它可以在短時間內對大型數據進行排序。儘管最壞情況下的時間複雜度較高，但在大多數情況下，它的表現都很優秀。\n\n## 堆積排序 Heap Sort\n\n堆積排序 Heap Sort 是一種使用二元樹 Binary Tree 資料結構的排序演算法。\n\n堆可以看作是一個完全二元樹，它具有以下兩個性質：\n\n1. 父節點的值永遠大於或等於（小於或等於）子節點的值。\n2. 堆中任意節點的子樹都符合上述特點。\n\n### 實作步驟\n\n1. 建立堆：將待排序的數列轉換成一個堆。這一步可以通過從最後一個非葉子節點開始，對每個節點進行調整來實現。具體來說，對於一個父節點，如果它的子節點的值比它的值大（或小），就交換它們，直到子樹也是一個堆，調整完成後就得到了一個初始的大根堆。\n2. 排序：從堆的尾部開始，每次取出堆頂元素與堆尾元素交換位置。交換後，堆的長度減1，重複此操作直到堆的大小為1，由於每次都是取出堆頂元素，所以得到的數列就是有序的，以保證元素依然構成一個大根堆。\n\n### C++程式碼\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i; // 初始化最大值為根節點\n    int left = 2 * i + 1; // 找到左子節點的索引\n    int right = 2 * i + 2; // 找到右子節點的索引\n    if (left < n && arr[left] > arr[largest]) { // 如果左子節點的值比最大值還要大\n        largest = left; // 更新最大值的索引為左子節點的索引\n    }\n    if (right < n && arr[right] > arr[largest]) { // 如果右子節點的值比最大值還要大\n        largest = right; // 更新最大值的索引為右子節點的索引\n    }\n    if (largest != i) { // 如果最大值不是根節點\n        swap(arr[i], arr[largest]); // 把最大值交換到根節點\n        heapify(arr, n, largest); // 遞迴對以最大值為根的子樹進行heapify操作\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--) { // 建立最大堆\n        heapify(arr, n, i);\n    }\n    for (int i = n - 1; i > 0; i--) { // 進行堆排序\n        swap(arr[0], arr[i]); // 把最大值與根節點交換\n        heapify(arr, i, 0); // 對剩餘元素進行heapify操作\n    }\n}\n\nint main() {  // 測試堆積排序\n    int n;  // 宣告變數 n 為數列長度\n    cout << \"請輸入要排序的數列長度：\";\n    cin >> n;\n\t\t\n    int arr[n];  // 宣告陣列 arr 用以儲存待排序數列\n    cout << \"請依序輸入數列元素：\\n\";\n    for (int i = 0; i < n; i++) {  // 重複 n 次輸入數值存入陣列 arr 中\n        cin >> arr[i];\n    }\n\n    heapSort(arr, n);\t// 呼叫堆積排序函式對 arr 進行排序\n\n    cout << \"排序後的數列：\\n\";\n    for (int i = 0; i < n; i++) {  // 利用迴圈依序輸出排序後的陣列元素\n        cout << arr[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```\n\n### 時間＆空間複雜度\n\n- 時間複雜度：O(nlogn)\n    \n    > 在堆積排序中，排序的主要操作是下潛，即將堆頂元素下潛到合適的位置，這個操作的時間複雜度是 O(logn)。在排序過程中，需要執行 n 次下潛操作，因此排序的時間複雜度為 O(nlogn)。\n    > \n- 空間複雜度：O(1)\n    \n    > 由於堆積排序是一種原地排序算法，因此它的空間複雜度是 O(1)，即不需要額外的空間。在堆排序中，只需要用到常數個變量作為中間變量，不需要額外的數組或其他數據結構。\n    > \n\n### 注意事項\n\n1. 記得使用交換操作來實現堆的調整和排序。\n2. 調整堆的時候，要先找到子節點中的最大值，然後再和父節點比較，如果子節點的值比父節點大，就將子節點的值上移。\n3. 調整堆的時候，要特別注意邊界情況，例如在定位左右子節點的時候，要判斷右子節點是否存在。\n\n### 總結\n\n堆排序是一種高效的排序算法，它具有良好的時間複雜度和空間複雜度，並且它只需要一個輔助空間來存儲堆，可以實現原地排序，因此堆排序在排序大數據時非常有效。但是在實際應用中，由於堆排序的常數因子比較大，因此實際運行速度可能不如快速排序和插入排序等算法。\n\n## 希爾排序（Shell Sort）\n\n希爾排序（Shell Sort）是一種插入排序的改進版，其基本思想是先將待排序的序列按照一定間隔分成幾個子序列，然後對每個子序列進行插入排序。接著逐步縮小間隔，重複進行上述操作，直到間隔縮小到1時，最後對整個序列進行一次插入排序，完成排序。\n\n希爾排序的主要優點是在比較次數和移動次數上都有所改進。因為希爾排序采用分組的方式進行插入排序，每次排序可以使得一定程度上有序，因此在進行後面的排序時就可以利用前面排序時建立的有序性，減少比較次數和移動次數。此外，希爾排序不需要額外的內存空間，適合在內存較小的情況下進行排序。\n\n### 實作步驟\n\n1. 首先選擇一個增量序列，這個序列的選擇可以影響希爾排序的效率。\n2. 將待排序的序列按照增量序列分成幾個子序列，對每個子序列進行插入排序。\n3. 逐步縮小增量序列，重複上述操作，直到增量為1時，最後對整個序列進行一次插入排序，完成排序。\n\n### C++程式碼\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid shellSort(int arr[], int n) {\n    // 初始化增量gap，設為n/2、n/4、n/8、...直到1\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        // 以gap為間隔，對每個子序列進行插入排序\n        for (int i = gap; i < n; i++) {\n            int temp = arr[i];\n            int j;\n            // 在子序列中進行插入排序\n            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {\n                arr[j] = arr[j - gap];\n            }\n            arr[j] = temp;\n        }\n    }\n}\n\nint main() {  // 測試希爾排序\n    int n;  // 宣告變數 n 為數列長度\n    cout << \"請輸入要排序的數列長度：\";\n    cin >> n;\n\t\t\n    int arr[n];  // 宣告陣列 arr 用以儲存待排序數列\n    cout << \"請依序輸入數列元素：\\n\";\n    for (int i = 0; i < n; i++) {  // 重複 n 次輸入數值存入陣列 arr 中\n        cin >> arr[i];\n    }\n\n    shellSort(arr, n);\t// 呼叫希爾排序函式對 arr 進行排序\n\n    cout << \"排序後的數列：\\n\";\n    for (int i = 0; i < n; i++) {  // 利用迴圈依序輸出排序後的陣列元素\n        cout << arr[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```\n\n### 時間＆空間複雜度\n\n- 時間複雜度：\n    \n    > 希爾排序的時間複雜度取決於子序列的間隔序列（Increment sequence），一般會使用Hibbard增量序列（Hibbard's increment sequence），其公式為：h_k = 2^k - 1，其中k為子序列的索引，h_k為對應的增量。\n    > \n    - 平均時間複雜度：O(n(logn)^2)\n    - 最壞時間複雜度：O(n(logn)^2)\n    - 最佳時間複雜度：O(n)\n- 空間複雜度：O(1)\n    \n    > 希爾排序是一種原地排序算法，只需要一個輔助變量來進行元素交換，因此空間複雜度為O(1)。\n    > \n\n### 注意事項\n\n1. 在實際應用中，希爾排序的實現需要根據具體情況進行優化，選擇合適的增量序列，以及在實現中注意避免不必要的交換和比較操作，從而提高排序的效率。\n2. 增量序列的選擇很重要，通常建議使用Shell提出的增量序列（1, 4, 13, 40, ...），但也可以根據具體情況進行調整。\n3. 插入排序可以使用直接插入排序或折半插入排序，具體選擇哪種排序算法可以根據實際情況進行選擇。\n4. 希爾排序的實現比較複雜，需要較好的理解和熟練的實現技巧。此外，在某些特殊情況下，希爾排序的效率可能會比其他排序算法低，因此在實際應用中需要仔細選擇排序算法。\n\n### 總結\n\n希爾排序是一種高效的排序算法，它通常比傳統的插入排序要快很多，特別是對於大型數據集。希爾排序采用分組的方式進行插入排序，每次排序可以使得一定程度上有序，因此在進行後面的排序時就可以利用前面排序時建立的有序性，減少比較次數和移動次數。\n\n## 計數排序（Counting Sort）\n\n計數排序（Counting Sort）是一種線性時間的排序算法，它可以用於排序一定範圍內的整數。計數排序的核心思想是先統計每個元素出現的次數，然後根據元素出現的次數，將元素排列成有序序列。\n\n### 動畫演示\n\n![計數排序動畫演示](https://i.imgur.com/5iGCVc1.gif)\n\n### 實作步驟\n\n1. 計算待排序數組中每個元素出現的次數。假設待排序的元素範圍為 [0, k]，則可以創建一個長度為 k+1 的計數數組，對於每個出現的元素值，在計數數組中相應的位置上加一。\n2. 對計數數組進行遍歷，依次累加前面所有元素的值，得到每個元素在有序序列中的位置。從計數數組的第二個元素開始，依次將前一個元素的值加到當前元素上，最終得到一個每個元素在有序序列中的位置的累加數組。\n3. 根據計數數組和有序序列的位置信息，將元素依次放入有序序列中。從原數組末尾開始，對每個元素值，從累加數組中取得對應的位置，把該元素放入有序序列中的該位置。每放入一個元素，該位置在累加數組中的值就需要減一。\n4. 將有序序列返回到原數組中。\n\n### C++程式碼\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n// 定義計數排序函數\nvoid countingSort(vector<int>& arr) {\n    int n = arr.size();\n    int max_val = 100;  // 假設元素的範圍為[0,100]\n\n    // 計算元素出現的次數，初始化計數數組為0\n    vector<int> count(max_val + 1, 0);\n    for (int i = 0; i < n; i++) {\n        count[arr[i]]++;  // 計算arr[i]出現的次數\n    }\n\n    // 累加前面所有元素的值，得到每個元素在有序序列中的位置\n    for (int i = 1; i <= max_val; i++) {\n        count[i] += count[i - 1];  // 累加前面所有元素的值\n    }\n\n    // 根據計數數組和有序序列的位置信息，將元素依次放入有序序列中\n    vector<int> result(n, 0);\n    for (int i = n - 1; i >= 0; i--) {\n        result[count[arr[i]] - 1] = arr[i];  // 將arr[i]放到有序序列的對應位置上\n        count[arr[i]]--;  // 將計數數組中對應元素的值減1\n    }\n\n    // 將結果返回到原數組中\n    for (int i = 0; i < n; i++) {\n        arr[i] = result[i];\n    }\n}\n\n// 測試計數排序函數\nint main() {\n    int n;\n    cout << \"請輸入數組的大小：\";\n    cin >> n;\n\n    cout << \"請輸入\" << n << \"個整數，範圍為[0,100]：\";\n    vector<int> arr(n);  // 定義一個整數向量\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    countingSort(arr);  // 呼叫計數排序函式對 arr 進行排序\n\n    cout << \"排序後的數組：\";\n    for (auto num : arr) {\n        cout << num << \" \";\n    }\n\n    return 0;\n}\n```\n\n### 注意事項\n\n- 計數排序只適用於元素範圍較小的情況。如果元素範圍過大，則需要創建過大的計數數組，進而影響排序的效率和空間複雜度。\n- 計數排序是一種穩定的排序演算法。如果待排序數組中有相等的元素，排序後相等元素的相對位置不會改變。\n- 計數排序對於浮點數和負整數排序的支援不好。\n\n### 時間＆空間複雜度\n\n- 時間複雜度：O(n+k)\n    \n    > 計數排序的時間複雜度可以分為兩部分：計數過程和排序過程。首先是計數過程，需要對整個序列進行一次遍歷，把每個元素出現的次數記錄在計數數組中。由於計數數組的大小等於待排序序列的範圍，因此計數過程的時間複雜度為 O(n+k)，其中 n 是序列的長度，k 是序列中元素的範圍。接下來是排序過程，需要遍歷待排序序列，根據計數數組中的信息將每個元素放置到排序好的位置上。由於只需要遍歷一次待排序序列，因此排序過程的時間複雜度為 O(n)。因此，計數排序的時間複雜度為 O(n+k)，其中 n 為待排序元素的數量，k 為待排序元素的最大值。需要注意的是，當範圍 k 比較大時，計數排序的效率可能會比較低。\n    > \n- 空間複雜度：O(k)\n    \n    > 計數排序的空間複雜度主要取決於計數數組的大小 k。因此，計數排序的空間複雜度為 O(k)。需要注意的是，當範圍 k 比較大時，計數排序的空間複雜度也會相應增加。\n    > \n\n### 總結\n\n計數排序是一種高效的排序算法，適用於元素範圍較小的場景，在各種應用中都有著廣泛的應用，例如對於年齡、成績等數值型數據的排序。\n\n儘管它的時間複雜度比其他常用排序算法（如快速排序和合併排序）更小，但是它的應用受到了很大的限制，因為它需要在內存中創建一個大小為k的計數數組，如果k太大，計數數組將占用大量內存。此外，計數排序也不適用於具有負值元素的數組。\n\n## 桶排序（Bucket Sort）\n\n桶排序（Bucket Sort）是一種非常簡單的排序演算法，它的基本思想是將要排序的資料分為幾個桶，每個桶裡的資料都有一定的範圍。然後，對每個桶中的資料進行排序，最後按照桶的順序將所有桶中的資料合併起來。\n\n### 實作步驟\n\n1. 建立一個 vector 來儲存待排序數列。\n2. 找出數列中的最大值和最小值，並算出每個桶的範圍。\n3. 建立桶(bucket)的數量，這裡以 10 個桶作為範例，並建立一個 vector，裡面包含了 10 個子 vector，分別代表每個桶的元素。\n4. 將數據分配到對應的桶中，具體的方法是透過取整和乘法來判斷數據應該放在哪個桶中。\n5. 對每個桶中的數據進行排序，可以使用 std::sort 函式。\n6. 將排序後的數據依次放回原數組中。\n\n### C++程式碼\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid bucketSort(vector<int>& arr) {\n    int n = arr.size();\n\n    // 建立桶(bucket)的數量，這裡以10個桶作為範例\n    const int bucket_num = 10;\n    vector<vector<int>> buckets(bucket_num);\n\n    // 將數據分配到對應的桶中\n    for (int i = 0; i < n; i++) {\n        int index = arr[i] / bucket_num;\n        buckets[index].push_back(arr[i]);\n    }\n\n    // 對每個桶中的數據進行排序\n    for (int i = 0; i < bucket_num; i++) {\n        sort(buckets[i].begin(), buckets[i].end());\n    }\n\n    // 將排序後的數據依次放回原數組中\n    int k = 0;\n    for (int i = 0; i < bucket_num; i++) {\n        for (int j = 0; j < buckets[i].size(); j++) {\n            arr[k] = buckets[i][j];\n            k++;\n        }\n    }\n}\n\n// 測試桶排序函數\nint main() {\n    int n;\n    cout << \"請輸入數列的大小: \";\n    cin >> n;\n\n    vector<int> arr(n);\n    cout << \"請輸入\" << n << \"個整數: \";\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    bucketSort(arr);  // 呼叫桶排序函式對 arr 進行排序\n\n    cout << \"排序後的數列: \";\n    for (auto num : arr) {\n        cout << num << \" \";\n    }\n\n    return 0;\n}\n```\n\n### 注意事項\n\n- 桶的大小設置：桶的大小應當選擇適中的值，太小會增加排序的時間複雜度，太大會佔用過多的空間。\n- 桶的數量：桶的數量應當根據數據的範圍和桶的大小進行設置。桶的數量不夠，會造成數據的堆積；桶的數量太多，會浪費空間。\n- 將數據分配到桶(bucket)中時，要注意取整和乘法的方法，避免產生錯誤。\n- 桶內部排序算法的選擇：桶內部的排序算法可以是任何一種穩定的排序算法，例如插入排序、冒泡排序等等。需要根據具體的應用場景選擇最優的算法。\n\n### 時間＆空間複雜度\n\n- 時間複雜度：O(n+k)\n    \n    > 計數排序的時間複雜度可以分為兩部分：計數過程和排序過程。首先是計數過程，需要對整個序列進行一次遍歷，把每個元素出現的次數記錄在計數數組中。由於計數數組的大小等於待排序序列的範圍，因此計數過程的時間複雜度為 O(n+k)，其中 n 是序列的長度，k 是序列中元素的範圍。接下來是排序過程，需要遍歷待排序序列，根據計數數組中的信息將每個元素放置到排序好的位置上。由於只需要遍歷一次待排序序列，因此排序過程的時間複雜度為 O(n)。因此，計數排序的時間複雜度為 O(n+k)，其中 n 為待排序元素的數量，k 為待排序元素的最大值。需要注意的是，當範圍 k 比較大時，計數排序的效率可能會比較低。\n    > \n- 空間複雜度：O(n+k)\n    \n    > 桶排序的空間複雜度取決於桶的數量和每個桶內部元素的個數。由於每個桶內部的元素個數都不超過n/k，因此每個桶所需的空間是O(n/k)。總空間複雜度就是O(n + k)。如果k接近n，則空間複雜度就會接近O(n)。需要注意的是，當k比較大時，可能會出現空間浪費的情況，因此需要根據具體情況來選擇適當的桶數量。\n    > \n\n### 總結\n\n桶排序是一種簡單但有效的線性時間複雜度排序算法，優點是簡單易懂，而且比較容易實現。桶排序在數據分佈比較集中的情況下效果較好，但當數據分佈比較分散時，則會產生較多的桶(bucket)。適用於待排序數據分布範圍有限的情況。\n\n## 基數排序（Radix Sort）\n\n基數排序是一種非比較排序算法，適用於整數排序。基本思想是根據排序元素的位數，將整數按照位數從低到高或者從高到低進行排序，可以使用桶排序或計數排序等算法來實現。它的排序過程是先從最低有效位開始，依次對每一位進行排序，直到最高有效位。\n\n例如，將一個整數序列按照個位、十位、百位的順序來排序。首先，按照個位進行排序，將序列中所有數字根據個位數分成10個桶，分別把它們放進對應的桶中。然後，按照桶的順序把數字放回原序列中。接下來，再按照十位進行排序，以此類推，直到按照最高有效位進行排序為止。\n\n### 動畫演示\n\n![基數排序動畫演示](https://i.imgur.com/Gn1kHX9.gif)\n\n### 實作步驟\n\n1. 找出數組中最大的元素，確定最高位數，用變數 digit 記錄；\n2. 從最低位數開始，將數組中的元素按照該位數的值放入相應的桶子（桶子數量為 10，分別代表 0~9）中，並計算每個桶子中的元素個數；\n3. 計算每個桶子中元素在暫存陣列中的結束位置；\n4. 把元素按照桶子中的順序放入暫存陣列中；\n5. 把暫存陣列中的元素放回原陣列；\n6. 重複步驟 2~5 直到排序完成。\n\n### C++程式碼\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid radix_sort(vector<int>& arr) {\n    int max = *max_element(arr.begin(), arr.end()); // 找出最大值\n    int digit = 1;\n    vector<int> tmp(arr.size()); // 建立暫存的 vector\n\n    while (max / digit > 0) {\n        vector<int> count(10); // 計數排序用的計數陣列\n\n        // 計算每個桶子中的元素個數\n        for (int i = 0; i < arr.size(); i++) {\n            int bucket = (arr[i] / digit) % 10;\n            count[bucket]++;\n        }\n\n        // 計算每個桶子中元素在暫存陣列中的結束位置\n        for (int i = 1; i < count.size(); i++) {\n            count[i] += count[i-1];\n        }\n\n        // 把元素放入暫存陣列\n        for (int i = arr.size() - 1; i >= 0; i--) {\n            int bucket = (arr[i] / digit) % 10;\n            tmp[count[bucket] - 1] = arr[i];\n            count[bucket]--;\n        }\n\n        // 把暫存陣列中的元素放回原陣列\n        for (int i = 0; i < arr.size(); i++) {\n            arr[i] = tmp[i];\n        }\n\n        digit *= 10; // 到下一個數位\n    }\n}\n\n// 測試基數排序函數\nint main() {\n    int n;\n    cout << \"請輸入數組的大小：\";\n    cin >> n;\n\n    cout << \"請輸入\" << n << \"個整數：\";\n    vector<int> arr(n);  // 定義一個整數向量\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    radix_sort(arr);  // 呼叫基數排序函式對 arr 進行排序\n\n    cout << \"排序後的數組：\";\n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << \" \";\n    }\n\n    return 0;\n}\n```\n\n### 注意事項\n\n- 基數排序適用於位數相同的數列排序，如果位數不同，需將所有數字補齊至相同位數。\n- 每個位數的排序需要使用穩定排序算法，以保證相同位數上的數字相對位置不變。\n- 實作時需要用到桶來存儲數字，桶的數量與基數相同，這將需要額外的空間開銷。\n\n### 時間＆空間複雜度\n\n- 時間複雜度：O(d(n+k))\n    \n    > 其中 d 為最大位數，n 為數組大小，k 為桶子數量，通常為 10（代表數字 0~9）。因為每一位數都要進行一次計數排序，計數排序的時間複雜度為 O(n+k)，所以時間複雜度為 O(d(n+k))。\n    > \n- 空間複雜度：O(n+k)\n    \n    > 基數排序的空間複雜度主要由暫存陣列和計數陣列決定，因此空間複雜度為 O(n+k)。\n    > \n\n### 總結\n\n總結來說，基數排序是一種穩定性較好且時間複雜度為線性的排序算法，但對於數字位數較大的情況下，其空間複雜度較高，可能需要額外的存儲空間。基數排序的優點是能夠處理不同長度的數字，且在數字大小範圍有限的情況下，表現優於快速排序和堆排序。但是，它需要額外的空間儲存桶，且當數字大小範圍非常大時，需要大量的額外空間，並且其時間複雜度也會增加。\n\n# 排序演算法的分類\n\n## 比較排序 Comparison Sort\n\n- 交換類排序 Exchange Sort\n    - 氣泡排序\n    - 快速排序\n- 選擇類排序 Selection Sort\n    - 選擇排序\n    - 堆積排序\n- 插入類排序 Insertion Sort\n    - 插入排序\n    - 希爾排序\n- 合併類排序 Merge Sort\n    - 合併排序\n\n## 非比較排序 Non-Comparison Sort\n\n- 計數排序\n- 桶排序\n- 基數排序\n\n# 排序演算法的比較\n\n| 排序演算法 | 最差時間複雜度  | 平均時間複雜度  | 最佳時間複雜度  | 空間複雜度  | 方式      | 穩定度 |\n| ---------- | --------------- | --------------- | --------------- | ----------- | --------- | ------ |\n| 氣泡排序   | $O(n^2)$        | $\\theta(n^2)$        | $\\omega(n)$          | $O(1)$      | In-place  | ✅     |\n| 選擇排序   | $O(n^2)$        | $\\theta(n^2)$        | $\\omega(n^2)$        | $O(1)$      | In-place  | ❌     |\n| 插入排序   | $O(n^2)$        | $\\theta(n^2)$        | $\\omega(n)$          | $O(1)$      | In-place  | ✅     |\n| 合併排序   | $O(n\\log n)$    | $\\theta(n \\log n)$   | $\\omega(n\\log n)$    | $O(n)$      | Out-place | ✅     |\n| 快速排序   | $O(n^2)$        | $\\theta(n\\log n)$    | $\\omega(n\\log n)$    | $O(\\log n)$ | In-place  | ❌     |\n| 堆積排序   | $O(n\\log n)$    | $\\theta(n\\log n)$    | $\\omega(n\\log n)$    | $O(1)$      | In-place  | ❌     |\n| 希爾排序   | $O(n \\log^2 n)$ | $\\theta(n\\log n)$    | $\\omega(n \\log^2 n)$ | $O(1)$      | In-place  | ❌     |\n| 計數排序   | $O(n+k)$        | $\\theta(n+k)$        | $\\omega(n+k)$        | $O(k)$      | Out-place | ✅     |\n| 桶排序     | $O(n^2)$        | $\\theta(n+k)$        | $\\omega(n+k)$        | $O(n+k)$    | Out-place | ❌     |\n| 基數排序   | $O(n \\times k)$ | $\\theta(n \\times k)$ | $\\omega(n \\times k)$ | $O(n+k)$    | Out-place | ✅     |\n\n\n## 特點與優缺點\n\n| 排序演算法 | 主要特點 | 優點 | 缺點 |\n| --- | --- | --- | --- |\n| 氣泡排序 | 一種簡單的交換排序演算法，每次將相鄰的元素進行比較和交換 | 實現簡單，程式易懂 | 時間複雜度較高，效率低 |\n| 選擇排序 | 每次選出最小（大）的元素放到已排序序列的末尾 | 實現簡單，程式易懂，穩定 | 時間複雜度較高，效率低 |\n| 插入排序 | 將未排序元素逐個插入到已排序的序列中，從後往前比較 | 實現簡單，對小規模資料排序效率高 | 時間複雜度較高，對大規模資料排序效率較低 |\n| 合併排序 | 分治策略，將序列遞迴划分為子序列，然後將子序列合併 | 時間複雜度較低，效率較高，穩定 | 需要較大的輔助空間 |\n| 快速排序 | 分治策略，選定一個基準元素，將序列分為左右兩部分，遞迴排序 | 時間複雜度較低，效率較高，適用於大規模資料排序 | 不穩定，最壞情況下時間複雜度較高 |\n| 堆積排序 | 將序列構建成大根堆（小根堆），每次將堆頂元素與末尾元素交換，重新調整堆 | 時間複雜度較低，效率較高，適用於大規模資料排序 | 不穩定 |\n| 希爾排序 | 插入排序的改進版本，設定一個增量，將序列劃分為若干子序列進行排序 | 對於中等規模資料排序效率較高 | 不穩定 |\n| 計數排序 | 統計序列中各元素的出現次數，根據出現次數和元素值的關係排序 | 時間複雜度較低，適用於數據範圍較小的整數排序 | 對於數據範圍較大的情況需要較大的輔助空間 |\n| 桶排序 | 將元素劃分到不同的桶中，對每個桶中的元素進行排序，最後合併 | 適用於元素值分佈較均勻的情況，時間複雜度較低 | 對於元素值分佈不均勻的情況效率較低 |\n| 基數排序 | 按照元素的位數進行排序，從低位到高位進行排序，每一位使用穩定排序演算法進行排序 | 適用於大規模資料排序且穩定，可以處理多關鍵字排序 | 需要額外的記憶體空間且時間複雜度高，效率較低 |\n\n# 文章總結\n\n在本文中，我們介紹了 10 種常見的排序演算法，每種演算法都有其優點和缺點。在實際應用中，需要根據具體的情況選擇最適合的排序演算法。如果你想學習排序演算法，我建議利用本文章及網路上各種資源，理解各個演算法中的原理，並且嘗試自己實作出這些演算法。通過不斷的練習，你將能更深入地理解這些排序演算法的原理和應用，或許能夠應用來解決現實中的問題，希望此篇文章能讓你有所收穫！\n\n![All 排序動畫](https://i.imgur.com/rvpFvDt.gif)\n\n# 參考資料\n\n- [維基百科：排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)\n- [資料結構和演算法：排序演算法](https://www.csie.ntu.edu.tw/~b98902112/cpp_and_algo/index.html)\n- [菜鳥教程：排序算法](https://www.runoob.com/w3cnote/sort-algorithm-summary.html)\n- [排序算法動畫](https://www.toptal.com/developers/sorting-algorithms)\n- [Sorting Algorithm](https://www.freecodecamp.org/news/sorting-algorithms-explained-with-examples-in-python-java-and-c/)\n- [Sorting algorithms on GeeksforGeeks](https://www.geeksforgeeks.org/sorting-algorithms/?ref=lbp)\n- [15 Sorting Algorithms in 6 Minutes - YT](https://www.youtube.com/watch?v=kPRA0W1kECg)\n\n> 此篇文章因內容繁多，所以在整理資料及撰寫上，可能會有些錯誤，也請大家多留言或善用右側聊天室提出問題，我會馬上勘誤修正，謝謝。\n\n---\n\n## [點擊回到導覽頁面](https://4yu.dev/post/Sitemap/)\n\n---","tags":["C++","實作","時間 & 空間複雜度","排序演算法 Sort Algorithm","氣泡排序 Bubble Sort","選擇排序 Selection Sort","插入排序 Insertion Sort","合併排序 Merge Sort","快速排序 Quick Sort","堆積排序 Heap Sort","希爾排序 Shell Sort","計數排序 Counting Sort","桶排序 Bucket Sort","基數排序 Radix Sort"],"categories":["筆記","程式"]},{"title":"Hello, World.","url":"/post/Hello-World/","content":"## 歡迎來到士育的部落格！\n\n### 網頁介紹\n\n此網頁使用了 [Hexo 靜態網頁框架](https://hexo.io/zh-tw/) \n\n部署在 [Github pages](https://pages.github.com/) 上\n\n我使用的 Theme 主題是 [Butterfly](https://butterfly.js.org/) \n\n創建日期為 2022/12/01（國一）版本使用 4.5.1（已在 2025/07/06 升級為 5.4.1）\n\n### 網頁用途\n\n這裡是我的程式筆記網頁\n\n內容包括我所學到的 資料結構 演算法 \n\n不會有程式語言基礎語法 因為網路上資源多且詳細\n\n筆記中的內容或許會有小錯誤或不完整 所以我會不斷的更新修改\n\n我也會不定期的發佈 程式解題 知識筆記 還有各種心得紀錄 ...\n\n有興趣的人可以參閱其他文章或到上方其他頁面看看\n\n如果你對文章有任何想法或建議 歡迎在文章下方評論區登入 Github 帳號 留下你的看法\n\n或是可以直接使用右下角的 線上聊天室功能 傳訊息給我 我會盡快回覆你的訊息\n\n若你想開始學程式 請到上方 link 連結 的頁面 我有放許多資源可以提供你學習\n\n提供的資源涵蓋 各種程式語言的基礎語法 以及各種程式相關平台 工具...\n\n以及各個程式社群的 Discord 伺服器\n\n希望能對你有所幫助 ！\n\n### 網址\n\n```\nhttps://4yu.dev\n```\n\n---\n\n## [點擊回到導覽頁面](https://4yu.dev/post/Sitemap/)\n\n---"}]